[{"title":"聊天项目(一) GateServer","url":"/2024/09/17/计算机/聊天项目-一-GateServer/","content":"\n# 1. Main函数的初始化\n\nGateServer 既作为服务器，又作为客户端：\n\n- 作为聊天客户端的网关服务器\n- 作为gRPC的客户端，gRPC的客户端比较简单，不需要在 Main 函数中进行初始化\n  - 邮箱验证服务\n  - 状态查询服务\n\nMain 函数中需要连接 Reids 服务器和 MySQL 服务器：\n\n```c++\nMysqlMgr::GetInstance();\nRedisMgr::GetInstance();\n```\n\n<!-- more -->\n\nMain 函数中需要实现上下文的初始化和服务器的优雅关闭：\n\n- 需要一个上下文服务来轮询事件，只负责关闭信号和 acceptor（注意并没有从服务池里面取）： `net::io_context ioc ` \n- 需要设置信号来优雅关闭服务器：`boost::asio::signals_set signals(ioc, SIGINT, SIGTERM)` 以及 `signals.async_wait()` \n\nMain 函数中开启服务器：\n\n```c++\nmake_shared<CServer>(ioc, gate_port)->Start();\n//在 Start 里面由于会执行异步的监听函数，所以会注册一个事件循环\n//所以 ioc 不会退出\nioc.run();\n```\n\n# 2. CServer的执行逻辑\n\nCServer 一共就只有两个函数，一个是构造函数用于初始化 acceptor 这个 socket，一个是 Start 函数用于监听并把连接丢给一个新的 CSession的成员变量 socket，在一个新的线程中进行通信。\n\nCServer 在初始化的时候会初始化一个 acceptor 来监听连接。 acceptor 会在指定端口监听连接，要通过绑定端点来实现，任意 IP 地址的连接都能够监听：\n\n```\nCServer::CServer(boost::asio::io_context &ioc, unsigned short& port):_ioc(ioc), _acceptor(ioc, endpoint(ip::v4, port)){}\n```\n\n要在 Start 函数中监听连接，并通过 acceptor 把新来的连接派发给不同的上下文，这些都交给 CSession 类来管理（包含 socket），因此需要在 CServer 的函数中创建一个 CSession 对象：\n\n```c++\nCServer::Start(){\n\t//从池中取一个上下文，这是一个服务池，本质上是一个线程池，每一个线程都跑一个服务\n\tauto& ioc = AsioIOServicePool::GetInstance()->GetIOService();\n\t//创建一个连接对象管理连接\n\tshared_ptr<CSession> new_con = make_shared<CSession>(ioc);\n\t//通过 lambda 表达式注册回调函数\n\t//self 很关键，在值捕获的时候能够使智能指针的引用技术加 1，所以能够实现伪闭包的操作\n\tauto self = shared_from_this(); // 需要在定义类的时候继承 enabled_shared_from_this\n\t_acceptor.async_wait(new_con->socket, [self, new_con](ec){\n\t\t//这个 new_con 运行在一个单独的线程中，因为它的上下文 ioc 是在一个线程池中创建的\n\t\tnew_con->Start();\n\t\t//继续监听连接\n\t\tself->Start();\n\t})\n}\n```\n\n> 注意：`std::make_shared` 直接创建并返回一个 `std::shared_ptr` 对象，相较于 `new` ，其拥有更高的效率，只涉及到一次分配（分配 `T` 类型的内存），而 `new` 需要分配两次，（一次分配 `T` 类型的内存，一次分配 `shared_ptr` 的内存）。\n\n# 3. CSession的执行逻辑\n\n网关服务器是在 CSession 中和客户端进行 HTTP 通信的，而在建立 CSession 连接之前是通过 TCP 进行通信的。CSession 的成员函数：\n\n- Start\n- PreParseGetParam\n- HandReq\n- WriteResponse\n- CheckDeadline\n\n## 3.1 HTTP 接收\n\n因为客户端发送的是数据是基于 HTTP 协议的，所以不需要像后面对 TCP 进行手动的切包操作，而是直接使用 beast 库进行读取就可以了：\n\n```c++\nauto self = shared_from_this();\n// 一定要传入 request 参数，这样就能够把客户端的请求放到 request 中\nhttp::async_read(_socket, _buffer, _request, [self](){\n    //数据的处理调用\n    self->HandleReq();\n    self->CheckDeadline();\n})\n```\n\n## 3.2 HTTP 的解析和注册函数调用\n\n读到数据之后需要在 HandleReq 中初步处理 HTTP 请求，然后会解析出请求类别，并在回调函数中进行数据的处理。HandleReq 的解析过程中，需要一边解析一边设置响应报文的 `状态行` ，`消息头`， 和 `消息体` 。要如何处理呢？主要是根据 HTTP 的 `method` 来进行解析，解析完之后交给逻辑类进行处理（这里不需要再为逻辑类单独创建线程了，因为本来服务就是跑在多个线程的）：\n\n```c++\nvoid CSession::HandleReq(){\n\t//设置版本\n\t_response.version(_request.version());\n\t//设置为短链接\n\t_response.keep_alive(false);\n    if(_requeset.method() == http::verb::get){\n        //!!!! HTTP URL 的解析 !!!\n        PreParseGetParam();\n        //交给逻辑类中的 HandleGet 处理\n        bool success = LogicSystem::GetInstance()->GetInstance()->HandleGet(_get_url, shared_from_this());\n        //设置响应报文的状态\n        _response.result(http::status::ok); // 设置状态码为200 OK\n        _response.set(http::field::server, \"GateServer\"); // 设置服务器头为GateServer\n        WriteResponse();\n    }\n    else if(_requeset.method() == http::verb::post){\n        //直接从逻辑类取函数就行了，不需要解析 URL\n        bool success = LogicSystem::GetInstance()->HandlePost(_request.target(), shared_from_this());\n        WriteResponse();\n    }\n}\n```\n\n这里需要设置响应报文的几个状态，记住：\n\n- 设置版本\n- 设置为短链接\n- 设置状态码：200 ok\n- 设置服务器头，也就是 Host\n\n注意：这里只有当 get 请求的时候才会调用 URL 解析函数，而 post 请求的时候直接调用回调函数就可以了。 这个聊天项目中的 request.target() 就是 URI ，并且没有设置参数，返回？前的字符串就得到了 URL 。HTTP 的路由解析函数：\n\n> 什么是URI？什么又是URL？\n\n```\n1. 提取URI：\n   - 从HTTP请求中获取目标URI（_request.target()）。\n2. 查找查询字符串起始位置：\n   - 使用find方法找到查询字符串开始的位置（即?的位置）。\n3. 分离路径与查询字符串：\n   - 如果没有查询字符串（即没有?），则整个URI作为路径存储到_get_url中。\n   - 如果存在查询字符串，则分割URI为路径部分和查询字符串部分，并分别存储到_get_url和query_string变量中。\n4. 解析查询字符串：\n   - 使用find方法查找&字符的位置，这标志着一个键值对的结束。\n   - 每次循环中，从当前查询字符串中截取出一个键值对。\n   - 使用find方法找到等号（=）的位置，将键值对分割成键和值两部分。\n   - 对键和值进行URL解码（假设有一个UrlDecode函数）。\n   - 将解码后的键值对存储到_get_params哈希表中。\n   - 移除已处理过的键值对及其后面的&字符，继续处理剩余的查询字符串。\n5. 处理最后一个键值对：\n   - 如果查询字符串中没有&字符，则认为这是最后一个键值对，对其进行相同的处理。\n```\n\n## 3.3 HTTP 注册的回调函数\n\n需要根据 HTTP 的路由来判断客户端的请求类别，这些请求的执行函数需要提前在逻辑类的初始化函数中注册，这样才能够调用。包含以下请求：\n\n- \"/get_varifycode\"\n- \"/user_register\"\n- \"/reset_pwd\"\n- \"/user_login\"\n\n以下是这4个回调函数的具体代码逻辑。\n\n### 3.3.1 get_varifycode\n\n### 3.3.2 user_register\n\n### 3.3.3 reset_pwd\n\n### 3.3.4 user_login\n\n\n\n# 4. 逻辑类的函数\n\n逻辑类的构造函数中会注册上述四个请求的回调函数，除此之外还包含4个成员函数：\n\n- RegGet：通过 insert 操作把路由和相对应的回调函数插入到 Get 哈希表中\n- RegPost：通过 insert 操作把路由和相对应的回调函数插入到 Post 哈希表中\n- HandleGet：直接通过 key 从 Get 哈希表中取出回调函数来执行\n- HandlePost：直接通过 key 从 Post 哈希表中取出回调函数来执行\n\n\n\n","tags":["C++聊天项目"],"categories":["计算机"]},{"title":"Man/machine interface based on the discharge timings of spinal motor neurons after targeted muscle reinnervation","url":"/2024/04/11/论文/Control/Man-machine-interface-based-on-the-discharge-timings-of-spinal-motor-neurons-after-targeted-muscle-reinnervation/","content":"\n肌肉接口通常只有在截肢后有相关残余肌肉组织可用时才可能。截肢程度越高，对控制信号的需求就越大，可用于进行直观控制的肌肉就越少。尽管如此，肌肉可以被用来将神经代码传递到缺失肢体的神经去神经化和再神经化。这种手术被称为靶向肌肉再支配（TMR），它是假肢的一个突破。\n\n增加激活水平的两种生理机制：额外运动神经元的募集和活动运动神经元放电频率的调节。运动神经元放电时序已被汇集以获得所有运动神经元的放电时序的集合，作为神经驱动的估计。","categories":["论文","Control"]},{"title":"Cumulative Spike Train Outperforms the Root-Mean-Square Metric in Muscle Excitation Estimation  from Dynamic High-Density EMG","url":"/2024/02/27/论文/Dynamic/Cumulative Spike Train Outperforms the Root-Mean-Square Metric in Muscle Excitation Estimation from Dynamic High-Density EMG/","content":"\n尽管平均校正值（ARV）和均方根值（RMS）随着募集的运动单元（MU）的数量及其发射率单调增加。它们不区分这些激活模式和运动单元动作电位（MUAP）的影响。这在动态肌肉收缩中变得有问题，因为肌肉的几何变化会导致 MUAP 形状的变化。因此，<mark>在 RMS 和 ARV 指标中，MUAP 的变化很容易被误认为是肌肉兴奋模式的变化</mark>。据我们所知，MUAP 变化对 ARV 或 RMS 指标的影响尚未系统量化。\n\n更先进的肌肉兴奋技术建立在通过分解 hdEMG 信号直接识别 MU 发放序列的基础上。这些技术将 MUAP 与兴奋模式完全分离，但在很大程度上仅在等长肌肉收缩上进行了测试。没有详细研究动态条件，主要是由于缺乏可靠的动态 hdEMG 分解技术。\n\n<mark>我们量化了 MUAP 对基于 RMS 的 hdEMG 肌肉兴奋估计的负面影响</mark>。RMS 度量在等距和动态条件下均产生14%的NRMSE（图1和图2）。即使只有5个已识别的 MU，基于 CKC 的 CST 也显著优于 RMS 度量。NRMSE 随着识别的 MU 的数量而进一步降低。\n\n\n\n\n\n","tags":["动态"],"categories":["论文","Dynamic"]},{"title":"On the Impact of Spike Segmentation on Motor Unit Identification in Dynamic Surface Electromyograms","url":"/2024/02/23/论文/Dynamic/On the Impact of Spike Segmentation on Motor Unit Identification in Dynamic Surface Electromyograms/","content":"总结就是：先选一段信号区间用于估计初始参数，然后再在各个区间上改进参数。\n\n提出了一种新的动态hdEMG卷积数据模型，以及用于评估MU识别准确性和分析动态肌肉收缩中MU动作电位（MUAP）变化对MU识别的影响的脉压比（PNR）指标。我们在不同的动态收缩速度下，对来自肱二头肌、股外侧肌和股直肌的信号测试了所提出的方法。\n\n当考虑MU发射时间的预先存在的知识时，可以显著提高尖峰分割方法的鲁棒性。例如，在处于相对恒定收缩水平的健康人体肌肉中，MU发射频率相对恒定。棘间距的标准偏差在平均棘间距的10%到30%之间[5]。不幸的是，这不适用于病理情况或快速肌肉收缩的情况，在这些情况下，这种额外知识的实施会大大降低MU尖峰分割的准确性。\n\n<!-- more -->\n\n1. **什么是等长收缩**：the geometry of the recorded muscle does not change significantly [5]. This guaranties relatively stationary MUAPs that can be identified either by template matching or blind-source separation (BSS) EMG decomposition methods.\n2. **动态收缩的情况**：In dynamic muscle contractions, muscle fibers shorten and slide below the skin surface (and below the electrode array), causing the changes in detected MUAPs.\n3. **动态和静态的区别**：在一个恒等的收缩水平下，MU的发放频率是保持不变的， $ISI$ 的标准差只有10%-30%。但是这在肌肉快速收缩或者病态的情况下是不成立的\n\n**高密度肌电的建模**：\n$$\n\\mathbf{y}(n)=\\overline{\\mathbf{H}}\\overline{\\mathbf{t}}(n)+\\Delta\\mathbf{H}(n)\\bar{\\mathbf{t}}(n)+\\mathbf{~}\\mathbf{\\omega}(n)\n$$\n这个模型是等长收缩模型的推广，在等长收缩中，$\\Delta \\mathbf{H}(n)$ 这一项代表的是 $\\overline{\\mathbf{H}}$ 和真实的 $\\mathbf{H}$ 之间的差异。这个差异在动态收缩中是随时间变化的，但是在等长收缩中，可以视为误差项。\n\n**动态下的衡量指标是什么**：PNR does not assume or favor any MUfiring patter and can, thus, be used equally good in pathological or any other condition with highly irregular MU firing patterns.\n\n目前在实验条件下还不可能验证动态表面肌电分解。即，与等距收缩不同，在动态条件下，表面肌电和侵入式肌电同时采集和分解的双源验证方法是不可能的。因此本文采用合成肌电进行分解，合成的高密度表面肌电信号根据圆柱形体积导体模型产生。\n\n当考虑 MU 发射时间的先验知识时，可以显著提高尖峰分割方法的鲁棒性。例如，在处于相对恒定收缩水平的健康人体肌肉中，MU 发射频率相对恒定。脉冲间距的标准偏差在平均棘间距的 10% 到 30% 之间。不幸的是，这不适用于病理情况或快速肌肉收缩的情况，在这些情况下，<mark>这种额外知识的实施会大大降低 MU 尖峰分割的准确性。</mark>","categories":["论文","Dynamic"]},{"title":"A new method for high-density surface electromyography decomposition in dynamic muscle contraction","url":"/2024/02/22/论文/Dynamic/A new method for high-density surface electromyography decomposition in dynamic muscle contraction/","content":"目前分解的主流方法有两种，这两种方法主要应用于静态收缩（肌肉恒力收缩）或者肌力缓慢变化的情况：\n\n- 基于模板匹配的模式识别方法\n- 盲源分离方法\n\n动态收缩时，由于电机相对位置的变化以及肌纤维长度的改变，导致 MUAP 发生变化。目前有少数学者对肌肉动态收缩 sEMG 信号进行了研究，Glaser 等[6]提出卷积核分解方法，该方法将 sEMG 信号分段，采用线性函数得到发放时刻，但是发放时刻分类仍然存在问题。 Glaser 等[7]还提出了基于 MU 波形非传输分量的分解算法，但由于传输分量与非传输分量的分离存在难度，实现比较困难。DeLuca 等[8]使用机器学习算法分解 sEMG 信号，但是 MU 波形变化影响因素众多，难以预测，所以识别仍然较困难。\n\n**带通滤波频带范围**：10-500 Hz","categories":["论文","Dynamic"]},{"title":"Motor Unit Identification From High-Density Surface Electromyograms in Repeated Dynamic Muscle Contractions","url":"/2024/02/22/论文/Dynamic/Motor Unit Identification From High-Density Surface Electromyograms in Repeated Dynamic Muscle Contractions/","content":"本文引入了MUAP变化的MU特异性测量，该测量可以直接在已识别的MU spikes中使用，并且不依赖于肌肉几何形状或关节角度的任何外部测量。PNR同样适用于动态下的分解效果评估。<mark>所引入的方法对MUAP变化和肌肉收缩速度表现出相当大的稳健性。</mark>\n\n由于EMG混合过程的复杂性，通常由卷积多输入多输出系统建模，个体MU发放模式的识别在很大程度上<mark>仅限于等长肌肉收缩</mark>，其中肌肉和周围组织的几何形状不会发生显著变化。在这种条件下，由电极获取的MU动作电位（MUAP）是相对稳定的，并且主要的EMG非平稳性来自MU的募集和放电速率调制。在动态收缩中，MUAP 形状改变的两个因素：  \n\n- 肌肉缩短会影响动作电位在肌肉连接处终止的潜伏期，从而导致MUAP成分不传导；\n- 肌肉纤维和摄取电极之间的距离随着肌肉缩短而变化。这两个因素都会影响检测到的MUAP形状。\n\n<!-- more -->\n\n---\n\n*2024/3/27*\n\n- 该算法的步骤是怎样的？\n\n  该算法首先是选取一段小区间，这段小区间上的 $\\Delta{H}$ 可以视为噪声，然后使用传统的 CKC 算法可以分解得到不同的 MU。关键在于怎样去追踪这个 MU。算法分为两步：\n\n  - 先寻找 PNR 值接近的区间，这样的区间和初始区间有着相似的混合矩阵（这样的区间可不可以直接用 gCKC 算法分解出来？）。\n  - 然后需要寻找别的区间，这涉及到 MUAP 的缓慢变化，因此需要设置一个加权函数 f，当权重在右边时，右边的相关向量占主要成分，所以会以右边的 MUAP 波形为基础去寻找下一个区间\n\n---\n\n> Due to the complexity of the EMG mixing process, which is typically modelled by convolutive multiple-input-multiple-output system [12]–[15], identification of individual MU firing pattern has been largely limited to isometric muscle contractions, in which the geometry of the muscle and surrounding tissue does not change considerably. In such conditions, the MU action potentials (MUAPs), acquired by the uptake electrodes are relatively stationary and the main EMG nonstationarity comes from the MU recruitment and firing rates modulation.  \n\n上述表明，之前的 MU 分解都限制在等长收缩（肌肉的几何尺寸不变，周围的组织变化很小），在这种情况下，MUAP 是相对静态的，主要的非静态来自于 MU 的募集和发放频率的调制。如果连发放频率和募集都是恒定的，那么就说收缩是完全静态的。\n\n# hdEMG的动态建模\n\n在`等长非疲劳性`肌肉收缩中，可以假设混合矩阵 $\\mathbf{H}(n)$ 是静止的。在这种情况下，经典的 hdEMG 分解技术，如 CKC，可以应用于整个 hdEMG 信号。在<mark>缓慢的动态肌肉收缩</mark>和<mark>长时间的等长收缩</mark>中，由于几何变形或肌肉疲劳，MUAP 形状逐渐变化，因此，<mark>hdEMG 需要被划分为 $\\mathbf{H}(n)$ 没有显著变化的足够短的时期</mark>。因此，经典的 hdEMG 分解技术需要独立地应用于每个信号历元。在典型的设置中，<mark>信号区间重叠 50%</mark>，以支持从不同的 hdEMG 区间识别的 MU 尖峰序列的不同片段能够有效合并。在<mark>中等和快速的动态收缩</mark>中，$\\mathbf{H}(n)$ 变得非平稳，但在某种意义上仍然遵循局部性原理，即它逐渐变化，并且这些变化可以用<mark>连续函数</mark>来建模。\n\n注意本文对 $H(n)$ 进行了重新建模：\n$$\n\\begin{gathered}\n\\text{y(n)} =\\bar{\\mathbf{H}}\\bar{\\mathbf{t}}\\left(n\\right)+\\Delta\\mathbf{H}(n)\\bar{\\mathbf{t}}\\left(n\\right)+\\boldsymbol{\\omega}\\left(n\\right) \\\\\n=\\bar{\\mathbf{H}}\\bar{\\mathbf{t}}(n)+\\mathbf{z}(n)+\\omega(n)\n\\end{gathered}\n$$\n\n这里的 $\\Delta\\mathbf{H}\\left(n\\right)\\mathbf{\\bar{t}}\\left(n\\right)$ 可以视作模型误差，$\\bar{\\mathbf{H}}$ 是 $\\mathbf{H}(n)$ 在区间内的平均。<u>在重复非疲劳实验中，$\\Delta\\mathbf{H}$ 和 $\\mathbf{H}$ 是重复的，但是 $\\mathbf{z}(n)$ 不是重复的，因为还取决于 $\\bar{\\mathbf{t}(n)}$</u> 。但是结果表明 $\\mathbf{z}(n)$ 的相关矩阵能部分反应周期重复性。\n\n# MUST的估计\n\n总结一下估计方法：分为<mark>区间内和区间外</mark>，区间内是寻找 PNR 值接近的区间（<font color = 'red'>本质是寻找 $\\mathbf{H}$ 接近的区间，$\\mathbf{H}$ 代表的是 MUAP，$\\mathbf{H}$ 接近说明 MUAP 接近，也就是说 MUAP 近似没有改变</font>），然后重新求解参数。也就是说，只要把区间选的足够小，那么就可以把 hdEMG 视为静态的。\n\n## 区间内估计\n\n1. 第 $j$ 个 MU 的 spike train 的估计等式为：\n\n$$\n\\hat{t}_j\\left(n\\right)=\\mathbf{c}_{\\mathrm{t_j}\\mathbf{y}}^{\\mathrm{T}}\\mathbf{C_y}^{-1}\\mathbf{y}(n)\n$$\n\n2. 在区间[a1, a2]上，通过梯度下降法得到 $\\mathbf{c}_{t_j\\boldsymbol{y}}$ ，进而估计 $\\hat{t_j}\\left(n_a\\right)$ \n3. 重求 $\\mathbf{c}_{t_j\\boldsymbol{y}}$ 为 $\\begin{aligned}\\mathbf{c}_{t_j\\boldsymbol{y},n_a}&=\\sum_{n_a\\in[a_1,a_2]}t_j\\left(n_a\\right)\\boldsymbol{y}\\left(n_a\\right)\\end{aligned}$ ，并重新估计 $\\hat{t}_{j,n_a}\\left(n\\right)$ \n4. 寻找 PNR 接近的区间，在全部区间上重新求步骤 3 中的参数（PNR 会随着 $\\Delta\\mathbf{H}(n_a)$ 和 $\\Delta\\mathbf{H}(n_b)$ 之间差异的增大而减小，因此 PNR 只是一个代替指标，用来寻找 $\\mathbf{H}(n_a)$ 和 $\\mathbf{H}(n_b)$ 接近的区间。等式中的 PNR 值取决于所有 hdEMG 通道中第 j 个 MU 的 MUAP 的形状。因此，局部 PNR 允许对具有相对恒定的 $\\mathbf{c}_{t_j\\boldsymbol{y}}$ 和 $\\mathbf{C}_y$ 的时间间隔进行MU特定的选择。\n\n> Δa was fixed to 1/5 of the contraction ramp (see the next section), whereas the number of decomposition runs in step 12 was fixed to 100\n\n## 区间外估计\n\n通过一个加权函数来使得区间中不同位置的 spike 被放大，最后把所有识别到的所有 spikes 都加在一块。移动区间 [a1, a2]，不断寻找。\n\n# 实验\n\n## 仿真数据集：\n\n仿真数据集就是先逐段分解出 MUAP，通过重叠来匹配MUAP，从而得到一个 MUAP 库，这个库中的 MUAP 有一个动态的变化，使用这个库中的 MUAP 来合成 repeated dynamic EMG（注意分解的范式和合成的范式是不一样的）。\n\n- 志愿者进行了80秒长的缓慢等速收缩，从肘部完全伸展开始，到肘部完全弯曲结束。肌肉收缩的范式包括完全伸展-屈曲斜坡。<mark>带通滤波范围：20-700 Hz</mark>\n- 记录的信号被划分为10s长的历元，具有50%的重叠。通过 CKC 分解技术独立地分解每个历元，并成对比较所识别的MU尖峰序列，以识别整个80s记录信号上的MU发射模式。他们的 MUAP 是通过36个连续10秒长的 EMG 周期的尖峰触发平均值来估计的，这些周期重叠7.8秒。（注意，计算 MUST 和 MUAP 时的步长时不一样的，但是都是以10 s为一个 epoch）\n- 仿真了 60 s的肌肉兴奋。在生成了 spike 后（MU firing rate 峰值为 35，意味着最小的 spike interval 为 30ms 左右），与 MUAP 库中的动态波形卷积得到仿真的 dynamic EMG。<mark>斜坡的数量设置为2、3、6和12</mark>，分别对应在15、10、5和2.5秒内实现肌肉完全伸展/屈曲。为了符合小的，远的 MU 常常淹没在生理噪声中这种情况，所有的 MUAP 被乘以了一个系数。\n\n## 实验数据\n\n- 5个人，4男1女\n- 两个64通道电极，13×5，5列电极平行于肌纤维\n\n在每次试验中，受试者进行<mark>重复的</mark>膝盖屈伸运动，将1公斤的重量固定在主腿的脚踝上。通过Fastrak运动跟踪器（Polheus，USA）测量膝关节角度，参考膝关节角度以稳定的速率从100度变化到160度，并在10秒内（中速）和20秒内（缓慢收缩）恢复。这里180度对应于膝盖的完全伸展。踝关节以100度角固定。每个试验包括<mark>八次（中速）或四次（慢速）</mark>连续重复所述膝盖运动，在整个试验过程中连续记录肌电图，并连续跟踪膝盖角度。至少 5 分钟间隔用来休息。\n\n# 结果\n\n- All the identified MUs extensively changed their MUAPs with muscle shortening.\n\n- MUAP 的改变程度不仅特定于肌肉和收缩，还特定于 MU，这说明不同条件下 MUAP 的改变程度不同：\n\n  > the extent of MUAP changes in dynamic contractions is not only muscle and contraction, but also MU specific.  \n\n  但是， 有的 MU 即使 MUAP 改变了， 也不影响它的 MUST 的识别，能够在整个周期上识别出来，如后图所示：  \n\n  > the impact of the MUAP changes on identified MU spikes is MU specific.\n\n- 分解对MU是特异性的，<mark>有的 MU 可以在整个收缩周期被分解出来，但有的 MU 只能在某一段强度下分解出来</mark>。  \n  ![image-20240225204647387](Motor Unit Identification From High-Density Surface Electromyograms in Repeated Dynamic Muscle Contractions/image-20240225204647387.png)  \n  ![image-20240225204750539](Motor Unit Identification From High-Density Surface Electromyograms in Repeated Dynamic Muscle Contractions/image-20240225204750539.png)\n  \n- 脉冲噪声比 PNR，先前引入用于测量等长肌肉收缩中MU识别的准确性，也可应用于动态条件。PNR反应了 spike train 中 spike 的高度，spike 的高度越高，那么 PNR 值就越大。。sensitivity 和 precision 与 PNR 成正相关，false alarm 和 PNR 值成负相关。PNR > 30 dB 时，灵敏度和准确度 > 90%，误报率 < 1%，这个在等长收缩时的特性在动态收缩中依然保留了下来，尽管明确指出 PNR 值在肌肉收缩、MUAP 改变时会受到影响。因此，PNR ≥ 30 dB 的标准应使用在局部 PNR 中，而在灵敏度 > 90%的 MU 中经常观察到相当低的全局PNR值（图6）。\n\n- 发力斜坡的长度并不能决定分解出的 MU 个数、PNR 值，以及灵敏度和准确度，说明这种算法对<mark>肌肉的收缩速度是鲁棒的</mark>。但是兴奋程度越高识别到的 MU 越多。\n\n- 与所提出的循环平稳CKC相比，经典的 CKC 方法识别出更多的 MUs ，但灵敏度明显较低(图5)。这与图 3 中识别出的 spike 序列的例子一致。\n\n- <mark>实验范式设置参考</mark>：MU 分解对曲线重复次数的敏感性是特定于肌肉和收缩水平的。一般来说，运动速度越高，所需的运动重复次数就越大。值得注意的是，运动重复不需要具有与伪码1的步骤6中实现的MU跟踪相同的持续时间，该MU跟踪在每个运动重复中自动确定用于MU尖峰识别的最佳时间支持。\n\n- 与传统 CKC 的区别：传统的 CKC 是作用于整个信号，通常不能完整地识别出所有的 spikes。CKC 算法的循环次数一般设置为100。而 csCKC 算法识别出的 spike 更多。  \n  ![image-20240226215147388](Motor Unit Identification From High-Density Surface Electromyograms in Repeated Dynamic Muscle Contractions/image-20240226215147388.png)\n  \n- PNR 这个标准可以用于任何复杂的肌肉收缩。\n\n# 还有哪些工作可以做\n\n- 没有试图解释同心和偏心期MU发射率的差异，也没有试图解释股外侧肌和股直肌中MU发射模式之间的差异。这些解释需要大量的重复肌肉收缩，超出了本研究的范围。\n- 未来需要进一步的研究来评估所述方法在不同骨骼肌中识别MU的适当性，并分析其对肌肉收缩重复次数的敏感性。\n- Validation of dynamic surface EMG decomposition is currently an open research problem.  \n\n","categories":["论文","Dynamic"]},{"title":"数据采集卡","url":"/2024/01/19/实验/数据采集卡/","content":"# 1 单双通道\n\n- 单通道：当采样通道总数量（nSampChanCount）等于 1 时，通道组内只有一个通道配置信息，即为单通道采集。  \n- 多通道：当采样通道总数量大于 1 时，通道组内有多个通道配置信息，则为多通道采集。如果用户使能 2、 0、 1 通道，则数据排列方式：\n  通道 2 数据 0、通道 0 数据 0、通道 1 数据 0\n  通道 2 数据 1、通道 0 数据 1、通道 1 数据 1\n  通道 2 数据 2、通道 0 数据 2、通道 1 数据 2 \n  \n# 2 参数选择\n## 2.1 nSampChanCount\n\n采样通道数量 (Sample Channel Count)，进入采样过程的通道个数，取值范围[1, 8]。即决定了 CHParam[]通道组阵列中有效单元的个数。若 nSampChanCount=1, 则表示仅 CHParam[0]单元决定的物理通道号有效; 若 nSampChanCount=2，则表示仅 CHParam[0]、CHParam[1]两个单元决定的物理通道号有效; 若 nSampChanCount=3，则表示仅 CHParam[0]、CHParam[1]、CHParam[2]三个单元决定的物理通道号有效，依次类推。\n## 2.2 nSampsPerChan\n\n**连续采样模式:** 决定着触发采样事件 hSampEvent 时的点数条件。\n\n比如指定该参数值为 1024点，则每采样到不小于 1024 点时就会触发采样事件 hSampEvent，它也决定着每次调用 AI ReadAnalog()或 AIreadBinary()时能最快返回的点数边界 (<mark>请注意:是不小于 nSampsPerChan，意思是不可能正好等于 nSampsPerChan 时就能得到事件通知，而是通常在超过 nSampsPerChan 时才能得到事件通知</mark>)。即该参数的取值大小决定着每两次读到数据的时间间隔，也就是实时响应度。点数越小，实时响应就越高，反之越低。但不能为了一味的追求实时响应度就将该参数的值设得很小，这个还要看采样速率的高低，<mark>如果采样速率很高，而 nSampsPerChan 的值很小，则可能造成任务负担过重而发生缓冲区溢出，以致造成丢点现象的发生。</mark>建议实时响应度不低于 20 个毫秒是比较合适的。比如每通道采样速率为 100Ksps，即10微秒一个点，则 nSampsPerChan 不小于 2000 个点是比较合适的。该参数的取值范围为[2, 1024 * 1024]，具体还要受制于系统可用内存和采样通道数。\n## 2.3 nReadSampsPerChan\n\n在有限点和连续采样模式中，它指定该次从设备的当前可读数据位置读取的数据点数（单位: 点）。注意此参数的值如大于当前的可读数点 nAvailSampsPerChan 则会继续等待直到至少有 nReadSampsPerChan 个点可读后读函数才会返回。等待期间，如果所等时间超过 fTimeout 指定时间也会返回，并置超时错误码。\n\n在连续采样过程中，如果要保持连续不丢点，此参数应尽可能接近于甚至等于当前的可读点数（nAvailSampsPerChan），但不能大于 AIParam.nSampsPerChan。当然此参数值也不能大于 fAnlgArray 的缓冲区长度，所以为避免出错，所开辟的缓冲区不能小于 nReadSampsPerChan * AIParam.nSampChanCount。\n\n<mark>和nSampsPerChan相比一个是需要读的一个实际采的。而实际读到的点数在pSampsPerChanRead。</mark>\n> 这个告诉我们，要关注数据采集卡的底层，采样分析发现，数据采集卡是 2 的幂次方个数目采集存储的。","categories":["实验"]},{"title":"编码器","url":"/2024/01/15/实验/编码器/","content":"编码器的A相、B相和Z相是增量式旋转编码器中常见的信号输出端：\n\n1. **A相** 和 **B相**：\n   - A相和B相通常是两个正交（即相差90度相位）的脉冲信号通道。\n   - 当编码器轴转动时，A相和B相会按照特定的顺序依次产生脉冲，由于它们的相位差为90度，通过检测这两个信号的超前或滞后关系，可以确定旋转的方向。\n   - 例如，当编码器顺时针旋转时，A相通常会先于B相变化；逆时针旋转时，则B相会先于A相变化。\n2. **Z相**（也称为索引脉冲或零位脉冲）：\n   - Z相是一个每旋转一圈才出现一次的脉冲信号，它不随转速改变而频率变化，而是固定在机械结构上的一个特定位置发出。\n   - 这个脉冲用于指示特定的位置参考点，如圆周上的零度位置，或者用于系统复位和绝对位置校准。\n   - 在一些控制系统中，可以通过检测Z相信号来精确地知道设备转了多少圈，并且可以在每个周期的起始点进行计数器清零或其他同步操作。\n\n综上所述，A相和B相主要用于测量转速和旋转方向，而Z相则提供了一个绝对位置的参考标记。这三相信号共同工作，使得控制系统的闭环控制更加准确和可靠。\n","categories":["实验"]},{"title":"单片机","url":"/2024/01/15/实验/单片机/","content":"- 实时采样代码\n\n```c\n// 采样\nstatic OUTPUT_SAMPLE_DATA sampleData = {0};\noutput_sample(&sampleData);\n\ng_hmi_data.output_data.real_current = sampleData.current;\ng_hmi_data.output_data.real_voltage = sampleData.voltage;\n```\n\n","categories":["实验"]},{"title":"Surface EMG Decomposition Based on K-means Clustering and Convolution Kernel Compensation","url":"/2024/01/12/论文/Decomposition/Surface-EMG-Decomposition-Based-on-K-means-Clustering-and-Convolution-Kernel-Compensation/","content":"这种算法一定要注意参数的设置，如果h设置过大，可能把一些不同mu的spike都均值化了。\n\n在高信噪比和低收缩强度的情况下，不需要迭代的过程，聚完类就能得到一个好的发放时刻。但是对高收缩力情况下的复杂emg信号，就需要这个迭代过程来改善spike train。\n\n","categories":["论文","Decomposition"]},{"title":"A peel-off convolution kernel compensation method for surface electromyography decomposition","url":"/2024/01/10/论文/Decomposition/A-peel-off-convolution-kernel-compensation-method-for-surface-electromyography-decomposition/","content":"\n这篇文章把peel-off策略应用到CKC算法上。CKC算法使用的是梯度下降求解，代价函数为 s^3/3 ，学习率设置为0.1，初始化为激活指数最大的值，并且识别到MU的发放时刻后进行剔除（但是这种剔除只会偶尔有效，所以本文提出了peel-off策略）。本文比较重要的是还介绍了几个评价指标：\n$$\n\\mathrm{RoA}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}+\\mathrm{FP}} \n$$\n$$\n\\mathrm{Sensitivity} = \\frac{\\mathrm{TP}}{\\mathrm{TP+FN}} \\\\\n$$\n$$\n\\text{Precision}=\\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}\n$$","tags":["上交","Decomposition"],"categories":["论文","Decomposition"]},{"title":"主成分分析和特征值分解","url":"/2024/01/09/数学/主成分分析和特征值分解/","content":"\n第一主成分对应的方差是协方差矩阵的最大特征值，第二主成分对应的方差是协方差矩阵第二大特征值，以此类推。真实采集数据的协方差矩阵的特征值通常会急剧下降，因此通常可以设置一个阈值来划分特征值。这个阈值决定了多少主成分被选取。\n<!-- more -->\n\n原向量可以划分到两个空间中，分别是信号子空间和噪声子空间。所以协方差矩阵可以表示为：\n$$\n\\mathbf{C}_\\mathbf{x}=\\sum_{i=1}^m\\mathbf{a}_i\\mathbf{a}_i^T+\\sigma^2\\mathbf{I}\n$$\nCKC算法中的噪声阈值之前计算一直存在问题，文章说选取最小的特征值作为噪声方差，但是根本筛选不掉噪声。后来阅读的时候发现eigenvalue后面加了个s，查阅了书籍发现，对原始信号进行主成分分析，取方差最大的方向作为第一主成分，对协方差矩阵进行特征值分解的时候，最大的特征值就是第一主成分的方差，第二大的特征值是第二主成分的方差，依此类推。当进行到第几个主成分的时候依然是有效信号呢？《Independent Component Analysis (Aapo Hyvarinen)》中说，高斯噪声是各向同性的，也就是说噪声在各个方向上的方差是一样的，所以当特征值小到一定程度的时候，会保持不变，这个时候就是噪声，把这些特征值加起来就得到了噪声阈值对应的方差。在处理实际测量数据时，协方差矩阵的特征值序列通常会急剧下降。这意味着随着特征值的编号增加，其数值会越来越小。可以设定一个阈值，低于该阈值的特征值对应的主成分（Principal Components）贡献相对较小，对数据集的解释力或压缩效果不显著。因此，这个阈值就决定了我们应该保留多少个主成分用于后续的数据分析、降维或其他处理过程。\n","categories":["数学"]},{"title":"Non-invasive characterization of motor unit  behaviour in pathological tremor","url":"/2023/12/29/论文/Decomposition/Non-invasive-characterization-of-motor-unit-behaviour-in-pathological-tremor/","content":"这篇文章介绍了 gCKC 算法的代价函数：  \n\n$$\nF(t) = 2\\cdot atan(t)-2\\cdot t+t\\cdot\\log(1+t^2)\n$$\n\n注意相关向量更新后要归一化。\n","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"Comparison of Convolutive Kernel Compensation and Non-Negative Matrix Factorization of Surface Electromyograms","url":"/2023/12/12/论文/Decomposition/Comparison-of-Convolutive-Kernel-Compensation-and-Non-Negative-Matrix-Factorization-of-Surface-Electromyograms/","content":"\n这篇文章的实验范式和我们的实验范式很像。\n\n<!-- more -->\n\n# Notes\n\n为了提高分解性能，观测向量y(n)可以进行K个延迟。\n\n> The method has been tested in many different experimental setups [9], [10], [16]–[21], [29], [31], [41], [45], [47] also in <mark>moderate dynamic contractions</mark> [8], [11], [12], [26], [40] and yielded up to 70 simultaneously active MUs.  \n\n# Experiments\n\n- All the subjects performed wrist flexions-extensions. Six subjects performed also pronations-supinations and four subjects performed ulnar-radial deviation.  \n- The subjects followed the trapezoidal (2 s ramp up + 5 s plateau + 2s ramp down + 5 s rest) force profiles. In each measurement, we recorded ten repetitions of the selected movement.\n- The hdEMG signals were recorded by <mark>two arrays</mark> of 5×13 electrodes with diameter of 1 mm and inter-electrode distance of 8 mm (OT Bioelettronica, Italy).  \n\n# Data analysis\n\n- 取30s作为一段，对每一段进行分解，然后把这些分解向量作用总的120s，再移除重复的MU，选择PNR高的MU。\n- 对每个MU进行动作的归类，比如flexion相关的MU归为G1，extension相关的MU归为G2，剩下的归为G3。\n- 肌肉兴奋是非负性的，非常符合NMF的假设。这意味着每个DOF需要估计至少两个分量F，即每个运动方向一个分量。\n- <mark>没有一种测试的分解技术能够完全补偿由于动态肌肉收缩引起的MUAP变化，尽管在研究手腕运动的情况下，这些变化相对较小，如前面[8]所述。</mark>","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"Blind source identification from the multichannel surface electromyogram","url":"/2023/12/10/论文/Decomposition/Blind-source-identification-from-the-multichannel-surface-electromyogram/","content":"\n一篇综述文章，后续在计算MU discharge pattern时可以参考。\n\nEMG crosstalk（串扰）：当在较小尺度观察时，电活动在空间位置上被记录形成EMG，EMG是许多同时激活的肌肉隔室和附近肌肉的活动的混合。\n\n在运动单元这个尺度上提取的信息直接映射到α运动神经元的活动，并提供了对中枢神经系统和 PNS 净输出的明确洞察。\n\n<!-- more -->\n\n- 由于神经肌肉系统的固有特性，这些尖峰序列是稀疏的，因此每个尖峰后面都有一系列的零。在正常情况下，神经肌肉接头高度稳定，因此运动神经元中的每一个尖峰都会触发受支配肌纤维的电激活，从而产生单纤维动作电位（SFAP）。\n\n- MUAP是空间的函数（图2），其形状反映了肌肉特性（例如动作电位的传导速度）、体积导体特性（例如插入组织的电导率）和采集系统特性（例如摄取电极区域的大小）。此外，在动态收缩中，由于电极相对于肌肉纤维的相对位置的连续变化，动作电位形状可能会随着时间的推移而迅速变化。\n\n- MUs和肌肉可以被视为运动神经元传导神经代码的天然放大器。\t\n\n- 在正常和非疲劳条件下，MU放电的同步性相对较小，因此尖峰列车相对独立。当通过所谓的独立分量分析（ICA）技术尝试对多通道EMG进行分解时，这被证明是有益的。在疲劳和神经退行性疾病（如帕金森病）中，不同运动神经元的放电往往同步，导致生理或病理性震颤。在这些情况下，独立来源的假设不再有效，使得ICA技术不适合用于EMG分解。值得注意的是，稀疏尖峰序列的假设在这些条件下仍然成立。\n\n- 将肌纤维与记录电极分离的容积导体起到低通空间滤波器的作用。\n\n- 卷积数据模型假设由不同的电极检测到的某一个MU的MUAP序列仅共享MU放电的时刻，而检测到的MUAP的形状由混合过程本身建模。这与生理MUAP模型非常接近，并且允许MUAP形状的任意空间变化。因此，卷积数据模型比瞬时数据模型更通用、更现实。\n\n- 虽然稀疏，但卷积模型通常不完全，存在源比测量多的问题，因此难以反演。EMG通道的数量取决于采集系统，但通常限制在几十个。同时，在运动任务中，即使在低收缩力下，也有几十个MU活跃。为了缓解这个问题，具有低能量动作电位的MU的贡献通常被建模为生理噪声。这种建模方法减少了源的数量，但同时也降低了信噪比。\n\n- 源s（t）是稀疏的，即最小的尖峰间隔大于MUAP的持续时间。\n\n","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"FastICA算法推导","url":"/2023/12/07/论文/Decomposition/FastICA算法推导/","content":"\n参考链接：[独立成分分析FastICA算法原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/133511600)\n\nFastICA是如何分离出原向量的呢？我的理解是FastICA需要优化一个目标使得非高斯性最小，假设得到一个分离向量使得非高斯性最小了，那么这个分离向量满足一个方程，通过不动点迭代法（牛顿迭代法）来求取这个方程的根，在迭代法的过程中，得到了FastICA的递推公式，最终收敛得到的根就是最优的分离向量。\n\n这么看其实白化的目的就是找到一组尽可能不相关的变量，FastICA得到的结果是要强于白化的。\n\n","categories":["论文","Decomposition"]},{"title":"相关矩阵、协方差矩阵、相关系数","url":"/2023/12/06/数学/相关矩阵、协方差矩阵、相关系数/","content":"\n参考博文：\n\n- [矩阵篇（四）-- 实随机向量的相关矩阵、协方差矩阵、相关系数_随机向量的协方差矩阵-CSDN博客](https://blog.csdn.net/xq151750111/article/details/121172306)\n- [协方差矩阵及其意义_协方差矩阵的意义-CSDN博客](https://blog.csdn.net/qq_41076797/article/details/112640676)\n\n协方差的意义：协方差代表的是随机变量之间的相关性，如果协方差矩阵越向对角线集中，那么表面随机变量之间的相关性越弱。相关系数就与协方差有关，相关系数的计算公式中分子就是两个变量的协方差。\n\n","categories":["数学"]},{"title":"白化","url":"/2023/12/06/数学/白化/","content":"# 为什么要白化\n\n假设训练数据是图像，由于图像中相邻像素之间具有很强的相关性，所以用于训练时输入是冗余的。白化的目的就是降低输入的冗余性。比如在独立成分分析（ICA）中，对数据做白化预处理可以去除各观测信号之间的相关性，从而简化了后续独立分量的提取过程，而且，通常情况下，数据进行白化处理与不对数据进行白化处理相比，算法的收敛性较好。\n\n<!-- more -->\n\n一些容易与白化变换混淆的概念包括：去相关化、标准化、有色变换。去相关化仅仅使得各个分量之间不相关，而对于整体的方差没有进行考虑。标准化使得整体的方差为1但是没有考虑相关性。有色变换是使得一个白色随机序列根据设计好的相关性矩阵变成一个要求的有色序列。\n\n为什么在白化变换中一定要求白化后的方差为1呢？举个例子，在信号处理中，一个随机信号u通过一个放大率为100的线性放大器得到另一个随机变量w，从方差的角度看其方差变为原来的10000倍，看起来是另一个与u完全不同的信号，但是实际上只是数值按比例放大，比如采用了不同的计量单位来量化同一个物理信号，两个看似不同的信号却描述了同一个物理现象。为了避免这种情况，最好在白化变换中将信号的整体方差也归一化为1，这样就可以避免类似的问题。\n\n白化的两种方式：\n\n- PCA白化\n- ZCA白化\n\n# 白化的定义\n\n“白化”这个词最早来源于信号处理领域，跟其中最常见的一种噪声——白噪声有很大的联系。在信号处理理论中，白噪声指的是一种在不同频率都有相同功率的随机信号，即其功率谱密度为常数，功率与频率无关。“白噪声”这个名字来源于白光，白光包含了光谱中所有的颜色，其功率谱密度也呈平坦状，类似地，“白噪声”这种噪声中包含了所有频率的噪声，因此被冠上了“白”的称号。其他不满足该功率谱密度特性的噪声也被称为有色噪声，类似于非白光的其他颜色光。\n\n简单来说，白色的定性就是均值为0，不相关。明白了白色的内涵之后，“白化”的概念也就很容易理解了，对于一个随机向量，如果它是白化的，那么它满足两个条件：\n\n（1）各分量零均值且方差为1\n\n（2）各分量不相关\n\n通过上面两个条件限制，可以发现白化向量的协方差矩阵为单位矩阵。白化变换的定义为：**白化**变换或**球面**变换是一种线性变换，它将具有已知协方差矩阵的随机变量向量转换为一组新变量组成的向量，使得新的向量协方差矩阵为一个<mark>单位矩阵</mark>。（白化强于不相关的地方在于白化后矩阵的特征方差是1。）\n\n对于零均值这个条件，只需要把原始向量减去均值就可以了：\n$$\n\\tilde{x}=x-\\frac{1}{n}\\sum^n_{i=1}x_i\n$$\n针对第二个条件，假设$X$是一个均值为0的随机向量，其协方差矩阵为$C_x$，那么白化变换就需要得到一个变换矩阵$W$，使得\n$$\nY=WX\n$$\n为白化向量。我们知道$X$的自协方差矩阵的表达式为：\n$$\n\\boldsymbol{C_x}=Cov(\\boldsymbol{x},\\boldsymbol{x})\\stackrel{def}{=}E\\{[\\boldsymbol{x}(\\xi)-\\boldsymbol{\\mu_x}][\\boldsymbol{x}(\\xi)-\\boldsymbol{\\mu_x}]^T\\}=\\begin{bmatrix}c_{11}&\\cdots&c_{1m}\\\\\\vdots&\\ddots&\\cdots\\\\c_{m1}&\\cdots&c_{mm}\\end{bmatrix}\n$$\n那么$Y$ 的协方差矩阵为 $\\Sigma=WC_x W^{T}$。（这个直接把$Y$与$X$的关系代入上式就可以得到），所以要使得$WC_x W^{T}=E$。白化变换的关键就是求出满足上述条件的变换矩阵$W$，求解方法不唯一。设 $C_x=U\\Lambda U^T$为 $C_x$ 的特征值分解，其中 $U$ 是正交矩阵（正交阵是指满足$AA^T=E$或者$A^TA=E$的$n$阶方阵$A$），那么 $W=R\\Lambda^{-1/2}U^T$ 都是满足条件的白化变换矩阵，其中 $R$ 为任意正交矩阵。特别地，我们称\n$$\nW=\\Lambda^{-1/2}U^T\n$$\n为PCA变换，称\n$$\nW=U\\Lambda^{-1/2}U^T\n$$\n为ZCA变换或马氏变换。\n\n# 参考文献\n\n[白化（Whitening） | Jacky's blogs (wangjs-jacky.github.io)](https://wangjs-jacky.github.io/2020/02/22/白化（Whitening）/#二维高维分布randn)\n\n[Whiten process——数据的白化处理-CSDN博客](https://blog.csdn.net/weixin_37872766/article/details/102957235)\n\n## 二维均匀分布：`rand`\n\n##  [![img](白化/20200221230611.png)](https://cdn.jsdelivr.net/gh/wangjs-jacky/testpic/img_temp/20200221230611.png)二维高维分二维高斯分布：`randn`\n\n[![img](白化/20200221230720.png)](https://cdn.jsdelivr.net/gh/wangjs-jacky/testpic/img_temp/20200221230720.png)\n\n> 注：这里的 PCA白化和 ZCA白化看上去一样其实是不一样的，PCA的数据在维度方向是无关的，相当于原数据发生了一个旋转，ZCA则与原数据没有发生旋转，从第一个图可以发现这种旋转方式。下图可以反映这种变换。\n\n![image-20231206181244836](白化/image-20231206181244836.png)\n","categories":["数学"]},{"title":"Automatic Implementation of Progressive FastICA Peel-Off for High Density Surface EMG Decomposition","url":"/2023/11/29/论文/Decomposition/Automatic-Implementation-of-Progressive-FastICA-Peel-Off-for-High-Density-Surface-EMG-Decomposition/","content":"表面肌电分解最重要的难点是MUAP的叠加。\n\nPFP框架是一个逐渐扩大MUST集合的过程。最初的的MUST集合是由FastICA从高密度肌电估计而来；然后，peel off过程被用来从原信号中减去已经识别到的MU的MUAP，这个过程能够减少已经识别到的MU对FastICA收敛的影响，因此更多MU能够从残差信号中涌现出来；最后，Constrained FastICA用于评估每个spike train以及纠正可能的错误和丢失的spikes。这个框架不断重复上述过程直到没有新的MU出现。\n\n<!-- more -->\n\n**PFP算法的主要步骤：**\n\n1. 初始化残差为原始信号，spike train集合为空\n2. 在扩展的残差信号上执行并行FastICA，提取spike train，通过聚类来区分输出中混叠的波形\n3. 对集合中的每一个spike train，将其作为参考信号，在原始信号上执行Constrained FastICA，保存可靠的spike train到集合中\n4. 对每一个通道，原始信号减去集合中所有spike trian的MUAPT（peel-off过程），得到残差信号\n5. 更新残差信号，然后重新执行步骤2\n6. 没有新的spike train或者到达终止条件时停止\n\n自动化的两个困难：\n\n- 如何克服FastICA的符号不确定性，如何设置合适的阈值\n- 如何确定Constrained FastICA的输出是一个可靠的MU\n\n针对第一个问题，通过非线性能量算子，能够把FastICA的输出转变成更清晰的正尖峰序列。但是NEO过程会导致spike偏移，虽然不影响spike train的识别，但是会影响MUAP的估计精度，所以本文不选择NEO，而是计算3阶标准矩Skewness，通过skew能够把<mark>FastICA的输出变成right-skewed（positive skew，即偏向正）。</mark>\n\n针对第二个问题，通过迭代算法来确定阈值，迭代算法的过程如下：\n\n1. 设置初始阈值\n2. 将信号按照阈值分成两个部分，分别计算两个部分的均值\n3. 将新的阈值设置为两个均值的算术平均值\n4. 重复步骤2和步骤3直到均值收敛\n\n初始值的设置非常重要，对结果有着非常大的影响，采用类似于Otsu阈值方法来设置初始值，发现这样的初始值离收敛值特别近。同时，这个阈值的收敛还可以用作终止判断条件，如果提取的尖峰序列不再改变，那么当使用该尖峰序列作为参考时，Constrained FastICA的输出将不会改变，因此阈值也将保持不变。\n\n**但是，**\n\n上述两个问题的解决，只能在FastICA输出是高信噪比的稀疏序列下有较好的效果，但有的时候FastICA的输出有非常低的信噪比。尽管理想情况下FastICA可以突出只属于一个运动单元的稀疏尖峰序列并抑制其他运动单元的尖峰，<mark>但实践中的另一种可能的情况是来自FastICA输出的尖峰不只属于一个运动单位，尤其是当处理具有非常严重的MUAP叠加或高运动单元同步水平的EMG信号时（这就是为什么要设置聚类）。</mark>\n\n<mark>一定要明确</mark>：FastICA估计出来的是一个带尖峰的信号，通过设置阈值来得到spike train。如果两个重叠的spike幅值接近，就很难区分出来，所以本文利用spikes的形态特征，通过聚类来区分。\n\n聚类需要满足以下要求：\n\n- 无监督的\n- 能够处理各种分布。spike的特征倾向于椭圆形的，K-means等处理球形分布的算法就不适用\n- 低复杂度\n\n基于上述要求选择了valley-seeking 聚类算法。聚类之后同一个cluster中的spikes有很大概率是来自同一个MU的，把同一个cluster中的spikes作为caonstrained fastica的初始spike train，使其收敛到相应的MU。因此，在执行valley-seeking聚类时，我们应该将false positive的发生率降至最低，即我们更愿意保证聚类中的大多数尖峰是正确的，而不是识别所有尖峰。\n\n**虽然**，Constrained FastICA 能够有一个高信噪比的输出，**但是**，这个算法不能保证 spike 都来自于一个运动单元，并且存在如下问题：\n\n1. 输出可能不是一个稀疏序列，而是一个白噪声序列，这说明已经没有新的MU了\n2. 输出包含少量零散的尖峰，这些尖峰通常有着较大的间隔\n3. 出现一个单峰，这是由于FastICA过拟合的现象\n4. 输出依然是几个MU的混叠，如果这种MU不能被valley-seeking分解出来，那么就应该舍弃他们\n\n为了解决上述4个问题，一些限制性参数被提出来根据MU的发放特性，参数如下：\n-   $\\xi$：Constrained FastICA 的输出与参考尖峰序列之间的相关系数。此参数是 Constrained FastICA 中的受约束条件。为了保证 Constrained FastICA 的收敛性，$\\xi$ 被设置为在该过程中逐渐减小。这可能导致较小的 $\\xi$，并因此损害相关性约束的重要性。因此，我们应该丢弃 $\\xi$ 太小的尖峰序列。该参数可以有效地排除上述情况（1）和情况（4）。阈值设置为0.5。\n-  $cov_{amp}$：如果spikes属于同一个MU，那么它的幅值应该保持一致，变异系数应该特别小。因此如果一个spike train的这个参数过大，那么就应该舍弃。阈值设置为0.3。\n-  $cov_{ISI}$：如果 MU 保持稳定放电，那么 $cov_{ISI}$ 过大的 spike train 应该舍弃掉。这个参数能够排除上述4个问题。阈值设置为0.4。\n-  $FR$：放电频率有一个生理学的上下界，通常是4-50Hz。\n\n**APFP算法的主要步骤：**\n\n1. 初始化残差信号为原始表面肌电信号，输入判断参数 c 1=0.5，c 2=0.3，c 3=0.4 和 c 4=4。初始化可靠发放时间序列集合 $\\psi$ 和待定发放时间序列集合 $\\psi _1$ 为空集\n2. 在扩展后的残差信号上运行parallel FastICA\n3. 对FastICA的每个输出，自动提取发放波形，并将它们通过Valley-seeking Clustering聚类 \n4. 将第3步中每个聚类后的发放序列作为初始的参考信号，反复执行constrained FastICA直到迭代阈值收敛\n5. 对第4步中每个提取出来的发放序列，进行下面的判断过程：\n   ![image-20231201195318336](Automatic-Implementation-of-Progressive-FastICA-Peel-Off-for-High-Density-Surface-EMG-Decomposition/image-20231201195318336.png)\n6. 对原始表面肌电信号的每一个通道，用 $\\psi$ 中所有的运动单位发放时间序列来估计这些运动单位在该通道的动作电位序列波形，接着将这些已经识别出的运动单位动作电位序列从原始信号中剥去，并更新残差信号，返回第 2 步\n7. 如果 $\\psi$ 中没有增加任何新的可靠运动单位发放序列，或者程序达到了预设的终止条件，输出 $\\psi$ 并结束程序\n\n   ","categories":["论文","Decomposition"]},{"title":"High-yield decomposition of surface EMG signals","url":"/2023/11/21/论文/Decomposition/High-yield-decomposition-of-surface-EMG-signals/","content":"\n这篇论文介绍了一种sEMG分解算法，这种方法不是针对高密度肌电的，这篇论文采集了4个通道的肌电信号。信号分解算法首先从sEMG信号中提取尽可能多的MUAP的动作电位“模板”，然后搜索提取的模板相互叠加或具有未识别动作电位的信号区域。该算法在分析这种叠加时考虑了相长和相消干扰效应，并且它要求未识别的动作电位在分解的MUAPT的发射位置处占信号能量的小于25%。我们的分解算法是利用人工智能知识系统子领域中成熟的技术设计的。基于知识的算法已广泛用于生理信号应用，如ECG解释和EEG癫痫检测，以及非生理信号应用，如遥感和雷达信号分类。\n\n<!-- more -->\n\n我们之前已经将PD方法与人工智能的集成处理和理解（IPUS）概念结合起来，开发了一种用于植入式EMG信号的分解算法。虽然De Luca等人（2006）的PD-IPUS算法通常能够从sEMG信号中提取20–30个MUAP的模板<mark>（把植入式的算法应用到表面肌电）</mark>，但它无法充分解决它们的复杂叠加，除非是最高振幅的4–8个MUAP。本文的信号分解算法代表了引入新机制的结果，这些机制有助于解决由原始PD-IPUS算法识别的大量MUAPT的复杂叠加。\n\n如下图的框图所示，本报告的sEMG信号分解算法从初始PD-IPUS阶段开始，以尽可能识别各种MUAP形状的模板。然后，它进入人工智能的“迭代生成和测试”阶段（PD-IGAT），以识别sEMG信号中任何复杂叠加中存在的模板。PD-IPSUS和PD-IGAT阶段的更多细节将在下面描述。\n\n![image-20231122214110046](High-yield-decomposition-of-surface-EMG-signals/image-20231122214110046.png)","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"Hierarchical control of motor units in voluntary contractions","url":"/2023/11/21/论文/Control/Hierarchical-control-of-motor-units-in-voluntary-contractions/","content":"\n本文主要解决的争议是到底是阈值高的MU有更高的放电频率还是阈值低的MU有更高的放电频率。部分人认为，阈值高、直径大的MU有更短的超极化电位，因此具有更高的放电频率，结合Henneman准则，得到这样一个结论，先募集的MU比后募集的MU放电频率更低。<font color = 'red'>但是，很多学者的研究发现，高兴奋水平下激活的高阈值MU，有着更低的放电频率。</font>\n\n<!-- more -->\n\n文章发现，在线性力增加的收缩过程中，放电率以指数函数的形式增加。在任何时间和力水平，包括募集时，实时放电率的值与募集阈值呈反比。指数函数的时间常数与募集阈值直接相关。至此，<mark>有两个关于MU放电频率的准则</mark>，一个是Henneman准则，另一个是“firing rate spectrum”  ：\n\n- Henneman准则：随着兴奋的增加，运动神经元按照体积从小到大的顺序募集。\n\n> The Henneman size principle states that **motor units are recruited from smallest to largest based on the size of the load**. For smaller loads that require less force, the low-force, fatigue-resistant, slow-twitch muscle fibers are activated before the recruitment of the less-fatigue-resistant, high-force, fast-twitch muscle fibers.\n\n- firing rate spectrum：在任何给定的时间或力水平下，早期募集（阈值低）的运动单位的放电率都大于后期募集（阈值高）的运动单位。\n\n结合这两个准则，可以得到这样一个总结：体积小的MU先募集，但是放电频率较高；体积大的MU后募集，但是放电频率较低。\n\n----\n\n文章的sEMG分解使用了Nawab的方法，为了验证分解算法的准确率和是否引入偏置，本文提出了对应的解决方法——DecomposeSynthesize-Decompose-Compare (DSDC)  ：\n\n- **准确率：**\n\n<mark>DSDC Accuracy的计算公式：</mark>\n$$\n\\text { Accuracy }=1-\\mathrm{N}_{\\text {error }} / \\mathrm{N}_{\\text {truth }}=1-\\left(\\mathrm{N}_{\\mathrm{FP}}+\\mathrm{N}_{\\mathrm{FN}}\\right) /\\left(\\mathrm{N}_{\\mathrm{TP}}+\\mathrm{N}_{\\mathrm{TN}}\\right)\n$$\n$N_{truth}$代表所有的正确事件，主要有两种错误，一种是real sEMG中出现了尖峰但是synthesized sEMG中没有出现尖峰；另一种是real sEMG中没有出现尖峰但是synthesized sEMG中出现了尖峰。\n\n> Following Nawab et al. (2008), the decomposition accuracy (A) for a MUAPT is determined from the number of firings (NFIR), the number of false positives (NFP), andthe number of false negatives (NFN) in the decomposition: $$ A=\\frac{N_{\\mathrm{FIR}}-N_{\\mathrm{FN}}-N_{\\mathrm{FP}}}{N_{\\mathrm{FIR}}} $$\n\n- **是否引入偏置：**\n\n文章把real sEMG分解得到的MUAPT随机打乱得到randomized MUAPT，再使用randomized MUAPT reconstruct sEMG，再对其进行分解，发现分解算法并不会影响放电的行为。因此，可以说明real sEMG得到的的放电速率的模式和趋势是能够表征运动单位实际的放电特性的。\n\n","categories":["论文","Control"]},{"title":"Decoding motor unit activity from forearm muscles: Perspectives for myoelectric control","url":"/2023/11/09/论文/Dynamic/Decoding-motor-unit-activity-from-forearm-muscles-Perspectives-for-myoelectric-control/","content":"文章结果表明，在动态收缩或者 MUAP 改变的条件下，在正常肢体受试者和肢体缺陷患者的各种自主手腕运动过程中，可以识别出大量运动神经元的活动。这篇文章并没有方法上的创新，而是直接运用盲源分离算法。\n\n<!-- more -->\n\n# 1. Introduction\n\n**重要结论：**\n\n- 由于神经肌肉结的存在，运动神经元的放电变成了MUAP\n\n> Because of the high reliability of the neuromuscular junction, each discharge of a motor neuron ultimately results in a motor unit action potential (MUAP) of the innervated muscle.\n\n- 肌肉充当了运动神经元神经活动的生物放大器，分解算法把这种活动解卷积\n\n> EMG decomposition provides access to the output spike trains of spinal motor neurons by using muscles as biological amplifiers of efferent nerve activity and decoding this activity by deconvolution  \n\n- EMG分解的进一步应用需要考虑实时和非静态两种情况\n\n> For control applications, the EMG decomposition needs to be real-time and accurate in non-stationary conditions\n\n- EMG 分解算法目前只适用于等长收缩（在恒定不变的力或者缓慢变化的力）\n\n> EMG decomposition methods have so far been proven applicable only in isometric contractions at constant or slow varying force.\n\n- SIL 能够评估分解的有效程度\n\n>It was previously shown, using concurrent intramuscular and surface EMG recordings, that SIL values are linearly related to decomposition accuracy.\n# 2. Methods\n\n**被试**：7个正常人 A1-A7，2个残疾人 D1-D2\n\n**电极片**：<mark>3个电极片用于正常人中的5个人，剩下的用2个电极片</mark>\n\n**预处理**：带通滤波3-900Hz，采样2048Hz，分辨率是12bit\n\n**传感器安装位置**：\n\n- the dorsal side of the palm\n- the dorsal side of the wrist\n- the dorsal side of the distal end of the upper arm\n\n**实验范式**：两个箭头指示，使重合，5s 内从放松位置到动作的最大位置再返回，使得关节角度呈一个三角形，然后再反向执行动作，这样称为一个 motor task。每个 task 被试执行3次，每次之间休息5s，每个 session 持续180s。\n\n> One motor task consisted of an agonist and an antagonist movement with 5 s rest in between. The performed motor tasks were flexion and extension corresponding to horizontal arrow movements, ulnar and radial deviation corresponding to vertical arrow movements, and pronation and supination corresponding to arrow rotation (Fig. 2)\n\n<mark>数据预处理</mark>：3-900 Hz 带通滤波\n# 3. Processing\n\nMUAP波形用来匹配同一个MU：通过比较两个MU的MUAP之间的标准化互相关系数。该函数对MUAP波形中的时间滞后和MUAP幅度的变化是稳健的。如果标准化互相关系数的最大值大于0.8就认为两个MU是一样的。\n\n有些运动神经元属于一个收缩肌，但是能在多个DoF中识别到，比如桡侧腕屈肌中的运动单位起到腕关节屈曲和桡侧偏斜的主动肌作用。只在一个动作中检测到的运动单位被分类为“maximally discriminative”。\n\n记录了每个MU第一次放电时的关节角度，这是能够被EMG分解算法检测到的第一个事件，是非常有意义的。首先，提供了能够进行MU分解的关节角范围；其次，因为MU是随着力缓慢募集的，所以还能够用于比例控制。\n\n如果一个 mu 90%的 spikes 都在一个动作期间发放，那么就认为这个 mu 对应这个动作。\n# 4. Results\n\n- <mark>尽管收缩具有非等长性质，但可以确定每个运动任务>15个运动单位。这种高产率分解对于四肢正常的受试者和四肢缺陷的受试对象都是可能的，这表明基于运动单位尖峰序列的肌电控制是可行的。</mark>\n- 每个运动任务平均识别出16±7个运动单位，平均ISR值为24.7±12.7%。在识别出的运动单位中，12±6个与主动肌肉动作有关，6±5个运动单位所有重复中都存在。平均SIL值为0.86±0.05，这与识别放电时间的估计准确度>85%相对应（<font color='red'>为什么？Multi-channel intramuscular and surface EMG decomposition by convolutive blind source separation</font>）。\n\n![image-20231111113201558](Decoding-motor-unit-activity-from-forearm-muscles-Perspectives-for-myoelectric-control/image-20231111113201558.png)\n\n- 9名被试中的6名只有1个任务没有consistently detected discriminative motor units，剩下两名所有任务都存在持续的能最大区分的MU\n\n​\t`注意：`consistent指所有重复中均放电，discriminative指只在一个motor task中放电。\n\n- maximally discriminative 这种属性在其他实验范式下可能会改变，本文的任务和重复方式比较简单。\n\n- 因为关节角度的逐渐增加可能对应于关节扭矩的增加，所以在更大角度募集的运动单位可能表现出更高的募集阈值。这些运动单位可能确实更容易区分，因为它们具有较大的神经支配数量，因此往往具有较大的表面MUAP振幅。\n\n- 只有不到一半的分解尖峰序列存在于给定运动任务的所有重复中，这可能是因为MUAP的波形形状的变化。\n\n- 与先前显示的静态收缩结果相比，ISR值更小。这与放电开始时相对较高角度的发现一致，这表明提取的运动单位只能解释总EMG变化（功率）的一小部分。适用于强非平稳条件的专门方法将减少这种情况的影响。\n\n  > Decomposition of surface EMG signals from cyclic dynamic contractions\n  >\n  > Single motor unit and fiber action potentials during fatigue\n\n- 然而，假肢控制的实时实现应该克服与非静态相关的挑战，这些挑战可能会阻碍运动单元的识别，例如手臂位置的变化、疲劳、长期稳定性、电极位置的变化或特定条件下运动单元行为的变化\n","categories":["论文","Dynamic"]},{"title":"假设检验","url":"/2023/11/07/数学/假设检验/","content":"\n参考知乎讲解：[小白爱上SPSS - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1486018864752857088)\n\n参考b站视频：[单因素方差分析(上）/ANOVA/什么是方差分析、方差分析的思路_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16U4y1e7DT/?spm_id_from=333.880.my_history.page.click&vd_source=f9284418e385ee0855b280e1ab5cb560)\n\n什么时候用什么检验：\n\n- 正态分布：\n\n  - 计数资料：\n\n    - 单个计数资料：单样本比例检验\n\n    - 多个计数资料：卡方检验\n\n  - 计量资料：\n    - 两组数据：t检验（可以和计数资料结合）\n    - 多组数据：ANOVA（可以和计数资料结合）\n\n- 非正态分布：\n\n  - 秩和检验\n\n<!-- more -->\n\n![image-20231107214251738](假设检验/image-20231107214251738.png)\n\n几个重要参数：\n\n- $\\alpha$：显著性水平，是 $p$ 值的临界值，一般比较小，如：0.01，0.05.\n- $p$：表示在 H0成立的情况下，拒绝 H0，接受 H1的错误决策的概率。可以理解为风险，$p$ 值越小，拒绝 $H_0$ 的风险越低。这个参数的值需要与显著性水平比较，若小于显著性水平，则拒绝假设 $H_0$，并称观察到的差异在统计上是显著的\n\n# 1. 方差分析\n\n- 单因素方差分析\n- 双因素方差分析\n\n# 1.1 单因素方差分析\n\n### 1.1.1 方差分析的基本概念\n\n**目的：** 比较不同分组 (通常组别大于等于3) 之间某一特征值的<mark>均值</mark>是否存在显著差异。（n个分类，它们的某一特征值的平均值，是否有显著区别）\n\n**因素 (factor or independent variable) ：** 一定是分类型变量，且类别大于3。例子:\n\n- 视频分区：生活区、知识区、游戏区、美妆区、搞笑区\n- 医学院：协和、北医、复旦医学院、上交医学院、Harvard medical school.John's Hopkins medical school、 UCSF medical school\n\n**特征值 (dependent variable)：** 一定是连续型变量\n\n**原假设：**\n$$\nH_{0}\\colon\\mu_{1}=\\mu_{2}=\\mu_{3}=\\cdots=\\mu_{n}\n$$\n\n**备择假设：**\n$$\nH_1{:}\\mu_1{:}\\mu_2{、}\\mu_3{、}...{\\mu_n} 不全相等\n$$\n\n### 1.1.2 方差分析的思路\n\n**数据整体波动(Sum of Squares Total)：**组内波动与组间波动。整体波动描述的是所有数据，包含了各个分组数据。\n\n**组内波动（Sum of Squares Within, SSW）：**\n\n- 某一分组内，个体特征值的离散程度\n- 例子：协和医学院学生考试成绩的离散程度\n\n**组间波动（Sum of Squares Between, SSB）：**\n\n- 不同分组之间，分组特征值的<mark>平均值</mark>的离散程度\n- 例子：协和医学院、北大医学院、哈佛医学，学生考试成绩均值的离散程度\n\n$$\nSST = SSB + SSW\n$$\n\n**一些结论和例子：**\n\n![image-20231108162755249](假设检验/image-20231108162755249.png)\n\n![image-20231108162817335](假设检验/image-20231108162817335.png)\n\n- 组内波动占整体波动越大，组间波动占整体波动越小，各组均值相等的可能性越大\n- 组内波动占整体波动越大，组间波动占整体波动越小，各组均值相等的可能性越大\n\n我们通过构造 f 统计量来判断我们的组间波动，它的占比是否足够的大，大到让我们拒绝原假设\n\n### 1.1.3 怎么计算SST SSW SSB，利用F检验进行判断\n\n**计算SST：**\n$$\n\\text{Sum of Squares Total=}\\sum(x_i-\\bar{\\bar{x}})^2\n$$\n![image-20231108173419940](假设检验/image-20231108173419940.png)\n\n**计算SSW：**\n$$\n\\text{Sum of Squares Within}=\\sum(x_i-\\overline{x_i})^2\n$$\n![image-20231108173810544](假设检验/image-20231108173810544.png)\n\n**计算SSB：**\n$$\n\\text{Sum of Squares Between}=\\sum(\\overline{x_i}-\\bar{\\bar{x}})^2\n$$\n![image-20231108174054306](假设检验/image-20231108174054306.png)\n\n**构造F统计量（符合F分布）：**\n\n![image-20231108174548544](假设检验/image-20231108174548544.png)\n\n- 组间自由度：组别数量-1\n- 组内自由度：Σ(每组个体数量 - 1)\n\n- <mark>通过查表格确定F统计量所对应的p值是多少</mark>\n\n![image-20231108192120221](假设检验/image-20231108192120221.png)\n\n# 1.2 双因素方差分析\n\n特征值同时受两个因素影响。e.g. 视频播放量同时受 视频分区 和 up主学历 影响。双因素方差分析因素的组别不做限制，不需要像单因素方差分析那样必须大于三组。双因素方差分析探讨的三个问题：\n\n- 问题一：根据第一个因素进行分组时，不同分组之间的特征值均值是否相等\n\n  - 原假设：第一个因素对特征值均值没有显著影响\n  - 备择假设：第一个因素对特征值均值存在显著影响\n\n- 问题二：根据第二个因素进行分组时，不同分组之间的特征值均值是否相等\n\n  - 原假设：第二个因素对特征值均值没有显著影响\n  - 备择假设：第二个因素对特征值均值存在显著影响\n\n- 问题三：第一个因素和第二个因素的交互效应，是否对不同分组之间的特征值均值产生影响\n\n  - 原假设：交互效应对特征值均值没有显著影响\n\n  - 备择假设：交互效应对特征值均值存在显著影响\n\n### 1.2.1 双因素方差分析思路\n\n计算五个波动：\n\n1. 数据整体波动（sum of squares total）\n2. 第一个因素所带来的波动（sum of squares first factor）\n3. 第二个因素所带来的波动（sum of squares second factor）\n4. 两个因素交互项所带来的波动（sum of squares interaction）\n5. 误差项所带来的波动（sum of square error）\n\n五个波动之间的关系：\n$$\nSST = SSFF + SSSF + SSI + SSE\n$$\n模型所带来的波动（sum of square model）:\n$$\nSSM = SSFF + SSSF +SSI\n$$\n为什么叫模型带来的波动呢？因为双因素方差分析可以理解为两个因素构成了这样一个检验模型，用这个模型来解释特征值的波动，前三项波动就是这个模型能够解释的部分。误差项时这个模型不能解释的部分。下面分情景进行解释： \n\n![image-20231108200012803](假设检验/image-20231108200012803.png)\n\n![image-20231108195331597](假设检验/image-20231108195331597.png)\n\n![image-20231108200341785](假设检验/image-20231108200341785.png)\n\n![image-20231108200458344](假设检验/image-20231108200458344.png)\n\n### 1.2.2 双因素方差分析思路\n\n1. 计算出因素一波动 、因素二波动 、交互项波动 、误差项波动\n2. 分别将因素一波动 、因素二波动 、交互项波动，与误差项波动进行比较\n   - 因素一波动 v.s 误差项波动进行比较（如果因素一波动显著大于误差项波动，那么就说因素一对特征值有影响）\n   - 因素二波动 v.s 误差项波动进行比较（如果因素二波动显著大于误差项波动，那么就说因素二对特征值有影响）\n   - 交互项波动 v.s 误差项波动进行比较（如果交互项波动显著大于误差项波动，那么就说交互项对特征值有影响）\n\n### 1.2.3 波动的计算方法\n\n- SST：每个个体的数值减去总体的平均值的平方和\n- SSFF：构造一组数据，使得这组数据只受因素一影响\n\n![image-20231108202619494](假设检验/image-20231108202619494.png)\n\n-  SSSF：构造一组数据，使得这组数据只受因素二影响\n\n![image-20231108202819017](假设检验/image-20231108202819017.png)\n\n- SSM：构造一组数据，使得特征值受两个因素影响\n\n![image-20231108203303363](假设检验/image-20231108203303363.png)\n\n- SSI：SSM - SSFF - SSSF\n- SSE：个体取值 - 模型所能解释的取值（SST - SSM）\n\n![image-20231108203754749](假设检验/image-20231108203754749.png)\n\n**构造F统计量（符合F分布）：**\n\n- sum of squares first 自由度：因素一分组数减1 =  2 -1 = 1\n- sum of squares second 自由度：因素二分组数减1 = 3 -1 = 2\n- sum of squares interaction 自由度：模型自由度减去因素一自由度减去因素二自由度 = (2 x 3 -1) - 1- 2 = 2\n- sum of squares error 自由度：整体自由度减去模型自由度 = (12 - 1) - (2 x 3 -1) = 6\n\n![image-20231108204641972](假设检验/image-20231108204641972.png)\n","categories":["数学"]},{"title":"Predicting wrist kinematics from motor unit discharge timings for the control of active prostheses","url":"/2023/11/03/论文/Dynamic/Predicting-wrist-kinematics-from-motor-unit-discharge-timings-for-the-control-of-active-prostheses/","content":"\n这篇文章描述并验证了一种从运动单元动作电位队列（MUAPT，称为神经特征）中预测腕关节屈曲/伸展、旋前/旋后和尺骨/桡骨偏移的关节角度的方法，并将预测结果与从全局肌电图特征的线性回归中获得的预测结果进行了比较。手的几个动作：\n\n- flexion——extension\n- pronation——supination\n- adduction——abduction（ulnar deviation—— radial deviation）\n\n这篇文章先通过训练集得到spike到neural input的函数，然后把MUAPT和residual EMG当作neural feature，然后对neural feature降维，然后通过线性回归来估计力矩。这篇文章的实验范式重点参考。\n\n<!-- more -->\n\n# 1. Method\n\n- 两到三片高密度肌电电极，8×8，10 inter-electrode distance\n- 参考电极和地电极防止在手腕处\n- monopolar mode\n- 5nd band-pass filter: 20-500Hz, zero phase\n\n**实验范式：**\n\n每个自由度下关节角度呈三角形变化，这样能够保证关节角度匀速。同时，两个方向均弯曲，弯曲范围为动作的极限。一个三角形称为一个trials，这样一共就有6个trials。一个run包含其中3个trials（DoF和trial随机选取）。每一个被试执行3次run，每个run斜坡的时长不同，代表着不同的收缩速度，分别是：\n\n- 5s，慢速\n- 2.5s，中速\n- 1s，高速\n\n# 2. Processing\n\n## 2.1 TD feature extraction\n\n>The following time-domain features were calculated for each window across all considered channels: root mean square, slope sign changes, zero crossings, and waveform length.\n\n## 2.2 neural feature extraction\n\n- <font color = \"red\">为了识别在一个以上DoF的任务中活动的运动单位，通过互相关对运动单位动作电位的波形进行比较。如果两个动作电位的波形的互相关系数＞0.8，那么认为是由同一个运动单位产生的。</font>\n- 分解高密度肌电信号的时候也是分段分解的，滑动窗口宽度为100ms，重叠10ms。\n- <font color = \"red\">重构的EMG信号与原始的EMG信号之间的差异部分也被用来提取信息，这与之前的想法一致。</font>\n\n## 2.3 model-based dimensionality reduction\n\n肌电信号的分解是存在错误的，这些错误不能被人工检查出来。另一方面，运动神经元之间的活动是存在相关性的，这种相关性可以用来弥补分解的错误。同一池或协同肌肉中的运动神经元共享相对较大比例的突触输入。因此，每个运动单位的放电时间不仅携带关于肌肉力量的信息，而且还与其他运动单元的活动相关，<mark>可以利用这个特性来降低特征维度</mark>。如何来提取这种共同的突触输入呢？\n\n- 首先每个神经元从中枢神经系统接收到的输入与尖峰队列的关系可以用一个函数表示：$$ \\alpha_{ij}=g_{ij}(x_{ij}) $$。使用鲁棒回归对 spike train 和关节角度来确定函数 $g$。<mark>之所以能这样确定是因为神经输入 $\\alpha$ 与关节角度有关，因此可以通过手腕关节角度来得到神经输入。</mark>\n- 在估计时，每个MU被分组到最相关的自由度中，在这个自由度下估计神经的输入。\n- 在每个自由度下，得到运动神经元池中所有神经元的上述输入后，结合前一个窗口的共同输入（用于平滑）用来提取一个共同的输入$\\alpha_{i}^{r}$。（因为每个MU接收到的信息不同，同时还有分解误差，所以不能直接相加，而需要一个专门的方法，最终选用了中位数这个方法）\n- 这篇文章中的<mark>神经特征</mark>：（1）提取出的共同输入；（2）残留信号的时频域特征。\n- 神经特征用于最简单的线性回归，回归后的力矩分解到3个自由度上。\n\n## 2.4 comparison between features\n\n- neural feature this paper proposed\n- time-domain feature\n- AM1：discharge spike count and EMG residual without model-based dimensionality reduction\n- AM2：only DSC without model-based dimensionality reduction and without the residual EMG features\n\n# 3. Results\n神经特征和时频域特征得到的决定系数之间是有显著统计差.的，神经特征回归的决定系数为0.77，时频域特征回归的决定系数为0.7。\n\n**一些重要结论：**\n\n- 与ramp duration有关，ramp duration越短，动作速度越快，收缩强度越大，募集的MU越多，识别到的spike trains越多，但是文章说这个没有显著的统计学差异，因为可能受其他因素影响\n- 只有少数MU在多个自由度中被识别到，这就是说绝大多数MU都只与单一的自由度有关，MU是与动作相关联的。这一点从上交的论文中也能看出来\n\n![image-20231109115844912](Predicting-wrist-kinematics-from-motor-unit-discharge-timings-for-the-control-of-active-prostheses/image-20231109115844912.png)\n\n- 使用替代方法的测试表明，包括残差EMG和所提出的降维都有助于实现卓越的性能\n- 所提出的方法以及AM1优于TD的观察结果表明，<mark>尖峰序列确实携带了传统特征无法提取的额外信息</mark>，即使对于如此高的信道数量也是如此\n- 分解算法识别出的MU都是阈值高的，因为阈值高的MU有更高的能量，这对分解和波形比较有利\n\n# 4. Limitations\n\n- 分解算法主要用于低、中力下的等长收缩，对动态收缩只部分有效\n","categories":["论文","Dynamic"]},{"title":"高密度肌电使用方法","url":"/2023/10/27/实验/高密度肌电使用方法/","content":"\n| 工作电极 |                                                参考电极                                                |                    地电极                    |\n|:--------:|:------------------------------------------------------------------------------------------------------:|:--------------------------------------------:|\n|   肌腹   | 没有明显电位变化的地方，如肘关节、腕关节，但必须是同一侧，如果放在两侧肘关节则肌电信号会夹杂着心电信号 | 设备接地，工作电极跟参考电极在同一个水平比较 |\n\n- 测量肌电时要减少不必要的线路和设备避免工频干扰；\n\n- 使用医用酒精皮肤清理，阻抗更小，信号更稳定；\n\n![image-20231027224835563](高密度肌电使用方法/image-20231027224835563.png)\n\n肌电信号的常见噪声：\n\n- 工频干扰；\n- 运动伪迹；\n- 心电或者其他呼吸相关干扰；\n","categories":["实验"]},{"title":"A Deep CNN Framework for Neural Drive Estimation From HD-EMG Across Contraction Intensities and Joint Angles","url":"/2023/10/23/论文/Dynamic/A-Deep-CNN-Framework-for-Neural-Drive-Estimation-From-HD-EMG-Across-Contraction-Intensities-and-Joint-Angles/","content":"\n这篇文章使用CNN进行估计。这篇文章的思想是，使用CNN进行估计，但是学习的时候不同强度，不同肌纤维长度下的MU都不一样，因此需要解决这个问题。而这篇文章提出的CNN能够在不同条件提取MUAP普遍的特征，因此能够估计不同条件下的神经特征。\n\n<!-- more -->\n\n# 1. Introduction\n\n- 由于幅值抵消和串扰的存在，EMG不能表达神经特征\n\n- 相比于sEMG，平滑的CST在估计手指力，手指关节参数，手腕关节参数等方面有更高的精度\n\n> Compared to amplitude-based surface EMG, the smoothed CST has higher accuracy in estimating isometric finger force [12], [13], finger kinematics [14], [15], and wrist kinematics [16], [17].   \n\n- 使用MU spikes来控制上肢假肢笔传统的基于特征的模式识别或者骨骼肌模型的控制方法更好\n\n- 在线分解算法通常分为两个步骤：\n\n> 1. an offline initialization where a separation matrix of MU filters is calculated based on a long segment of data (>10 s);\n> 2. an online decomposition where the separation matrix is used to identify spike trains and then updated with the newly identified spike trains  \n\n这种方法的缺点是：分离矩阵在离线训练的时候就确定了，因而分离矩阵决定的MU就确定了。除此之外，当收缩强度改变的时候，MU也会改变，因此即使是等长收缩，训练好的分离矩阵在不同强度下也只能识别到一部分MU。\n\n- 当收缩的强度（n% MVC）增加时，由于小MU存在幅值抵消，识别到的MU会改变\n- 使用CNN和RNN能够估计MUST，但是这些方法严重依赖MUAP的形状，不同MU的MUAP只有很小概率相同，同一个MU的波形也会因肌肉长度的改变而改变\n\n# 2. Method\n\n（1）Isometric Trapezoidal Contractions With Different Intensities: \n\n- 10%、30%：5-s ramp-up, a 20-s plateau, and a 5-s ramp-down phase\n- 50%： 5-s ramp-up, a 15-s plateau, and a 5-s ramp-down phase\n\n","tags":["Dynamic"],"categories":["论文","Dynamic"]},{"title":"Toward a generalizable deep CNN for neural drive estimation across muscles and participants","url":"/2023/10/19/论文/Across Day/Toward-a-generalizable-deep-CNN-for-neural-drive-estimation-across-muscles-and-participants/","content":"\n当前在线估计方法在不同天或者不同人的情况下需要重新离线训练，这限制了在线算法的广泛使用。<font color = \"Red\">这篇文章主要是为了研究神经驱动在不同session、muscle和participants之间的估计结果。这篇文章的引言部分值得重点关注，同时ANOVA的部分也值得重点关注。</font>\n\n<!-- more -->\n\n# 1. Introduction\n\n关于neural drive的阐述：\n\n> the neural drive to muscles is composed of discrete spike signals, which are then amplified and transformed to continuous motor unit action potential (MUAP) signals  by the innervated muscle.\n\n为什么要分解：sEMG只是粗略的估计，并没有线性地关联到神经驱动，由于动作电位的<font color = \"Red\">叠加</font>和<font color = \"Red\">幅值抵消</font>。\n\n如果提出一个新的分解算法：必须使用two-source validation protocol验证。\n\n虽然阶段性更新策略能够解释MUAP的缓慢变化，但是分离向量在离线训练后只能识别到固定的MU数目，使得这些方法只能用于同一个session里面的同一个肌肉。\n\n- 募集的MU数目对于不同的肌肉和不同的患者是不同的\n- amplitude和duration受肌纤维的直径影响\n- 不同肌肉不同患者的MUAP波形是不一样的\n- MUAP的特性受电极和肌纤维之间的相对位置影响\n- 不同天、不同session，MUAP也会改变\n\n# 2. Method\n\n**时间间隔：**两个session间隔20个月\n\n**实验范式：**\n\n- 3次最大自愿等长收缩，每次3-5s，相邻两次间隔2分钟\n- 第一个session，根据屏幕提示执行3次小于最大收缩的等长收缩，曲线为梯形，上升10s、水平10s、下降10s，为最大值的25%。每次执行完后休息30s\n- 第二个session，梯形改为上升5s、水平20s、下降5s。每次休息60s\n\n**电极贴片**：两片13×5，电极间距8mm，ELSCH064NM2  \n\n**导电膏**：conductive paste\n\n**泡胶**：bi-adhesive foam layer\n\n**人工检查**：在是用盲源分离算法后人工检查剔除错误\n\n**MU 筛选**：选取 PNR 大于30的 MU（能够保证 SIL 大于90%，FP 小于2%）\n\n**CNN：**\n\n- 输入：一个时间窗的高密度肌电信号，时间窗的长度为40个数据点（左右各扩充10各数据点），步长为20个数据点\n- 输出：设置了4个节点，对应窗口内的MU spikes的数目。如果没有检测到spike，那么所有节点的输出为0；如果窗口中有一个尖峰，则将第一个节点设置为一；如果窗口中有两个尖峰，则前两个节点设置为1。但是，如果窗口中有四个以上的尖峰，我们将所有四个节点都设置为1。因此，可能会丢失训练和测试数据中的一些尖峰（最多只有4个节点），但当将深度CNN的输出与从BSS提取的完整CST进行比较时，这是最好的选择。将CST窗口化，窗口长20个数据点，步长20个数据点，没有数据重叠\n- 输入和输出帧中心对齐\n- six parametric layers (four convolutional layers and two fully connected layers)\n- three non-parametric layers (two max pooling layers and one flatten layer)\n\n**python 实现的开源代码**： https://github.com/ywen3/dcnn_mu_decomp\n\n**双因素分析：**\n\n- 因素一：validation method\n- 因素二：data source\n\n# 3. Results\n\n- 使用BSS分解算法得到的结果：\n\n![image-20231023205249557](Toward-a-generalizable-deep-CNN-for-neural-drive-estimation-across-muscles-and-participants/image-20231023205249557.png)\n\n","categories":["论文","Across Day"]},{"title":"Elbow-flexion force estimation during arm posture dynamically changing between pronation and supination","url":"/2023/10/16/论文/Dynamic/Elbow-flexion-force-estimation-during-arm-posture-dynamically-changing-between-pronation-and-supination/","content":"这篇文章使用NMF分解算法把高密度肌电分解为激活模式和时变系数。并且对动态下的分解算法进行了改善，采用了分段分解的方法。看这篇文章主要是为了学习如何处理非等长收缩的情况。\n\n<!-- more -->\n\n# 1. Method\n\n**实验范式：**\n\n1. 首先执行MVC，MVC执行3次，为了精度需要，至少需要保持 3 s\n2. 等长收缩获取训练数据\n   - pronated arm posture\n     - sinusoidal: the duration of sinusoidal pattern was 6s and its amplitude ranged from 0% to 60% MVC\n     - staircase: from 0% to 20%, 40% and 60% MVC successively, and each targeted force level was held for 2s  \n   - supinated arm poseture\n     - sinusoidal\n     - staircase\n3. 动态收缩测试力估计的性能\n   - 被试的手臂在pronation和supination之间切换\n   - 一个切换周期为8-10s\n   - 总任务时常为40s\n\n**非负矩阵分解**：\n\n![image-20231018092354173](Elbow-flexion-force-estimation-during-arm-posture-dynamically-changing-between-pronation-and-supination/image-20231018092354173.png)\n\n上式中，M是标准化后的高密度肌电包络线（m个通道，n个采样），W的每一列代表一个激活模式（activation pattern，一共有s个激活模式），每个激活模式有m个权重因子；C的每一行代表时变的系数向量，时变系数的面积定义为相应激活模式的激活强度。\n\n![image-20231018095013998](Elbow-flexion-force-estimation-during-arm-posture-dynamically-changing-between-pronation-and-supination/image-20231018095013998.png)\n\n只有VAF＞0.95重建的M才能较好地反映原始的M，所以VAF的阈值设置为0.95。\n\n# 2. Data Processing\n\n**静态等长收缩：**\n\n主激活模式：激活强度最高的激活模式\n\n有效通道：每个激活模式权重因子排在前1/4的通道被选做有效通道，取这些通道的标准化sEMG包络线用作力估计模型的输入\n\n**动态改进**：\n\n力估计模型的输入基于激活强度的比例，具体步骤如下：\n\n1. 高密度肌电分段为segments，NMF算法对每个段进行分解\n2. 对每个segment，当最大和次大的激活强度超过阈值，认为存在主激活模式，否则认为存在多个激活模式，对力的贡献均有显著贡献\n3. 由于激活模式的激活强度在不同的任务和被试之间存在差别，所以需要阈值需要经验设置并且进行调整\n4. 所有激活模式下，通道根据权重参数进行降序排列。当主模式存在的时候，选取主模式的前1/4通道被选取提取输入；当主模式不存在时，选取所有通道的前1/4\n\n**滑动窗口的使用**：\n\n> The threshold of VAF was also set to 0.95 and data segment length was 1 s (1000 data points). To achieve point-by-point force estimation, a sliding window with step length 1 was used to extract data segments. For each task, the first 1 s data segment was used to realize the estimation of the 1000th points (the starting point to estimate)\n\n# 3. Conclusion\n\n- 动态运动的主要特征是在动作转变的过程中伴随这激活区域的改变，这些激活区域对力的估计非常重要。\n- 不同通道的选择结果在不同收缩阶段是不同的。\n\n![image-20231019000541389](Elbow-flexion-force-estimation-during-arm-posture-dynamically-changing-between-pronation-and-supination/image-20231019000541389.png)\n\n- 实验曲线选择正弦函数可能包含更多有效的信息并且在选择通道上更加的高效\n","categories":["论文","Dynamic"]},{"title":"Decomposition of surface EMG signals from cyclic dynamic contractions","url":"/2023/10/16/论文/Dynamic/Decomposition-of-surface-EMG-signals-from-cyclic-dynamic-contractions/","content":"本文采用了机器学习算法和时变MUAP区分法来分解伪静态和动态的肌电信号（<font color='red'>什么是伪静态？</font>）。本报告描述了一种创新的方法，用于分解步态中肘部屈曲/伸展周期性收缩期间以及膝盖和脚踝屈曲/伸展期间获得的sEMG信号。本文对运动单位在循环收缩期间的性能的初步观察表明，在重复的动态收缩期间，运动单元的控制受与等长收缩期间相同的规则控制。运动单位的共同驱动和分级募集特性得到了保留。\n\n<!-- more -->\n\n# 1. Introduction\n\n目前的研究主要集中在肌肉等长收缩的条件下，肌纤维长度近似保持不变，这种情况下MUAP在形状上的改变有限。动态收缩的主要问题涉及整个收缩过程中MUAP的形状和幅度的大量变化。MUAP改变的主要原因有两点：\n\n- 动态收缩下电极相对位置的改变\n- 肌肉长度的改变\n\n这两个问题主要的解决方法是从原来的静态分解算法上，采用循序渐进的方式。\n\n<font color = 'red'>本文的算法适用于周期性的收缩之中，周期性收缩一定程度上能够简化分解过程，因为MUAP的调整也是周期性的。</font>尽管限制在了周期性的动作中，但是动态收缩条件下可能存在的问题：\n\n- 随着肌肉的伸缩，循环内部MUAP的波形改变\n- 在循环之间，即使关节角度一致，同一个MU的MUAP也会改变\n- 不同MU的波形相似\n\nMUAP的改变更多是集中在幅值的改变上而非形状的改变。\n\n# 2. Algorithm\n\n## 2.1 算法原理\n\n算法可以分为两个独立的阶段。第一个阶段主要识别未被污染的MUAP波形（指那些没有叠加的动作电位）；第二个阶段主要通过识别到的MUAP自动去识别叠加部分的组成波形。\n\n**阶梯形力曲线**：改变是逐渐引入的\n\n本文主要解决两个问题：\n\n1. 跟踪不同收缩角度上MUAP形状的演变\n2. 当关节角度从一个平台变化到下一个平台时，提供增量募集识别能力\n\n针对问题一，我们通过实现更自适应的MUAP匹配标准来修改分类器以考虑可能随着收缩角的变化而发生的MUAP形状改变。具体来说，我们定义了n维接受域，其基于未受污染的MUAP形状参数的局部特征来识别相同运动单位的MUAP。<mark>每个运动单位的接受域用每个增加的未受污染的MUAP的分类来更新，以说明MUAP形状参数的变化，这些变化可能作为时间和收缩角的函数而发生。</mark>\n\n针对问题二，通过增加迭代搜索程序来解决增量募集识别问题——一次处理一个子集的MUAP，直到剩余sEMG信号的平均能量满足自适应阈值。\n\n**单循环力曲线**：\n\n该算法主要解决intracycle问题，也就是之前提到的动态收缩条件下存在的前两个问题。统计分类器中的机器学习的算法被结合到之前用于阶梯形力曲线的分类器中。具体来说，我们通过对尖峰到尖峰的连续性进行详细检查来评估MUAP形状的参数变化。然后指定最近邻分类器来基于这些MUAP形状参数来区分循环内的形状变化。\n\n**多循环力曲线**：\n\n修改后的算法允许最大后验概率分类器判别标准在转换前和转换后循环期间为每个运动单位包含更大的接受域。为了减轻错误分类MUAP的易感性，我们采用了MUAP轮廓进化判别方法，它基于单周期收缩期间实现的多目标跟踪方法。这种方法之所以有效，是因为可以使用整个单独循环中MUAP形状的参数变化的演变来区分位于循环间过渡附近的形状相似性。为了进一步增强该策略的稳健性，使用循环平稳信号分析（Gardner 1994）来增强所涉及循环的形状演化。这种严格的数学框架能够检测形状进化轨迹的周期到周期的可重复性，并对不同的MUAP进行更有力的区分\n\n## 2.2 验证\n\n一个重要概念——DSDC：decompose-synthesize-decompose-compare。\n\n这个方法用来衡量分解的误差，通过比较原始信号和合成信号来评估。合成信号由从记录的sEMG信号的分解获得的MUAPT和在均方根上等于记录的sEM分解的残差的均方根的随机化带限的时变高斯噪声组成。\n\n# 3. Experiments\n\n首先执行阶梯形曲线，文章测试了3种曲线，分别是：\n\n- 4 steps (33.8, 67.5, 101.3, 135°) of 10-s duration each; \n- 8 steps (16.9, 33.8, 50.6, ..., 135°) of 5-s duration each; \n- 12 steps (11.3, 22.5, 33.8, ..., 135°) of 3-s duration each.   \n\n然后执行单循环力曲线，手臂弯曲范围为0-90°，分别以两种速度30°/s和45°/s。最后执行多循环力曲线，也就是重复8次单循环力曲线。\n\n![image-20231121112159661](Decomposition-of-surface-EMG-signals-from-cyclic-dynamic-contractions/image-20231121112159661.png)","tags":["动态"],"categories":["论文","Dynamic"]},{"title":"Database","url":"/2023/09/29/数据库/Database/","content":"\n![image-20230929230731364](Database/image-20230929230731364.png)\n\n# Hyser\n\n采集设备：OT\n\n[Open Access Dataset and Toolbox of High-Density Surface Electromyogram Recordings](https://physionet.org/content/hd-semg/1.0.0/)\n\n# Ninapro\n\n采集设备：Delsysy。该数据库并不侧重高密度\n\n[Welcome to Ninaweb](http://ninapro.hevs.ch/)\n\n# CSL-HDEMG\n\n采集设备：OT\n\n[Advancing Muscle-Computer Interfaces with High-Density Electromyography | Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems](https://dl.acm.org/doi/abs/10.1145/2702123.2702501)\n\n# CapgMyo\n\n采集设备：OT\n\n[ZJU CAPG GROUP](http://zju-capg.org/research_en_electro_capgmyo.html#download)\n\n","categories":["数据库"]},{"title":"Analysis of motor unit spike trains estimated from high-density surface electromyography is highly reliable across operators","url":"/2023/08/29/论文/Characteristic/Analysis-of-motor-unit-spike-trains-estimated-from-high-density-surface-electromyography-is-highly-reliable-across-operators/","content":"\n重要程度: ⭐⭐⭐⭐⭐\n\n开源数据：[Analysis of motor unit spike trains estimated from high-density surface electromyography is highly reliable across operators (figshare.com)](https://figshare.com/articles/dataset/Analysis_of_motor_unit_spike_trains_estimated_from_high-density_surface_electromyography_is_highly_reliable_across_operators/13695937)\n\n<!-- more -->\n\n# 实验\n\n**人数**：10人\n\n- 实验1：GL和GM\n- 实验2：TA\n\n## 实验流程\n\n- 15-20次收缩预热，收缩程度小于最大收缩\n- 3次最大等长收缩，持续3-5秒，每次休息120秒\n- 10%，30%，50%，70%四个力水平下完成3次收缩，每次收缩包括5s上升，15s或20s保持，5s下降。收缩之间休息一分钟或者两分钟\n\n# Introduction\n\n> Blind source separation procedures (Holobar and Zazula, 2007; Negro et al., 2016) applied to these signals currentlyenable the identification of up to 30–40 motor units. However, after anautomatic extraction, most of these approaches require some degree of manual analysis/editing of the motor unit spike trains to check for false positives and false negatives (Del Vecchio et al., 2020; Enoka, 2019). This manual analysis consists of reinforcing the motor unit spike trains with tuned motor unit separation filters. \n\n","categories":["论文","Characteristic"]},{"title":"pytorch","url":"/2023/08/22/机器学习/pytorch/","content":"# 常见的Transforms\n\n使用不同的方法转换输入输出。\n\n```python\nfrom torchvision import tranforms\n```\n\n按住ctrl键可以打开transforms的源码，然后可以在pycharm的左边structure处看见结构，里面包含了所有的类。注意是类，要构造一个对象。\n\n常用的一些类包括：\n\n- Compose\n- ToTensor\n- Normalize\n- Resize\n\n<!-- more -->\n\n# 常见的层\n\n- convolution layer：能够考虑空间信息\n- maxpool layer：类似于马赛克，训练的数据量大大的减小\n- dropout layer：随机地把一些元素变成零，主要为了防止过拟合\n- non linear layer：非线性越多，才能训练出符合各种曲线的函数\n- flatten layer：该层用于将数据平铺，之后可以输入给全连接层，平铺时batch_size并不会改变\n- linear layer：全连接层，两个全连接层可以拟合任何函数，在输入时需要将各个维度展开\n- batch normalization layer：批归一化，能够加快收敛速度，但是不能提升模型精度\n\n# GPU训练\n\n先指定device：\n\n```python\ndevice = torch.device('cuda')\n```\n\n然后需要迁移模型、损失函数、样本\n\n```python\nmodel.to(device)\nloss_fn.to(device)\nimg.to(device) / target.to(device)\n```\n\n","categories":["机器学习"]},{"title":"python","url":"/2023/08/17/计算机/python/","content":"\n# 下划线的作用\n\n在Python的变量名和方法名中，单下划线和双下划线都有各自的含义，有的仅仅是作为约定，用于提示开发人员，而有的则对Python解释器有特殊含义。\n\n你可能有些疑惑，在Python中变量名和方法名中的单下划线、双下划线到底有什么含义？下面我们就来看看下面五种下划线模式和命名约定，以及它们各自如何影响Python程序的行为：\n\n- 前置单下划线：_var\n- 后置单下划线：var_\n- 前置双下划线：__var\n- 前后双下划线：__var__\n- 单下划线：_\n\n<!-- more -->\n\n**前置单下划线：_var**\n\n当涉及变量名和方法名时，前置单下划线只有约定含义。它对于程序员而言是一种提示，Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。\n\n前置单下划线的意思是提示其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南8），不过，这个约定对Python解释器并没有特殊含义，与Java不同，Python在“私有”和“公共”之间并没有很强的区别。\n\n来看下面的Student类例子：\n\n```python3\nclass Student:\n    def __init__(self):\n        self.name = \"Mark\"\n        self._age = 18\n```\n\n如果实例化这个类并尝试访问在__init__构造函数中定义的name和_age属性，会发生什么情况？\n\n![img](python/v2-ebc081a36d295ba51b127b2ec7cb29b1_720w.webp)\n\n可以看到_age前面的单下划线并没有阻止我们访问变量的值，这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。但是前置下划线会影响从模块中导入名称的方式。假设在一个名为common.py的模块中有如下代码：\n\n```python3\ndef func1():\n    return \"func1\"\n\n\ndef _func2():\n    return \"func2\"\n```\n\n![img](python/v2-12cf8b17511d31b43d0335a7aaa77cfd_720w.webp)\n\n现在，如果使用 from common import * 这种方式导入所有名称，Python不会导入带有前置单下划线的名称，除非在模块中定义了__all__列表覆盖了这个行为：\n\n![img](python/v2-79fe81c973622fd0fe462c659fadd878_720w.webp)\n\n![img](python/v2-d8410f078a72ac88cbc35220298a63df_720w.webp)\n\n顺便说一下，我们应尽量避免使用*号导入，因为这样就不清楚当前名称空间中存在哪些名称了，为了清楚起见，最好坚持使用常规导入方法，与*号导入不同，常规导入不受前置单下划线命名约定的影响：\n\n![img](python/v2-3a288684b483d59cca87f8f222500179_720w.webp)\n\n**后置单下划线：var_**\n\n有时，当某个变量的名称已被Python语言中的关键字占用，如class、def等的名称不能用作Python中的变量名，在这种情况下可以追加一个下划线来绕过命名冲突：\n\n![img](python/v2-b1d0a06956ff6dded656ead57fd2a2b5_720w.webp)\n\n用一个后置单下划线来避免与Python关键字的命名冲突是一个约定。PEP 8定义并解释了这个约定。\n\n**前置双下划线：__var**\n\n前面的两种下划线模式只有约定的意义，但使用以双下划线开头的Python类属性（变量和方法）就不一样了，双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突，这也称为名称改写，即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突，下面用代码示例来实验一下：\n\n```python3\nclass Student:\n    def __init__(self):\n        self.name = \"Mark\"\n        self._age = 18\n        self.__gender = \"男\"\n\n\nif __name__ == \"__main__\":\n    student = Student()\n    print(dir(student))\n```\n\n![img](python/v2-f59f997464278c9329f3b8073d7980c0_720w.webp)\n\n上图中我们用内置的dir()函数看这个对象的属性：该函数返回了一个包含对象属性的列表，在这个列表中尝试寻找之前的变量名称name、_age和__gender，你会发现一些有趣的变化，首先，self.name变量没有改动，在属性列表中显示为name，接着，self._age也一样，在类中显示为_age，在这种情况下前置下划线仅仅是一个约定，是对程序员的一个提示，然而self.__gender就不一样了，在该列表中找不到__gender这个变量，仔细观察就会看到，这个对象上有一个名为_Student__gender的属性，这就是Python解释器应用名称改写之后的名称，是为了防止子类覆盖这些变量。\n\n名称改写也适用于方法名，会影响在类环境中所有以双下划线开头的名称。\n\n**前后双下划线：__var__**\n\n如果名字前后都使用双下划线，则不会发生名称改写，前后由双下划线包围的变量不受Python解释器的影响：\n\n```python3\nclass Student:\n    def __init__(self):\n        self.name = \"Mark\"\n        self._age = 18\n        self.__gender = \"男\"\n        self.__score__ = 99\n\n\nif __name__ == \"__main__\":\n    student = Student()\n    print(dir(student))\n    print(f\"score = {student.__score__}\")\n```\n\n![img](python/v2-e2d7e1d431a008cebaf64f6d9c1cd850_720w.webp)\n\n但是前后双下划线的名称在Python中有特殊用途，像__init__这样的对象构造函数，用来让对象可调用的__call__函数，都遵循这条规则。\n\n这些双下划线方法通常被称为魔法方法，双下划线方法是Python的核心功能，应根据需要使用，但就命名约定而言，最好避免在自己的程序中使用以双下划线开头和结尾的名称，以避免与Python语言的未来变更发生冲突。\n\n**单下划线：_**\n\n按照约定，单下划线有时用作名称，来表示变量是临时的或弃用的，例如下面的循环中并不需要访问运行的索引，那么可以使用_来表示它只是一个临时值：\n\n```python3\nif __name__ == \"__main__\":\n    for _ in range(5):\n        print(\"hello world!\")\n```\n\n![img](python/v2-554204c0d199c6bd1363bb8a1d5cb66c_720w.webp)\n\n在解包表达式中还可使用单下划线表示一个弃用的变量来忽略特定的值，同样，这个含义只是一个约定，不会触发Python解析器中的任何特殊行为，单下划线只是一个有效的变量名，偶尔用于该目的。\n\n下面的代码示例中，我将元组解包为单独的变量，但其中只关注name和score字段的值。可是为了执行解包表达式，我们就必须为元组中的所有值都分配变量，此时 _ 用作占位符变量：\n\n```python3\nif __name__ == \"__main__\":\n    student = (\"mark\", 19, \"男\", \"99分\")\n    name, _, _, score = student\n    print(f\"name = {name}, score = {score}, _ = {_}\")\n```\n\n![img](python/v2-9db2ac48068b891bcd8f9b7e247f975f_720w.webp)\n\n除了用作临时变量之外，_在大多数Python REPL中是一个特殊变量，表示由解释器计算的上一个表达式的结果，如果正在使用解释器会话，用下划线可以方便地获取先前计算的结果：\n\n![img](python/v2-fc524b016205b7b1865a1f5aeeb34fc4_720w.webp)\n\n如果正在实时构建对象，有单下划线的话不用事先指定名称就能与之交互：\n\n![img](python/v2-afbe91628a20df60688d0ef0f5e5f05b_720w.webp)\n\n**总结：**\n\n- 前置单下划线_var：命名约定，用来表示该名称仅在内部使用。一般对Python解释器没有特殊含义（*号导入除外），只能作为对程序员的提示。\n- 后置单下划线var_：命名约定，用于避免与Python关键字发生命名冲突。\n- 前置双下划线__var：在类环境中使用时会触发名称改写，对Python解释器有特殊含义。\n- 前后双下划线__var__：表示由Python语言定义的特殊方法。在自定义的属性中要避免使用这种命名方式。\n- 单下划线_：有时用作临时或弃用变量的名称，此外还能表示Python REPL会话中上一个表达式的结果。\n","categories":["计算机"]},{"title":"西瓜书","url":"/2023/08/16/机器学习/西瓜书/","content":"\n# 第二章 模型评估与选择\n\n**评价标准：**\n\n- 回归模型评估：均方误差 MSE\n- 分类模型评估：错误率 E 和精度 acc（两者互补）\n\n**代价函数与代价敏感：**\n\n损失函数（Loss Function ）是定义在单个样本上的，算的是一个样本的误差。\n代价函数（Cost Function ）是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。\n\n上述的acc就是一个代价均等的函数，每一类分类错误的后果是一样的。\n\n<!-- more -->\n\n**为了确保泛化误差的稳定性，从而得到理想的模型，我们就需要利用K折验证法，其一般流程如下：**\n\n(1) 将数据集分为训练集和测试集，测试集放在一边。\n\n(2) 将训练集分为 k 份，每次使用 k 份中的1 份作为验证集，其他全部作为训练集。\n\n(3) 通过 k 次训练后，得到了 k 个不同的模型。\n\n(4) 评估 k 个模型的效果，从中挑选效果最好的超参数。\n\n(5) 使用最优的超参数，然后将 k 份数据全部作为训练集重新训练模型，得到最终所需模型，最后再到测试集上测试。\n\n**参数与调参：**\n\n- 模型参数：参数属于模型内部的配置变量，它们通常在建模过程自动学习得出。如：线性回归或逻辑回归中的系数、支持向量机中的支持向量、神经网络中的权重。\n\n- 模型超参数：超参数属于模型外部的配置变量，他们通常由研究员根据自身建模经验手动设定。如学习速率，迭代次数，层数、K近邻中的K值。\n\n# 第三章 线性模型\n\n在线性回归中，当以均方误差为代价函数时，对其求解的方法称为最小二乘法。均方误差对应于欧氏距离，最小二乘法就是试图找到一条直线，使所有样本到直线上的距离之和最小。\n\n这里的代价函数关于求解参数是凸函数，因此当偏导数为0时就是使代价函数最小的最优解。推导过程需要学习一下矩阵的求导法则。\n\n# 第五章 神经网络\n\n**BP算法：**\n\nBP算法是包含两个部分，第一个部分是forward pass，算出Z，Z需要代入到激活函数的导数中求出具体值供backward pass计算；第二个部分是backward pass，用于求偏导数。\n\n[Lhy_Machine_Learning/2022 ML/选修 To Learn More/第一节 at main · CQ-yangxh/Lhy_Machine_Learning (github.com)](https://github.com/CQ-yangxh/Lhy_Machine_Learning/tree/main/2022 ML/选修 To Learn More/第一节)\n","categories":["机器学习"]},{"title":"LSTM实例3","url":"/2023/07/18/机器学习/LSTM实例3/","content":"# 使用深度学习进行“序列到序列”回归\n\n此示例说明如何使用深度学习预测发动机的剩余使用寿命 (RUL)。\n\n要训练深度神经网络以根据时序数据或序列数据预测数值，可以使用长短期记忆 (LSTM) 网络。\n\n此示例使用 [1] 中所述的涡轮风扇发动机退化仿真数据集。该示例训练一个 LSTM 网络，旨在根据表示发动机中各种传感器的时序数据来预测发动机的剩余使用寿命（预测性维护，以周期为单位度量）。训练数据包含 100 台发动机的仿真时序数据。每个序列的长度各不相同，对应于完整的运行至故障 (RTF) 实例。测试数据包含 100 个不完整序列，每个序列的末尾为相应的剩余使用寿命值。\n\n该数据集包含 100 个训练观测值和 100 个测试观测值。\n\n<!-- more -->\n\n### 下载数据\n\n从 https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/ [2] 下载并解压缩涡轮风扇发动机退化仿真数据集。\n\n涡轮风扇发动机退化仿真数据集的每个时序表示一个发动机。每台发动机启动时的初始磨损程度和制造变差均未知。发动机在每个时序开始时运转正常，在到达序列中的某一时刻时出现故障。在训练集中，故障的规模不断增大，直到出现系统故障。\n\n数据是 ZIP 压缩的文本文件，其中包含 26 列以空格分隔的数值。每一行是在一个运转周期中截取的数据快照，每一列代表一个不同的变量。这些列分别对应于以下数据：\n\n- 第 1 列 - 单元编号\n- 第 2 列 - 周期时间\n- 第 3-5 列 - 操作设置\n- 第 6-26 列 - 传感器测量值 1-21\n\n创建一个目录来存储涡轮风扇发动机退化仿真数据集。\n\n```\ndataFolder = fullfile(tempdir,\"turbofan\");\nif ~exist(dataFolder,'dir')\n    mkdir(dataFolder);\nend\n```\n\n从 https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/ 下载并提取涡轮风扇发动机退化仿真数据集。\n\n从文件 `CMAPSSData.zip` 中解压缩数据。\n\n```\nfilename = \"CMAPSSData.zip\";\nunzip(filename,dataFolder)\n```\n\n### 准备训练数据\n\n使用此示例附带的函数 `processTurboFanDataTrain` 加载数据。函数 `processTurboFanDataTrain` 从 `filenamePredictors` 中提取数据并返回元胞数组 `XTrain` 和 `YTrain`，其中包含训练预测变量和响应序列。\n\n```\nfilenamePredictors = fullfile(dataFolder,\"train_FD001.txt\");\n[XTrain,YTrain] = processTurboFanDataTrain(filenamePredictors);\n```\n\n**删除具有常量值的特征**\n\n在所有时间步都保持不变的特征可能对训练产生负面影响。找到最小值和最大值相同的数据行，然后删除这些行。\n\n```\nm = min([XTrain{:}],[],2);\nM = max([XTrain{:}],[],2);\nidxConstant = M == m;\n\nfor i = 1:numel(XTrain)\n    XTrain{i}(idxConstant,:) = [];\nend\n```\n\n查看序列中其余特征的数量。\n\n```\nnumFeatures = size(XTrain{1},1)\nnumFeatures = 17\n```\n\n**归一化训练预测变量**\n\n将训练预测变量归一化为具有零均值和单位方差。要计算所有观测值的均值和标准差，请水平串联序列数据。\n\n```\nmu = mean([XTrain{:}],2);\nsig = std([XTrain{:}],0,2);\n\nfor i = 1:numel(XTrain)\n    XTrain{i} = (XTrain{i} - mu) ./ sig;\nend\n```\n\n**裁剪响应**\n\n要更多地从发动机快要出现故障时的序列数据中进行学习，请以阈值 150 对响应进行裁剪。这会使网络将具有更高 RUL 值的实例视为等同。\n\n```\nthr = 150;\nfor i = 1:numel(YTrain)\n    YTrain{i}(YTrain{i} > thr) = thr;\nend\n```\n\n下图显示了第一个观测值及其对应的裁剪响应。\n\n![img](LSTM实例3/sequencetosequenceregressionusingdeeplearningexample_01_zh_CN.png)\n\n**准备要填充的数据**\n\n要最大程度地减少添加到小批量的填充量，请按序列长度对训练数据进行排序。然后，选择可均匀划分训练数据的小批量大小，并减少小批量中的填充量。\n\n按序列长度对训练数据进行排序。\n\n```\nfor i=1:numel(XTrain)\n    sequence = XTrain{i};\n    sequenceLengths(i) = size(sequence,2);\nend\n\n[sequenceLengths,idx] = sort(sequenceLengths,'descend');\nXTrain = XTrain(idx);\nYTrain = YTrain(idx);\n```\n\n在条形图中查看排序的序列长度。\n\n```\nfigure\nbar(sequenceLengths)\nxlabel(\"Sequence\")\nylabel(\"Length\")\ntitle(\"Sorted Data\")\n```\n\n![img](LSTM实例3/sequencetosequenceregressionusingdeeplearningexample_02_zh_CN.png)\n\n选择可均匀划分训练数据的小批量大小，并减少小批量中的填充量。指定小批量大小为 20。下图显示了未排序序列和已排序序列的填充情况。\n\n```\nminiBatchSize = 20;\n```\n\n![img](LSTM实例3/sequencetosequenceregressionusingdeeplearningexample_03_zh_CN.png)\n\n### 定义网络架构\n\n定义网络架构。创建一个 LSTM 网络，该网络包含一个具有 200 个隐藏单元的 LSTM 层，然后是一个大小为 50 的全连接层和一个丢弃概率为 0.5 的丢弃层。\n\n```\nnumResponses = size(YTrain{1},1);\nnumHiddenUnits = 200;\n\nlayers = [ ...\n    sequenceInputLayer(numFeatures)\n    lstmLayer(numHiddenUnits,'OutputMode','sequence')\n    fullyConnectedLayer(50)\n    dropoutLayer(0.5)\n    fullyConnectedLayer(numResponses)\n    regressionLayer];\n```\n\n指定训练选项。使用求解器 `'adam'` 以大小为 20 的小批量进行 60 轮训练。指定学习率为 0.01。要防止梯度爆炸，请将梯度阈值设置为 1。要使序列保持按长度排序，请将 `'Shuffle'` 设置为 `'never'`。\n\n```\nmaxEpochs = 60;\nminiBatchSize = 20;\n\noptions = trainingOptions('adam', ...\n    'MaxEpochs',maxEpochs, ...\n    'MiniBatchSize',miniBatchSize, ...\n    'InitialLearnRate',0.01, ...\n    'GradientThreshold',1, ...\n    'Shuffle','never', ...\n    'Plots','training-progress',...\n    'Verbose',0);\n```\n\n### 训练网络\n\n使用 `trainNetwork` 训练网络。\n\n```\nnet = trainNetwork(XTrain,YTrain,layers,options);\n```\n\n### 测试网络\n\n使用此示例附带的函数 `processTurboFanDataTest` 准备测试数据。函数 `processTurboFanDataTest` 从 `filenamePredictors` 和 `filenameResponses` 中提取数据并返回元胞数组 `XTest` 和 `YTest`，其中分别包含测试预测变量和响应序列。\n\n```\nfilenamePredictors = fullfile(dataFolder,\"test_FD001.txt\");\nfilenameResponses = fullfile(dataFolder,\"RUL_FD001.txt\");\n[XTest,YTest] = processTurboFanDataTest(filenamePredictors,filenameResponses);\n```\n\n使用根据训练数据计算出的 `idxConstant` 删除具有常量值的特征。使用与训练数据相同的参数来归一化测试预测变量。使用与训练数据相同的阈值对测试响应进行裁剪。\n\n```\nfor i = 1:numel(XTest)\n    XTest{i}(idxConstant,:) = [];\n    XTest{i} = (XTest{i} - mu) ./ sig;\n    YTest{i}(YTest{i} > thr) = thr;\nend\n```\n\n使用 `predict` 对测试数据进行预测。为防止函数向数据添加填充，请指定小批量大小为 1。\n\n```\nYPred = predict(net,XTest,'MiniBatchSize',1);\n```\n\nLSTM 网络对不完整序列进行预测，一次预测一个时间步。在每个时间步，网络使用此时间步的值进行预测，网络状态仅根据先前的时间步进行计算。网络在各次预测之间更新其状态。`predict` 函数返回这些预测值的序列。预测值的最后一个元素对应于不完整序列的预测 RUL。\n\n您也可以使用 `predictAndUpdateState` 一次对一个时间步进行预测。这在时间步的值以流的方式到达时非常有用。通常，对完整序列进行预测比一次对一个时间步进行预测更快。有关如何通过在相邻的单个时间步预测之间更新网络来预测将来时间步的示例，请参阅[使用深度学习进行时序预测](https://www.mathworks.com/help/releases/R2021b/deeplearning/ug/time-series-forecasting-using-deep-learning.html)。\n\n在绘图中可视化一些预测值。\n\n```\nidx = randperm(numel(YPred),4);\nfigure\nfor i = 1:numel(idx)\n    subplot(2,2,i)\n    \n    plot(YTest{idx(i)},'--')\n    hold on\n    plot(YPred{idx(i)},'.-')\n    hold off\n    \n    ylim([0 thr + 25])\n    title(\"Test Observation \" + idx(i))\n    xlabel(\"Time Step\")\n    ylabel(\"RUL\")\nend\nlegend([\"Test Data\" \"Predicted\"],'Location','southeast')\n```\n\n对于给定的不完整序列，预测的当前 RUL 是预测序列的最后一个元素。计算预测值的均方根误差 (RMSE)，并在直方图中可视化预测误差。\n\n```\nfor i = 1:numel(YTest)\n    YTestLast(i) = YTest{i}(end);\n    YPredLast(i) = YPred{i}(end);\nend\nfigure\nrmse = sqrt(mean((YPredLast - YTestLast).^2))\nhistogram(YPredLast - YTestLast)\ntitle(\"RMSE = \" + rmse)\nylabel(\"Frequency\")\nxlabel(\"Error\")\n```\n","categories":["机器学习"]},{"title":"LSTM实例2","url":"/2023/07/17/机器学习/LSTM实例2/","content":"# 使用深度学习进行序列分类\n\n此示例说明如何使用长短期记忆 (LSTM) 网络对序列数据进行分类。\n\n要训练深度神经网络以对序列数据进行分类，可以使用 LSTM 网络。LSTM 网络允许您将序列数据输入网络，并根据序列数据的各个时间步进行预测。\n\n此示例使用 [1] 和 [2] 中所述的日语元音数据集。此示例训练一个 LSTM 网络，旨在根据表示连续说出的两个日语元音的时序数据来识别说话者。训练数据包含九个说话者的时序数据。每个序列有 12 个特征，且长度不同。该数据集包含 270 个训练观测值和 370 个测试观测值。\n\n<!-- more -->\n\n### 加载序列数据\n\n加载日语元音训练数据。`XTrain` 是包含 270 个不同长度的 12 维序列的元胞数组。`Y` 是对应于九个说话者的标签 \"1\"、\"2\"、...、\"9\" 的分类向量。`XTrain` 中的条目是具有 12 行（每个特征一行）和不同列数（每个时间步一列）的矩阵。\n\n```\n[XTrain,YTrain] = japaneseVowelsTrainData;\nXTrain(1:5)\nans=5×1 cell array\n    {12×20 double}\n    {12×26 double}\n    {12×22 double}\n    {12×20 double}\n    {12×21 double}\n```\n\n在绘图中可视化第一个时序。每行对应一个特征。\n\n```\nfigure\nplot(XTrain{1}')\nxlabel(\"Time Step\")\ntitle(\"Training Observation 1\")\nnumFeatures = size(XTrain{1},1);\nlegend(\"Feature \" + string(1:numFeatures),'Location','northeastoutside')\n```\n\n![img](LSTM实例2/classifysequencedatausinglstmnetworksexample_01_zh_CN.png)\n\n### 准备要填充的数据\n\n在训练过程中，默认情况下，软件将训练数据拆分成小批量并填充序列，使它们具有相同的长度。过多填充会对网络性能产生负面影响。\n\n为了防止训练过程添加过多填充，您可以按序列长度对训练数据进行排序，并选择合适的小批量大小，以使同一小批量中的序列长度相近。下图显示了对数据进行排序之前和之后填充序列的效果。\n\n![img](LSTM实例2/classifysequencedatausinglstmnetworksexample_02_zh_CN.png)\n\n获取每个观测值的序列长度。\n\n```\nnumObservations = numel(XTrain);\nfor i=1:numObservations\n    sequence = XTrain{i};\n    sequenceLengths(i) = size(sequence,2);\nend\n```\n\n按序列长度对数据进行排序。\n\n```\n[sequenceLengths,idx] = sort(sequenceLengths);\nXTrain = XTrain(idx);\nYTrain = YTrain(idx);\n```\n\n在条形图中查看排序的序列长度。\n\n```\nfigure\nbar(sequenceLengths)\nylim([0 30])\nxlabel(\"Sequence\")\nylabel(\"Length\")\ntitle(\"Sorted Data\")\n```\n\n![img](LSTM实例2/classifysequencedatausinglstmnetworksexample_03_zh_CN.png)\n\n选择小批量大小 27 以均匀划分训练数据，并减少小批量中的填充量。下图说明了添加到序列中的填充。\n\n```\nminiBatchSize = 27;\n```\n\n![img](LSTM实例2/classifysequencedatausinglstmnetworksexample_04_zh_CN.png)\n\n### 定义 LSTM 网络架构\n\n定义 LSTM 网络架构。将输入大小指定为序列大小 12（输入数据的维度）。指定具有 100 个隐含单元的双向 LSTM 层，并输出序列的最后一个元素。最后，通过包含大小为 9 的全连接层，后跟 softmax 层和分类层，来指定九个类。\n\n如果您可以在预测时访问完整序列，则可以在网络中使用双向 LSTM 层。双向 LSTM 层在每个时间步从完整序列学习。如果您不能在预测时访问完整序列，例如，您正在预测值或一次预测一个时间步时，则改用 LSTM 层。\n\n```\ninputSize = 12;\nnumHiddenUnits = 100;\nnumClasses = 9;\n\nlayers = [ ...\n    sequenceInputLayer(inputSize)\n    bilstmLayer(numHiddenUnits,'OutputMode','last')\n    fullyConnectedLayer(numClasses)\n    softmaxLayer\n    classificationLayer]\nlayers = \n  5×1 Layer array with layers:\n\n     1   ''   Sequence Input          Sequence input with 12 dimensions\n     2   ''   BiLSTM                  BiLSTM with 100 hidden units\n     3   ''   Fully Connected         9 fully connected layer\n     4   ''   Softmax                 softmax\n     5   ''   Classification Output   crossentropyex\n```\n\n现在，指定训练选项。指定求解器为 `'adam'`，梯度阈值为 1，最大轮数为 100。要减少小批量中的填充量，请选择 27 作为小批量大小。要填充数据以使长度与最长序列相同，请将序列长度指定为 `'longest'`。要确保数据保持按序列长度排序的状态，请指定从不打乱数据。\n\n由于小批量数据存储较小且序列较短，因此更适合在 CPU 上训练。将 `'ExecutionEnvironment'` 指定为 `'cpu'`。要在 GPU（如果可用）上进行训练，请将 `'ExecutionEnvironment'` 设置为 `'auto'`（这是默认值）。\n\n```\nmaxEpochs = 100;\nminiBatchSize = 27;\n\noptions = trainingOptions('adam', ...\n    'ExecutionEnvironment','cpu', ...\n    'GradientThreshold',1, ...\n    'MaxEpochs',maxEpochs, ...\n    'MiniBatchSize',miniBatchSize, ...\n    'SequenceLength','longest', ...\n    'Shuffle','never', ...\n    'Verbose',0, ...\n    'Plots','training-progress');\n```\n\n### 训练 LSTM 网络\n\n使用 `trainNetwork` 以指定的训练选项训练 LSTM 网络。\n\n```\nnet = trainNetwork(XTrain,YTrain,layers,options);\n```\n\n![img](LSTM实例2/classifysequencedatausinglstmnetworksexample_05_zh_CN.png)\n\n### 测试 LSTM 网络\n\n加载测试集并将序列分类到不同的说话者。\n\n加载日语元音测试数据。`XTest` 是包含 370 个不同长度的 12 维序列的元胞数组。`YTest` 是由对应于九个说话者的标签 \"1\"、\"2\"、...、\"9\" 组成的分类向量。\n\n```\n[XTest,YTest] = japaneseVowelsTestData;\nXTest(1:3)\nans=3×1 cell array\n    {12×19 double}\n    {12×17 double}\n    {12×19 double}\n```\n\nLSTM 网络 `net` 已使用相似长度的小批量序列进行训练。确保以相同的方式组织测试数据。按序列长度对测试数据进行排序。\n\n```\nnumObservationsTest = numel(XTest);\nfor i=1:numObservationsTest\n    sequence = XTest{i};\n    sequenceLengthsTest(i) = size(sequence,2);\nend\n[sequenceLengthsTest,idx] = sort(sequenceLengthsTest);\nXTest = XTest(idx);\nYTest = YTest(idx);\n```\n\n对测试数据进行分类。要减少分类过程中引入的填充量，请将小批量大小设置为 27。要应用与训练数据相同的填充，请将序列长度指定为 `'longest'`。\n\n```\nminiBatchSize = 27;\nYPred = classify(net,XTest, ...\n    'MiniBatchSize',miniBatchSize, ...\n    'SequenceLength','longest');\n```\n\n计算预测值的分类准确度。\n\n```\nacc = sum(YPred == YTest)./numel(YTest)\n```\n\nacc = 0.9730\n","categories":["机器学习"]},{"title":"LSTM实例1","url":"/2023/07/15/机器学习/LSTM实例1/","content":"# 使用深度学习进行时序预测\n\n此示例说明如何使用长期短期记忆 (LSTM) 网络预测时序数据。\n\n要预测序列在将来时间步的值，您可以训练“序列到序列”回归 LSTM 网络，其中响应是将值移位了一个时间步的训练序列。也就是说，在输入序列的每个时间步，LSTM 网络都学习预测下一个时间步的值。\n\n要预测将来多个时间步的值，请使用 `predictAndUpdateState` 函数一次预测一个时间步，并在每次预测时更新网络状态。\n\n此示例使用数据集 `chickenpox_dataset`。该示例训练一个 LSTM 网络，旨在根据前几个月的水痘病例数来预测未来的水痘病例数。\n\n<!-- more -->\n\n### 加载序列数据\n\n加载示例数据。`chickenpox_dataset` 包含一个时序，其时间步对应于月份，值对应于病例数。输出是一个元胞数组，其中每个元素均为单一时间步。将数据重构为行向量。\n\n```\ndata = chickenpox_dataset;\ndata = [data{:}];\n\nfigure\nplot(data)\nxlabel(\"Month\")\nylabel(\"Cases\")\ntitle(\"Monthly Cases of Chickenpox\")\n```\n\n![img](LSTM实例1/timeseriesforecastingusingdeeplearningexample_01_zh_CN.png)\n\n对训练数据和测试数据进行分区。序列的前 90% 用于训练，后 10% 用于测试。\n\n```\nnumTimeStepsTrain = floor(0.9*numel(data));\n\ndataTrain = data(1:numTimeStepsTrain+1);\ndataTest = data(numTimeStepsTrain+1:end);\n```\n\n### 标准化数据\n\n为了获得较好的拟合并防止训练发散，将<mark>训练数据</mark>标准化为具有零均值和单位方差（响应变量并没有标准化）。<mark>在预测时，您必须使用与训练数据相同的参数来标准化测试数据。</mark>\n\n```\nmu = mean(dataTrain);\nsig = std(dataTrain);\n\ndataTrainStandardized = (dataTrain - mu) / sig;\n```\n\n### 准备预测变量和响应\n\n要预测序列在将来时间步的值，请将响应指定为将值移位了一个时间步的训练序列。也就是说，在输入序列的每个时间步，LSTM 网络都学习预测下一个时间步的值。预测变量是没有最终时间步的训练序列。\n\n```\nXTrain = dataTrainStandardized(1:end-1);\nYTrain = dataTrainStandardized(2:end);\n```\n\n### **定义 LSTM 网络架构**\n\n创建 LSTM 回归网络。指定 LSTM 层有 200 个隐含单元。\n\n- 注意这里的特征维度和响应维度都是1维的。\n\n```\nnumFeatures = 1;\nnumResponses = 1;\nnumHiddenUnits = 200;\n\nlayers = [ ...\n    sequenceInputLayer(numFeatures)\n    lstmLayer(numHiddenUnits)\n    fullyConnectedLayer(numResponses)\n    regressionLayer];\n```\n\n指定训练选项。将求解器设置为 `'adam'` 并进行 250 轮训练。要防止梯度爆炸，请将梯度阈值设置为 1。指定初始学习率 0.005，在 125 轮训练后通过乘以因子 0.2 来降低学习率。\n\n```\noptions = trainingOptions('adam', ...\n    'MaxEpochs',250, ...\n    'GradientThreshold',1, ...\n    'InitialLearnRate',0.005, ...\n    'LearnRateSchedule','piecewise', ...\n    'LearnRateDropPeriod',125, ...\n    'LearnRateDropFactor',0.2, ...\n    'Verbose',0, ...\n    'Plots','training-progress');\n```\n\n### 训练 LSTM 网络\n\n使用 `trainNetwork` 以指定的训练选项训练 LSTM 网络。\n\n```\nnet = trainNetwork(XTrain,YTrain,layers,options);\n```\n\n![img](LSTM实例1/timeseriesforecastingusingdeeplearningexample_02_zh_CN.png)\n\n### 预测将来时间步\n\n要预测将来多个时间步的值，请使用 `predictAndUpdateState` 函数一次预测一个时间步，并在每次预测时更新网络状态。对于每次预测，使用前一次预测作为函数的输入。\n\n使用与训练数据相同的参数来标准化测试数据。\n\n```\ndataTestStandardized = (dataTest - mu) / sig;\nXTest = dataTestStandardized(1:end-1);\n```\n\n要初始化网络状态，请先对训练数据 `XTrain` 进行预测。接下来，使用训练响应的最后一个时间步 `YTrain(end)` 进行第一次预测。循环其余预测并将前一次预测输入到 `predictAndUpdateState`。\n\n- 为什么要先使用XTrain来预测？\n\n  因为LSTM网络的隐藏状态和记忆细胞状态是需要初始化的，训练之后的网络只是确定了各个连接的权重和偏置，并没有包含这两个量，所以先要用XTrain来得到这两个量，然后输入到后面预测的时间步中。\n\n- 为什么要是更新网络状态？\n\n  更新网络状态就是更新隐藏状态和记忆细胞状态，不然一直是YTrain(end)的状态。\n\n- 为什么初始化和更新都是用predictAndUpdateState函数？\n\n  初始化的时候使用的是一个数组，这样就能从最开始一步一步predict到XTrain的最后一个数据，而不是一上来就用最后一个数据去预测和更新状态。后面测试的时候是因为数据已经连贯了，接着输入一个数据就可以了。\n\n对于大型数据集合、长序列或大型网络，在 GPU 上进行预测计算通常比在 CPU 上快。其他情况下，在 CPU 上进行预测计算通常更快。对于单时间步预测，请使用 CPU。要使用 CPU 进行预测，请将 `predictAndUpdateState` 的 `'ExecutionEnvironment'` 选项设置为 `'cpu'`。\n\n```\nnet = predictAndUpdateState(net,XTrain);\n[net,YPred] = predictAndUpdateState(net,YTrain(end));\n\nnumTimeStepsTest = numel(XTest);\nfor i = 2:numTimeStepsTest\n    [net,YPred(:,i)] = predictAndUpdateState(net,YPred(:,i-1),'ExecutionEnvironment','cpu');\nend\n```\n\n使用先前计算的参数对预测去标准化。\n\n```\nYPred = sig*YPred + mu;\n```\n\n训练进度图会报告根据标准化数据计算出的均方根误差 (RMSE)。根据去标准化的预测值计算 RMSE。\n\n```\nYTest = dataTest(2:end);\nrmse = sqrt(mean((YPred-YTest).^2))\nrmse = single\n    248.5531\n```\n\n使用预测值绘制训练时序。\n\n```\nfigure\nplot(dataTrain(1:end-1))\nhold on\nidx = numTimeStepsTrain:(numTimeStepsTrain+numTimeStepsTest);\nplot(idx,[data(numTimeStepsTrain) YPred],'.-')\nhold off\nxlabel(\"Month\")\nylabel(\"Cases\")\ntitle(\"Forecast\")\nlegend([\"Observed\" \"Forecast\"])\n```\n\n![img](LSTM实例1/timeseriesforecastingusingdeeplearningexample_03_zh_CN.png)\n\n将预测值与测试数据进行比较。\n\n```\nfigure\nsubplot(2,1,1)\nplot(YTest)\nhold on\nplot(YPred,'.-')\nhold off\nlegend([\"Observed\" \"Forecast\"])\nylabel(\"Cases\")\ntitle(\"Forecast\")\n\nsubplot(2,1,2)\nstem(YPred - YTest)\nxlabel(\"Month\")\nylabel(\"Error\")\ntitle(\"RMSE = \" + rmse)\n```\n\n![img](LSTM实例1/timeseriesforecastingusingdeeplearningexample_04_zh_CN.png)\n\n### 使用观测值更新网络状态\n\n如果您可以访问预测之间的时间步的实际值，则可以使用观测值而不是预测值更新网络状态。\n\n首先，初始化网络状态。要对新序列进行预测，请使用 `resetState` 重置网络状态。重置网络状态可防止先前的预测影响对新数据的预测。重置网络状态，然后通过对训练数据进行预测来初始化网络状态。\n\n```\nnet = resetState(net);\nnet = predictAndUpdateState(net,XTrain);\n```\n\n对每个时间步进行预测。对于每次预测，使用前一时间步的观测值预测下一个时间步。将 `predictAndUpdateState` 的 `'ExecutionEnvironment'` 选项设置为 `'cpu'`。\n\n```\nYPred = [];\nnumTimeStepsTest = numel(XTest);\nfor i = 1:numTimeStepsTest\n    [net,YPred(:,i)] = predictAndUpdateState(net,XTest(:,i),'ExecutionEnvironment','cpu');\nend\n```\n\n使用先前计算的参数对预测去标准化。\n\n```\nYPred = sig*YPred + mu;\n```\n\n计算均方根误差 (RMSE)。\n\n```\nrmse = sqrt(mean((YPred-YTest).^2))\nrmse = 158.0959\n```\n\n将预测值与测试数据进行比较。\n\n```\nfigure\nsubplot(2,1,1)\nplot(YTest)\nhold on\nplot(YPred,'.-')\nhold off\nlegend([\"Observed\" \"Predicted\"])\nylabel(\"Cases\")\ntitle(\"Forecast with Updates\")\n\nsubplot(2,1,2)\nstem(YPred - YTest)\nxlabel(\"Month\")\nylabel(\"Error\")\ntitle(\"RMSE = \" + rmse)\n```\n\n![img](LSTM实例1/timeseriesforecastingusingdeeplearningexample_05_zh_CN.png)\n\n这里，当使用观测值而不是预测值更新网络状态时，预测更准确。\n","categories":["机器学习"]},{"title":"深度学习基础概念","url":"/2023/07/12/机器学习/深度学习基础概念/","content":"\n- 学习笔记：[《动手学深度学习》 — 动手学深度学习 2.0.0 documentation (d2l.ai)](https://zh-v2.d2l.ai/)\n- pytorch 源码解读：[PyTorch 源码解读 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1316816403623084032?utm_source=wechat_session&utm_medium=social&utm_oi=1026969008788107264)\n- 一些博客：[Home - colah's blog](https://colah.github.io/)\n\n<!--more-->\n# 1.最基础的三个概念：Epoch, Batch, Iteration\n\n*转自：*[(57条消息) 卷积神经网络训练三个概念（epoch，迭代次数，batchsize）_训练epoch是什么意思_qq_37274615的博客-CSDN博客](https://blog.csdn.net/qq_37274615/article/details/81147013)\n\n----\n\n## 1.1 名词解释\n\n![img](深度学习基础概念/70.jpeg)\n\n**epoch**：训练时，所有训练数据集都训练过一次。\n\n**batch_size**：在训练集中选择一组样本用来更新权值。1个 batch 包含的样本的数目，通常设为2的 n 次幂，常用的包括64,128,256。网络较小时选用256，较大时选用64。\n\n**iteration**：训练时，1个 batch 训练图像通过网络训练一次（一次前向传播+一次后向传播），每迭代一次权重更新一次；测试时，1个 batch 测试图像通过网络一次（一次前向传播）。所谓 iterations 就是完成一次 epoch 所需的 batch 个数。\n\n## 1.2 换算关系\n\n![img](深度学习基础概念/70-16891593456231.jpeg)\n\n实际上，梯度下降的几种方式的根本区别就在于上面公式中的 Batch Size不同。\n\n>注：上表中 Mini-Batch 的 Batch 个数为 N / B + 1 是针对未整除的情况。整除则是 N / B。\n\n## 1.3 示例\n\nCIFAR10 数据集有 50000 张训练图片，10000 张测试图片。现在选择 Batch Size = 256 对模型进行训练。\n\n- **每个 Epoch 要训练的图片数量**：50000\n- **训练集具有的 Batch 个数**：50000/256=195+1=196\n- **每个 Epoch 需要完成的 Batch 个数**：196\n- **每个 Epoch 具有的 Iteration 个数**：196\n- **每个 Epoch 中发生模型权重更新的次数**：196 * 10\n- 训练代后，模型权重更新的次数：不同代的训练，其实用的是同一个训练集的数据。第1代和第10代虽然用的都是训练集的五万张图片，但是对模型的权重更新值却是完全不同的。因为不同代的模型处于代价函数空间上的不同位置，模型的训练代越靠后，越接近谷底，其代价越小。\n\n# 2. 张量\n\n*转自*：[笔记 | 什么是张量（tensor）& 深度学习 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/48982978)\n\n---\n\n在深度学习里，**Tensor实际上就是一个多维数组（multidimensional array）**。\n\n而Tensor的目的是**能够创造更高维度的矩阵、向量**。\n\n从知乎的相关讨论中截图几张说明的图：[什么是张量 (tensor)？](https://www.zhihu.com/question/20695804)\n\n![img](深度学习基础概念/v2-91fefb9a6227e8c11f8df316bc30cbb5_720w.jpg)\n\n现在将三维的张量用一个正方体来表示：\n\n![img](深度学习基础概念/v2-b279b633e5f17f7a0519601d99689298_720w.jpg)\n\n这样子可以进一步生成更高维的张量：\n\n![img](深度学习基础概念/v2-00d07246473e1b195b4b69a84fec280a_720w.jpg)\n\n这有啥用呢？在用TensorFlow处理更高维数据结构的时候，最好可以能够在脑子里相出数据的形状。\n\n举个简单的例子，彩色图像文件（RGB）一般都会处理成3-d tensor，每个2d array中的element表示一个像素，R代表Red，G代表Green，B代表Blue：\n\n![img](深度学习基础概念/v2-08c6ca8d12ba2ea5194cb532e73a9c44_720w.webp)\n\n","categories":["机器学习"]},{"title":"Mapping Individual Motor Unit Activity to Continuous Three-DoF Wrist Torques: Perspectives for Myoelectric Control","url":"/2023/07/06/论文/Deep Learning/Mapping-Individual-Motor-Unit-Activity-to-Continuous-Three-DoF-Wrist-Torques-Perspectives-for-Myoelectric-Control/","content":"以往的研究主要集中在离散的动作和单自由度。在基于回归的连续控制方案中，EMG信号通常被视为随机信号，其中运动运动学/动力学由统计特性反映。尽管SPC相关研究在过去十年中取得了巨大的进展，但实现自然直观的基于EMG的控制仍然具有挑战性。本文是第一篇考虑3自由度连续力矩估计的。\n\n<!-- more -->\n# 1. Introuction\n\n肌电的离散控制方案：\n\n- 状态机\n- 模式识别\n\n肌电的连续控制方案：\n\n- regression model\n- simultaneous adn proportional control\n\n<font color = \"red\">基于MUAPT的关节连续运动估计：</font>\n\n> *Predicting wrist kinematics from motor unit discharge timings for the control of active prostheses* \n>\n> *Real-time isometric finger extension force estimation based on motor unit discharge information* \n>\n> *Man/machine interface based on the discharge timings of spinal motor neurons after targeted muscle reinnervation* \n>\n> *In vivo neuromechanics: Decoding causal motor neuron behavior with resulting musculoskeletal function*  \n\n<font color = \"red\">通过放电属性来线性估计激活程度：</font>\n\n> *Predicting wrist kinematics from motor unit discharge timings for the control of active prostheses*  \n>\n> *Finger joint angle estimation based on motoneuron discharge activities*  \n>\n> *放电率跟运动参数高度相关:* *Prediction of finger kinematics from discharge timings of motor units: Implications for intuitive control of myoelectric prostheses*  \n\n<font color = \"red\">MUAPT得到的神经驱动用于神经肌肉-骨骼模型：</font>\n\n> *In vivo neuromechanics: Decoding causal motor neuron behavior with resulting musculoskeletal function* \n>\n> *Neuromusculoskeletal mapping for man-machine interfacing*  \n\n基于MUAPT控制的优势：\n\n- 能够更好的理解深层的运动\n- 基于MUAPT的控制范式在自然和灵巧控制中更有优势\n\n**本文的意义：**\n\n先前的研究主要研究了基于MUAPT的连续控制在单个DoF或两个DoF（本文是3个）任务中的可行性。此外，与传统的连续控制相比，基于MUAPT的控制实验协议相对简单，不能满足实际应用。为了克服这些限制，本研究旨在将从高密度表面肌电信号中识别的运动单元放电映射为多DoF和连续手腕扭矩。\n\n# 2. Methods\n\n受试者执行等长收缩，没有关节运动\n\n**实验范式**：7个 session，session 之间休息1-2分钟，每个 session 对应一个 task，每个 session 包含两个，每个 trial 中执行 task 的周期为2-3s，每个 trial 持续20s。第一个 trial 的信号用作训练，第二个 trial 的信号用作测试\n\n**3个自由度分别是：**\n- pronation - supination\n- wrist flexion - wrist extension\n- ulnar deviation - radius deviation\n\n**高密度肌电**：3 * 64通道\n\n<font color = \"red\">分解方法：</font>segment-wise decomposition method\n> Segment-wise decomposition of surface electromyography to identify discharges across motor neuron populations\n\n先使用上述方法在1自由度下分解得到分离向量，然后把分离向量用在多自由度的肌电信号在线分解中。神经特征被提取并通过线性回归模型映射到力矩上。\n\n**力矩信号的预处理**：通过插值升至2048Hz，然后20Hz 低通滤波过滤基线噪声\n\n**EMG 信号的预处理**：4阶巴特沃斯，20-500Hz，50Hz 陷波\n\n**无效通道的剔除**：rms 高于均值的3倍\n\n把单自由度的信号级联起来分解，每个电极片单独分解，剔除重复：\n![image-20231011161049914](Mapping-Individual-Motor-Unit-Activity-to-Continuous-Three-DoF-Wrist-Torques-Perspectives-for-Myoelectric-Control/image-20231011161049914.png)\n\n# 3. Analysis\n\n**提取两种神经特征：**\n\n- MU发放时的抽搐力\n\n  > 抽搐力的模型：\n  >*Models of recruitment and rate coding organization in motor-unit pools* \n  \n- 滑动窗口中MU发放的次数\n\n**线性估计方法：**\n\n![image-20231011172949151](Mapping-Individual-Motor-Unit-Activity-to-Continuous-Three-DoF-Wrist-Torques-Perspectives-for-Myoelectric-Control/image-20231011172949151.png)\n\n**评价回归效果的指标：**\n- 皮尔森相关系数\n- 决定系数\n- 标准化均方根误差\n- 粗糙度：用于评估输出平滑度，表示估计和记录的波动水平之间的比率\n\n**单因素方差分析**：ANOVA，类似于控制变量法，探究单个因素对组别的影响\n\n**分解结果是的形式是**：均值±标准差，这是对所有被试进行统计分析得到的\n\n# 4. Results\n\n- segment-wise分解方法可以分解出更多的MU\n\n- 多自由度训练的效果更好\n\n- 抽搐力比ST的效果更好，准确率和平滑度更好\n\n- fle-ext这个自由度的估计效果是最好的\n\n- 与以前的研究相比，在多DoF手腕运动过程中发现了更多的MUAPT。尽管运动单位数量的增加是以分解精度的下降为代价的，但基于神经特征的转矩估计在多DoF任务中显示出较高的精度。\n\n- 通过保留分离向量的方法，可以在任务之间跟踪MU\n\n  > *Real-time isometric finger extension force estimation based on motor unit discharge information* \n  >\n  > *Simultaneous and proportional control of wrist and hand movements by decoding motor unit discharges in real time*\n\n- 非震荡的自由度会导致更大的误差\n\n","tags":["上交"],"categories":["论文","Deep Learning"]},{"title":"Surface Electromyography Image-Driven Torque Estimation of Multi-DoF Wrist Movements","url":"/2023/07/06/论文/Deep Learning/Surface-Electromyography-Image-Driven-Torque-Estimation-of-Multi-DoF-Wrist-Movements/","content":"\n# 1. Introduction\n\n肌电控制主要有两个方案：\n\n- PR-based control\n- regression-based control\n\n通常只包含时域特征或者频域特征。\n\n多自由度手腕动作估计：\n\n> *Regressionconvolutional neural network for improved simultaneous EMG control*\n> *Decoding simultaneous multi-DOFwrist movements from raw EMG signals using a convolutional neural network*\n\n肌电控制中，CNN模型能够用于减少电极移位的影响，并结合自我校准来在跨天的情况下保持性能。\n\n**本文的意义**：\n\n力的变化会影响运动单元募集的<mark>空间分布</mark>，进而导致sEMG信号的不同空间模式。因此，将空间信息引入基于sEMG信号的SPC具有至关重要的意义。本文将每一时刻的高密度肌电作为一幅图像，使用CNN进行力矩估计。\n\n# Methods\n\n**实验范式**：单自由度——5个 trial；双自由度——2个 trials。每个 trial 持续30s，动作的频率小于1Hz\n\n![image-20231013222131728](Surface-Electromyography-Image-Driven-Torque-Estimation-of-Multi-DoF-Wrist-Movements/image-20231013222131728.png)\n\n**神经网络的结构**：27层\n\n![image-20231013223036822](Surface-Electromyography-Image-Driven-Torque-Estimation-of-Multi-DoF-Wrist-Movements/image-20231013223036822.png)\n\n输入：8 × 24 × 1\n\n输出：1 × 1 × 2\n\n**评价标准**：\n\n![image-20231013223121615](Surface-Electromyography-Image-Driven-Torque-Estimation-of-Multi-DoF-Wrist-Movements/image-20231013223121615.png)\n\n对预测后的力矩进行了一个滑动窗口滤波，滤除了尖刺，更平滑更接近真实的力矩\n\n**与传统的回归器做比较**：\n\n- linear regression (LR)  \n- support vector regression (SVR)  \n- artificial neural network utilizing histogram of oriented gradient (annHOG) as features  \n- CNN model with short-time Fourier transform (STFT-CNN)  \n\n# 3. Conclusion\n\n- 本文提出的方法有最高的相关系数，最小的nRMSE，最好的平滑度\n- 对CNN提取的特征做主成分分析，发现第一主成分和Fle-Ext的力矩相关；第二主成分和Pro-Sup的力矩相关\n","tags":["上交"],"categories":["论文","Deep Learning"]},{"title":"Wrist Torque Estimation via Electromyographic Motor Unit Decomposition and Image Reconstruction","url":"/2023/07/06/论文/Control/Wrist-Torque-Estimation-via-Electromyographic-Motor-Unit-Decomposition-and-Image-Reconstruction/","content":"\n重点精读文章。这篇文章的literature review部分介绍了很多关于手腕运动学估计的文献，值得学习，为小论文做准备。这篇文章的方法是先把HD-EMG分解成MUST，然后用MUAP卷积MUST得到各个电极处重构的EMG信号，重构的EMG信号构成了一张图像，N个MU的图像构成了CNN某一时刻的输出。这篇文章分析了MU-specific image和discharge rate的回归效果，发现MU-specific image包含更多的local information，而discharge rate只包含了开关量。讨论部分，文章对比了CNN-DR，LR-DR，SVR-DR，ANN-DR，和CNN-image之间的回归效果，通过R2和nRMSE来评价模型的优劣。这篇文章的方法值得借鉴，没有简单地一开始就考虑图像，而是先分解得到MUST，再重构图像。\n\n<!-- more -->\n\n# 1.Intro\n\nsEMG是由MUAP和MUST的卷积结果叠加形成的。受神经支配的肌肉纤维收缩并驱动骨骼肌产生所需的运动。\n\n肌电控制的直接控制通常只能控制一个自由度，因而通过模式识别来实现多个自由度的控制，区分手部的不同pattern，但是这种方法是离散的，不能对连续动作解码。\n\n> still consider the sEMG signals as an interfered source signal and ignore the underlying generation process in physiology 。\n\n文献《Decoding motor unit activity from forearm muscles: Perspectives for myoelectric control》验证了<mark>非等长收缩下手腕动作</mark>MU解码的可行性。\n\n文章指出了使用discharge rate的缺点，由此引出图像能够包含更丰富的信息：\n\n>值得注意的是，大多数基于分解MU的现有范式仅基于DR特征，这些特征已被证明是有效的，但可能缺乏放电瞬间周围的局部信息，并忽略了不同MU的微妙相互作用。由于DR特征来源于运动单位的开关状态，因此该时刻的激活水平（即局部信息）不足。此外，人工提取的DR特征是否是HMI中MUST特征提取的最佳和代表，这仍然是一个悬而未决的问题。\n\n# 2.Experiments\n\n**人数**：10人。健康：7男1女；残疾：1男1女\n\n**数据采集：**\n\n- 力矩：2 DOF，伸/缩，内旋/外旋，采样率1000Hz\n- HD-EMG：3 * 64通道，2048Hz (EMG-USB2+, OT Bioelettronica, Italy)  ，尽可能覆盖前臂的肌肉\n- 同步：发送同步脉冲\n\n**实验范式**：通过光标的移动来指示（可以改进）\n\n**实验数目**：两个任务，每个任务包含5个 trial，每个 trial 持续29s（<font color = \"red\">分解算法对时间有要求吗</font>）\n\n**动作**：flexion/extension, pronation/supination，<font color = \"red\">等长收缩</font>\n\n# 3. Method\n\n**数据预处理：**\n\n- 4阶巴特沃斯带通滤波器，20-500Hz\n- 50Hz陷波滤波器\n- 丢弃信噪比低的通道\n- 力矩通过4Hz 4阶低通巴特沃斯滤波器滤波，重采样至2048Hz\n\n**MU-specific image：**\n\n通过 MUAP 和 MUST 卷积来重建（resconstructed）单个 MU 的放电信号，然后把每个通道重建的信号按电极顺序排列成8 * 24网格，称为 MU-specific image。\n\n**排除重复MU：**\n\n> 在本研究中，EMG信号的分解是在每个电极阵列中单独进行的。由于EMG信号的串扰，相邻电极阵列应该包含一些共模信号。因此，分解的尖峰序列可能具有重复的尖峰序列，如果两个尖峰序列的一致性（RoA）超过30%，则会消除重复的尖峰。\n\n这说明64通道分解的结果是有效的，通道数的多少无非是得到MU的多少，即使电极片数更多，但可能会分解得到相同的MU。<font color = \"red\">可以在代码中添加RoA的判断条件来确保没有得到重复的MU。</font>\n\n**有效MU的判断条件：**\n\n> Those MUSTs with PNR below 20 dB were discarded because of low decomposition confidence.  \n\n<font color = \"red\">低于20dB的MU被排除，并不是低于30</font>\n\n**CNN的输入和输出：**\n\n- 如果识别到N个MU，那么某一个时刻根据这些MU重建的N个图像就构成了CNN的输入：8 × 24 × N MU-images\n- 与Pro-Sup，Fle-Ext对应的二维向量（<font color = \"red\">？</font>）\n\n**CNN数据集划分：**\n\n- 10%验证集\n- 20%测试集\n- 70%训练集\n\n**滑动窗口：**\n\n- 200ms宽，150ms重叠\n\n**多种回归器的对比：**\n\n- LR-DR（DR代表discharge rate）\n- SVR-DR\n- ANN-DR\n- CNN-DR\n\n传统的回归方法使用discharge rate作为特征，N × 1  的特征作为回归模型的输入。他是把各个MU的放电率分开来的，不是CST。对比结果如下，明显更优。\n\n![image-20231008162956889](Wrist-Torque-Estimation-via-Electromyographic-Motor-Unit-Decomposition-and-Image-Reconstruction/image-20231008162956889.png)\n\n**评价指标：**\n\n- 决定系数：\n\n$$\nR^2=1-\\frac{\\sum_{i=1}^n\\left(\\hat{T}_i-T_i\\right)^2}{\\sum_{i=1}^n\\left(T_i-\\bar{T}\\right)^2}\n$$\n\n- 归一化均方误差：\n\n$$\nnRMSE=\\frac{\\sqrt{\\sum_{i=1}^n\\left(\\hat{T}_i-T_i\\right)^2/n}}{T_{\\mathrm{max}}-T_{\\mathrm{min}}}\\times100\\%\n$$\n\n**MU统计：**\n\n分别分解来自每个电极阵列的EMG信号，然后根据放电序列剔除重复的运动单位，进而合并得到的全部的运动单位。对于每个受试者的每次试验，在激活Pro/Sup和Fle/Ext时，可以从EMG信号中分解出20多个运动单位。\n\n**特征分析：**\n\n分析了测试数据集下每个DoF中记录的手腕力矩与`从dropout层后训练的CNN模型中提取的特征`以及`DR特征`之间的相互关系。具体来说，我们分别通过对CNN模型提取的特征和DR特征进行了主成分分析。\n\n> PC1-MUimage and PCsDev-DR across all the subjects were calculated.\n\n- Regardless of Pro-Sup or Fle-Ext, the cross-correlation of PC1-MUimage with wrist torques was <mark>much higher</mark> than that of PCsDev-DR. \n\n- The extracted features from MU-specific images had much stronger linearity than DR features with respect to the recorded wrist torques.  \n","tags":["上交","TNSRE","Image","Wrist-Torque"],"categories":["论文","Control"]},{"title":"Behaviour of human motor units in different muscles during linearly varying contractions","url":"/2023/06/27/论文/Characteristic/Behaviour-of-human-motor-units-in-different-muscles-during-linearly-varying-contractions/","content":"\nmotor unit的标准翻译是运动单位。这是很重要的一篇文章，文章从人类三角肌和第一背骨间 （f.d.i.） 肌肉记录了多达 8 个同时活动的运动单位的电活动。检测到的肌电信号已使用最近开发的技术分解为构成的运动单位动作电位序列。结果显示，根据运动神经兴奋性，在两种肌肉肌肉和所有受试者组中，存在高度有序的募集和去募集方案。\n\n<!-- more -->\n\n# 1. 笔记\n\n在人类三角肌和第一骨间背侧肌（f.d.i）的三角形力变化等长收缩过程中，同时研究了两个和八个运动单位之间的关系。在这两块肌肉中总共检查了286个单独的m.u.A.p.序列。之所以选择f.d.i.进行研究，是因为肌肉中产生的等长张力与食指外展的等长力近似成线性比例。类似地，由连接到手臂的袖带测量的等长力与由三角肌的中间纤维产生的等长张力近似成线性比例。fdi的运动单位放电频率随着力水平的增加而逐渐增加，而deltoid运动单位的放电率在募集后突然增加，但随着力的增加放电频率只微微增大。因此在deltoid中募集是发力的主要机制，而在fdi中放电频率是发力的主要机制。\n\n## 1.1 实验\n\n**人数**：13名男性\n\n**力记录**：提供了三角肌等长收缩的方法\n\n**力曲线：**\n\n- 三角形，等长收缩。这种曲线允许记录完整的运动单位放电频率：从开始募集，经过力的增加和减小阶段（速率编码），到去募集。\n\n- 40%m.v.c.和80%m.v.c.的峰值力。\n\n**收缩水平**：为了提供一种比较不同技术受试者组表现的方法，在三次短暂的非疲劳性收缩后，对受试者的最大自主收缩（m.v.c.）水平进行平均。尽一切努力保持m.v.c.测量的一致性。随后所需收缩的水平被指定为该力的百分比（%m.v.c.）。\n\n**EMG 记录**：将单个双极针电极插入肌肉中并定位以记录在上述每次收缩期间两到八个单独运动单元的放电。\n\n**实验变量：**\n\n- 被试\n- 力曲线斜率\n- 最大力\n\n## 1.2 方法\n\n**放电率：**\n\n<font color = \"red\">每个运动单位的时变平均放电频率是通过使与运动单位放电时间相对应的脉冲串通过对称的单位面积来估计的（不理解）。</font>\n\n汉宁窗口数字滤波器。之所以选择这种方法，是因为平滑程度与放电频率无关，并且计算的放电频率估计是无偏的，没有时间延迟失真。滤波器的宽度可以改变为在可变时间内的平均，从而影响放电频率的平滑度。使用400毫秒宽的滤波器来检查此处研究的三角形力变化收缩期间的放电频率变化。\n\n**募集阈值**：用 MVC 的一个百分比表示\n\n## 1.3 结果\n\n**力的产生机制：**\n\n- 特定肌肉的机械性能高度依赖于其纤维成分：快速抽搐与慢速抽搐纤维的比例可以决定肌肉主要是静态的还是动态的。\n\n- 肌肉使用不同的机制来将力量输出增加到40%以上：三角肌主要依赖于募集，f.d.i.依赖于速率编码。\n\nf.d.i.是一种解剖学上受限的小肌肉，由大约120个运动单位组成（Feinstein，Lindegard，Nyman&Wohlfart，1955）。一旦它们变得活跃起来，即使是其中最小的一个也必须对肌肉的总力量输出做出显著贡献。如果募集是补充力的唯一（甚至是主要）手段，肌肉将无法产生平稳增加的收缩。随着力的增大，有序的运动单位将在力输出记录中产生“阶梯”效应。然而，f.d.i.的功能是使食指产生小而准确的运动，需要精细的力量分级。为了补偿其电机单元的稀疏性，f.d.i依赖于高度动态的速率编码来产生平滑的、线性变化的等距收缩。\n\n相比之下，三角肌是一块大肌肉，有多达1000个运动单位（与二头肌中约770个运动单位相比；Christensen，1959），每个运动单位在总力量输出中所占的比例相对较小。由于三角肌主要用于产生大而有力的收缩，因此在正常的自主活动中，精细控制的放电频率是不必要的。每个新募集的运动单位可以提供足够小的力增量，以产生功能上平滑的收缩。\n","tags":["MUAP","MUST","DeLuca"],"categories":["论文","Characteristic"]},{"title":"Fluctuations in isometric muscle force can be described by one linear projection of low-frequency components of motor unit discharge rates","url":"/2023/05/15/论文/Characteristic/Fluctuations-in-isometric-muscle-force-can-be-described-by-one-linear-projection-of-low-frequency-components-of-motor-unit-discharge-rates/","content":"\n这篇文章研究了肌肉等长收缩力可以通过一个线性映射来描述，该映射是运动单位放电频率的低频成分。研究人员记录了来自八名健康男性拇指外展肌的肌内 (电极)和高密度表面肌电图(13x5电极网格)，并在最大力的5%、7.5%和10%外进行了60秒的收缩。通过分解算法从肌电图记录中识别出总共222个运动单位的尖峰队列。主成分分析表明，第一个共同成分（FCC）在整个收缩间隔内描述了平滑放电率的44.2+7.5%，而在5秒间隔内描述了64.3+10.2%。当FCC是由每次收缩四个或更多个运动单位计算出来时，相比于单个运动单位，它与肌肉产生的力(62.7+10.1%)相关性更大 (P<0.001)。总之，FCC获得了运动单位放电率低频成分的大部分。\n\n- 表面EMG信号的包络是通过用持续时间为400ms的Hann窗口对整流的EMG进行滤波而从网格的中心位置的通道计算的。\n\n- 使用持续时间为400 ms的Hann窗口对每个运动单元的瞬时放电率进行平滑，并使用0.75 Hz的截止频率进行高通滤波（零相位滤波器，H（f）=1−sin（πf/)πf），以消除先前研究中提出的偏移和趋势（De Luca等人，1982）。","tags":["MUST"],"categories":["论文","Characteristic"]},{"title":"生物神经网络","url":"/2023/05/15/机器学习/生物神经网络/","content":"\n 参考链接：[Hello! - Jack Terwilliger](http://jackterwilliger.com/)","categories":["机器学习"]},{"title":"RNN与LSTM","url":"/2023/05/12/机器学习/RNN与LSTM/","content":"- **RNN讲解：**[【循环神经网络】5分钟搞懂RNN，3D动画深入浅出_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1z5411f7Bm/?spm_id_from=333.337.search-card.all.click&vd_source=f9284418e385ee0855b280e1ab5cb560)\n\n- **李宏毅推导：**[26.循环神经网络RNN（II）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ux411S7Yk?p=26&vd_source=f9284418e385ee0855b280e1ab5cb560)\n\n- **matlab代码分析：**[(49条消息) 基于MATLAB的LSTM神经网络时序预测（完整代码+范例数据文件）_lstm matlab_Tooto_ttt的博客-CSDN博客](https://blog.csdn.net/m0_56146217/article/details/123577068)\n\n- **lstm交替步长：**[lstm原理+timesteps理解+实操+时间序列多变量_jiekclek的博客-CSDN博客](https://blog.csdn.net/henielh/article/details/106956131?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D)\n\n<!-- more -->\n\nRNN对两个时刻的隐藏层进行了连接，使得神经网络具有记忆功能。\n\n![](RNN与LSTM/image-20230512101328525.png)\n\n![image-20230523165438853](RNN与LSTM/image-20230523165438853.png)\n\n**LSTM 讲解**：[【LSTM长短期记忆网络】3D模型一目了然，带你领略算法背后的逻辑](https://www.bilibili.com/video/BV1Z34y1k7mc/?spm_id_from=333.788&vd_source=f9284418e385ee0855b280e1ab5cb560)\n\nLSTM相较于RNN增加了一条新的时间链：\n\n![image-20230512102505189](RNN与LSTM/image-20230512102505189.png)\n\n![image-20230512102949179](RNN与LSTM/image-20230512102949179.png)\n\n![image-20230523172713953](RNN与LSTM/image-20230523172713953.png)\n\n![image-20230523201850973](RNN与LSTM/image-20230523201850973.png)\n\n![image-20230712205839798](RNN与LSTM/image-20230712205839798.png)\n\n实际上，LSTM的网络是这样的：\n\n![img](RNN与LSTM/v2-72cf098084ed6a1ac68798b6b81f784c_720w.webp)\n\n上面的图表示包含2个隐含层的LSTM网络，在T=1时刻看，它是一个普通的BP网络，在T=2时刻看也是一个普通的BP网络，只是沿时间轴展开后，T=1训练的隐含层信息H,C会被传递到下一个时刻T=2，如下图所示。上图中向右的五个长长的箭头，说的也是隐含层状态在时间轴上的传递。\n\n# 使用深度学习进行时间序列预测\n\n此示例说明如何使用长期短期记忆 (LSTM) 网络预测时间序列数据。\n\nLSTM 网络是一种循环神经网络 (RNN)，它通过遍历时间步并更新 RNN 状态来处理输入数据。RNN 状态包含在所有先前时间步中记住的信息。您可以使用 LSTM 神经网络，通过将先前的时间步作为输入来预测时间序列或序列的后续值。要为时间序列预测训练 LSTM 神经网络，请训练具有序列输出的回归 LSTM 神经网络，其中响应（目标）是将值移位了一个时间步的训练序列。也就是说，在输入序列的每个时间步，LSTM 神经网络都学习预测下一个时间步的值。\n\n有两种预测方法：开环预测和闭环预测。\n\n- 开环预测仅使用输入数据预测序列中的下一个时间步。对后续时间步进行预测时，需要从数据源中收集真实值并将其用作输入。例如，假设您要使用时间步 1 到 *t*−1 中收集的数据来预测序列的时间步 *t* 的值。要对时间步 *t*+1 进行预测，请等到记录下时间步 *t* 的真实值，并将其用作输入进行下一次预测。在进行下一次预测之前，如果有可以提供给 RNN 的真实值，则请使用开环预测。\n- 闭环预测通过使用先前的预测作为输入来预测序列中的后续时间步。在这种情况下，模型不需要真实值便可进行预测。例如，假设您要仅使用在时间步 1 至 *t*−1 中收集的数据来预测序列的时间步 *t* 至 *t*+*k* 的值。要对时间步 *i* 进行预测，请使用时间步 *i*−1 的预测值作为输入。使用闭环预测来预测多个后续时间步，或在进行下一次预测之前没有真实值可提供给 RNN 时使用闭环预测。\n\n### 指定训练数据\n\n首先，你需要将所有数据分成三个部分(当然可以不要验证集，一般论文里我们是返回验证集上的最优模型)：训练集、验证集和测试集，也就是把3000行数据分成三部分，一般是622或者712，这里以622为例，也就是说训练集中有1800条数据，验证集和测试集各600条数据。\n\n然后你需要对训练集中的数据进行归一化，例如最大最小值归一化，然后假设你使用前100个数据预测接下来10个数据(比如你可以用前100个数据的300个特征预测接下来10个数据的某一个或者某几个特征，例如你可以用前100个时刻的ABCDE特征预测接下来10个时刻的A特征或者10个时刻的ABC特征，这里以10个A特征为例)，那么此时你构建的第1个样本应该为(X=1...100，Y=101...110)，第二个样本为(X=2...101，Y=102...111)，最后一个样本为(X=1691...1790 Y=1791...1800)。\n\n这样，你的训练集中一个包含了1691个样本，然后你就可以进一步进行分批处理。分批处理前你可以打乱这1691个样本，这种打乱是不会对LSTM的训练造成影响的，<mark>因为每个样本的内部是有序的</mark>，LSTM处理的是这100个数据间的时序关系。但是如果你用sgd或者[minibatch](https://www.zhihu.com/search?q=minibatch&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A2581549999})，一般来讲靠前的batch会对[模型梯度](https://www.zhihu.com/search?q=模型梯度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A2581549999})造成更大影响，为了公平起见，可以选择打乱数据。\n\n打乱数据后就可以开始进行批次处理，比如batch_size=100，也就是将1691个样本每100个分为一组，这样你一共可以得到17个batch的数据，除了最后一个[bacth](https://www.zhihu.com/search?q=bacth&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A2581549999})的X为(batch_size=91,seq_len=100, input_size=5)，Y为(batch=91, output_size=1)以外，其他16个batch的X为(batch_size=100,seq_len=100, input_size=5)，Y为(batch=100, output_size=1)。\n\n### 准备要填充的数据\n\n在训练过程中，默认情况下，软件将训练数据拆分成小批量并填充序列，使它们具有相同的长度。过多填充会对网络性能产生负面影响。\n\n为了防止训练过程添加过多填充，您可以按序列长度对训练数据进行排序，并选择合适的小批量大小，以使同一小批量中的序列长度相近。下图显示了对数据进行排序之前和之后填充序列的效果。\n\n![img](RNN与LSTM/classifysequencedatausinglstmnetworksexample_02_zh_CN.png)\n\n### 定义 LSTM 神经网络架构\n\n创建一个 LSTM 回归神经网络。\n\n- 使用输入大小与输入数据的通道数匹配的序列输入层。\n- 接下来，使用一个具有 128 个隐藏单元的 LSTM 层。隐藏单元的数量确定该层学习了多少信息。使用更多隐藏单元可以产生更准确的结果，但也更有可能导致训练数据过拟合。\n- 要输出通道数与输入数据相同的序列，请包含一个输出大小与输入数据通道数匹配的全连接层。\n- 最后，包括一个回归层。\n\n```\nlayers = [\n    sequenceInputLayer(numChannels)\n    lstmLayer(128)\n    fullyConnectedLayer(numChannels)\n    regressionLayer];\n```\n\n- 批归一化在每一层中用于减少内部协变量移位。\n- Dropout使神经元以一定概率丢失，以防止每个隐藏层后面的过拟合问题。\n\n### LSTM 层架构\n\n下图说明具有 C 个长度为 S 的特征（通道）的时序 X 通过 LSTM 层的流程。在图中，**h**t 和 **c**t分别表示在时间步 t 的输出（也称为*隐藏状态*）和 *单元状态*。\n\n![img](RNN与LSTM/lstmflow.png)\n\n第一个 LSTM 模块使用网络的初始状态和序列的第一个时间步来计算第一个输出和更新后的单元状态。在时间步 t 上，该模块使用网络的当前状态 (**c**t−1,**h**t−1) 和序列的下一个时间步来计算输出和更新后的单元状态 **c**t。\n\n该层的状态由*隐藏状态*（也称为*输出状态*）和*单元状态*组成。时间步 t 处的隐藏状态包含该时间步的 LSTM 层的输出。单元状态包含从前面的时间步中获得的信息。在每个时间步，该层都会在单元状态中添加或删除信息。该层使用不同的门控制这些更新。\n\n### 指定训练选项\n\n指定训练选项。\n\n- 使用 Adam 优化进行训练。\n- 进行 200 轮训练。对于较大的数据集，您可能不需要像良好拟合那样进行这么多轮训练。\n- 在每个小批量中，对序列进行左填充，使它们具有相同的长度。左填充可以防止 RNN 预测序列末尾的填充值。\n- 每轮训练都会打乱数据。\n- 在绘图中显示训练进度。\n- 禁用详细输出。\n\n- matlab中在对LSTM进行训练时需要明确是sequence to sequence还是sequence to last。前者是在每一个时间步都进行预测，后者是只在最后一个时间步进行预测，详细请参考matlab文档说明。EMG-force的回归主要用到sequence to sequence。\n\n---\n\n**一些评论：**\n\n> ——看了不少LSTM简单实例，发现都是滚动预测。宣称预测后三年数据，其实每次只能预测后一个月的数据，我称之为假 · 预测。\n>\n> ​\t——您好，用神经网络做预测的时候，目前大多是都只预测下一个时间步的，如果需要长时预测（例如预测未来3s的车辆轨迹），那就需要滚动预测或者迭\t代了。您有不同的见解挺好的，可以麻烦提供新的思路以做讨论吗，谢谢！\n>\n> ​\t\t——可以看看seq2seq、注意力机制还有transformer之类的，我看的李沐和李宏毅的讲解。虽然我目前还是做的滚动预测，不过可以一次输出多个时间\t\t步然后再滚动。遇到的问题就是这种复杂模型因为各种原因不一定有效果，比如数据量不够，只能说是值得一试。\n","categories":["机器学习"]},{"title":"A convolutional neural network to identify motor units from high-density surface electromyography signals in real time","url":"/2023/04/29/论文/Deep Learning/A-convolutional-neural-network-to-identify-motor-units-from-high-density-surface-electromyography-signals-in-real-time/","content":"\n重要程度: ⭐⭐⭐⭐⭐\n\n# 为什么看这篇文献？\n\n- 利用高密度肌电，通过卷积神经网络识别运动单元的尖峰序列以及实时估计肌肉的神经驱动\n- 两种不同的CNN网络与卷积核补偿算法（CKC）进行了比较，分别从仿真和实验上\n- 探究窗口大小和步长的影响\n- 该方法是用于识别运动单元的。运动单元目前有多种分解方法，如FastICA算法、CKC算法，本文是在CKC算法的基础上缩短识别时间\n\n<!-- more -->\n\n# 看文献过程中的笔记：\n\n## ❓疑问：\n\n- 98%和85%的准确率和灵敏性分别代表什么？\n\n  > 准确率是识别错的，灵敏性是没识别到的\n\n- 为什么要把CKC识别的尖峰序列用于CNN的训练\n\n  > 用作输出标记值\n\n- 什么是消失梯度问题？\n\n- 目视检查并手动编辑所有MU尖峰序列[37]\n\n- 脉冲噪声比（PNR）>30 dB的MU被保留用于进一步分析[34]\n\n    \n\n## ✍️笔记：\n\n*2023.09.14*\n\n---\n\n**这篇文章的初衷**：这篇文章考虑到分解算法种的矩阵扩展和白化需要很多时间。自己在跑代码的时候发现，白化还好，矩阵扩展真的需要花费很大的时间，特别是当 R 很大的时候，而且就是分解也需要迭代很多次，速度非常慢，因此实时性是不可能的，所以这篇文章提出了用 CNN 来直接识别 MUST。\n\n回顾了文献《A convolutional neural network to identify motor units from high-density surface electromyography signals in real time》，这篇文章说到盲源分离算法的时间成本很高，回过头来确实是这样的，特别是信号的扩展那一步，如果扩展的参数比较大的话甚至可能要等个几分钟。同时，在学习完深度学习的相关基础后，对这个网络结构的认知也更加清晰，他采用了4层卷积层，每两层接一个池化层，最后接两个全连接层。需要注意的是，他是将sEMG的64个通道平铺后，使用滑动窗口来构成图像的，这和我的方法不太一样。这次还仔细分析了滑动窗口是如何构造的，哪一段输入对应哪一段输出，未来可能会用到滑动窗口，可以参考。\n\n*2022.03.20*\n\n---\n\n文章首先通过CKC算法（基于生理学）识别运动单元，HD-EMG（输入）和尖峰序列（输出）用于训练CNN。然后HD-EMG被CNN实时分解为放电序列。放电序列通过求和和滤波来估计神经驱动。\n\n**两种CNN：**（a）多个单输出深度卷积神经网络SO-DCNN（一个net分解一个MU）；（b）一个多输出深度卷积神经网络MO-DCNN（一个net分解所有MU）。\n\n用CKC估计的神经驱动与用MO-DCNN估计的神经网络驱动之间存在较高的互相关系数（不同条件下的r值范围：0.88–0.95）。\n\n### 一、Introduction\n\n人类运动的控制与运动单元（MU）的激活有关，**运动单元结合了运动神经元及其所支配的肌肉纤维**。肌肉动作电位先于力的产生，导致机电（这里的机电指机械臂等被控制系统）的延迟，可以通过肌电信号预测运动意图来降低延迟。因此信号处理必须要准确快速，通常短于自主运动期间观察到的机电延迟（即225±50 ms [8]）。\n\n**神经驱动**：支配肌肉的运动神经元的输出\n\n**神经支配比率**：运动单位内神经元支配的肌肉纤维的数量（不同运动单元之间不同）\n\n**运动单元动作电位**：motor unit action potentials（**MUAPs**）\n\n**问题**—>CKC，ICA 等算法已用于识别大量的 MU，但信号扩展或白化等几个步骤增加了计算时间，不能实时估计神经驱动。\n\n**解决**—>将干扰 EMG 分解为 MU 尖峰序列的算法直接估计神经驱动。\n\n> 对表面肌电信号如何分解成MUST的相关研究已经进展为如何增加准确率和降低时间延迟。更为重要的是，如何利用MUAP的时空特性去识别MUST。由于肌电信号是随机信号，因此通常通过滑动窗口提取其特征，考虑到低延迟，本文要选取尽可能短的滑动窗口。\n>\n> 我们认为对肌肉的神经驱动是所有已识别的MU的尖峰序列的总和，也称为累积尖峰序列（CST）。为了生成CST，对单个MU尖峰序列进行求和，并用400ms的Hanning窗口进行滤波（De Luca等人，1982）。\n\n### 二、Methodology\n\n**CKC算法识别了MU的个数及尖峰序列，$y$是通过CKC算法得到的二进制序列：**\n\n![](A-convolutional-neural-network-to-identify-motor-units-from-high-density-surface-electromyography-signals-in-real-time/Untitled.png)\n\n- <font color = \"red\">上面公式中的max以及后面的公式是什么意思？</font>\n<mark>max的意思是取最大值，如果有1则是1，如果没有1则是零。这里是在步长这么大的窗口里进行取值，取出来构成输入窗口的输出</mark>\n\n- CNN的输入输出：\n  CNN的输入：one window of the HD-EMG signal (width: $M$; length: $w$)\n  CNN的输出：binary value, indicating the discharge times of a given MU\n  <font color = \"red\">[i × s - w/2, i × s + w/2]——>discharge time instance: i × s——>会造成一个w/2的延迟。</font>\n  \n- 通过F1-score来评判一个MU是否被成功识别\n<mark>结构和超参数手动优化，比较不同层数的3种网络，比较不同节点数的3种网络，本文用的CNN是效果最好的。文章使用的CNN是两个卷积层接一个池化层，然后再两个卷积层接一个池化层，最后接两个全连接层。输出层采用了sigmoid激活函数，因为值域是0-1，其他层采用了ReLU激活函数，ReLU解决了梯度消失的问题并且能够快速收敛。</mark>\n\n**For the SO-DCNN：**\n\n![image-20230913171459585](A-convolutional-neural-network-to-identify-motor-units-from-high-density-surface-electromyography-signals-in-real-time/image-20230913171459585.png)\n\nC1-C3包含128个并行核滤波器，核大小为3，用于提取时空特征。C4有64个核滤波器，用于减少完全连接层的可训练参数的数量。卷积层（FM6）的输出被平坦化为矢量，并被馈入两个完全连接的层，分别包括256个节点和1个节点。我们对输出层使用S形激活函数，对所有其他层使用整流线性单元（ReLU）激活函数。sigmoid激活函数的输出范围为0到1，这符合我们的输出要求，即二进制值。ReLU解决了消失梯度问题，加快了收敛速度。\n\n- 设计连续卷积层，允许CNN模型学习更复杂的特征。\n- 将大小为2的最大池应用于C2和C4以提取代表性特征，同时降低特征的维数。\n- 完全连接层基于特征映射做预测和分类。\n\n**For the MO-DCNN：**\n\n![image-20230913171524030](A-convolutional-neural-network-to-identify-motor-units-from-high-density-surface-electromyography-signals-in-real-time/image-20230913171524030.png)\n\n前三层结构相同，后面变为并行层。\n\n### 三、Experiment\n\n**肌肉**：腓肠肌\n\n**设备**：A two-dimensional adhesive grid of 64 electrodes was placed over the gastrocnemius medialis muscle\n\n**高密度肌电信号的仿真**：三层圆柱形容器，每层包含肌肉、脂肪、皮肤，半径分别为10mm、4mm、1mm。125664条纤维，分为150个运动单位。每个运动单元支配的纤维为52到3191不等。\n### 四、Data processing\n\n1. HD-EMG decomposition with the CKC algorithm implemented in the DEMUSE tool software\n   需要人工检查假阳或者假阴，剔除信噪比小于30dB的运动单元（该阈值确保灵敏度高于90%，假阳性率低于2%），剔除尖峰序列小于150的运动单元。（提高灵敏度降低误差）\n2. 利用所有网格中的最大幅值对信号进行-1到1的归一化（通过限制输入的幅值对学习进行加速）\n3. 并不是所有的MU都用于CNN的训练，选取了至少有150个spikes的MU用作CNN的输入\n# 文献使用了哪些方法？\n1. 滑动窗口方法：窗宽和步长的选择，<mark>要考虑窗口没有重叠和存在gap的情况。</mark>\n2. 深度CNN由四个卷积层（C1-C4）、两个完全连接层（F1和F2）、两层最大池层和一个平坦层组成。Deep CNN使用tensorflow和keras完成\n3. CKC算法使用matalb开发的DEMUSE工具软件\n4. 灵敏度和准确率：\n\n   ![image-20230914113549166](A-convolutional-neural-network-to-identify-motor-units-from-high-density-surface-electromyography-signals-in-real-time/image-20230914113549166.png)\n# 文献得到了哪些结论？\n\n- MO-DCNN 训练和预测的时间最低，但是 SO-DCNN 的准确率和灵敏度普遍较高。MO-DCNN 在训练时间（3.2-21.4 s/epoch）方面优于 SO-DCNN（6.5–47.8 s/epoch）和预测时间也同样是 MO-DCNN 更优（0.04 vs 0.27 s/sample）。MO-DCNN 的最佳窗口大小和步长分别为 120 和 20 个数据点。模拟和实验记录的 HD-EMG 信号的准确率和灵敏度分别为 98%和 85%，与 CKC 估计的神经驱动相关系数高于0.85\n\n- CKC的分解结果显示发力水平越低，识别到的MU越多（10%：22，30%：23，50%：15）\n\n- 窗口长度为20的情形下灵敏度和准确率均较低，有两个可能的原因：\n  \n  - 连续窗口的重叠部分较少\n  \n  - 连续窗口之间存在间隙\n  \n- 总的延迟（HD-EMG信号到预测放电序列）在80ms，比以前的方法快两倍，且低于人类机电延迟（from 70 to 385 ms in [8]）\n  - 提出的神经网络能够更好地识别低信噪比信号，从而减少数据段的时间\n  - 没有信号扩展、白化等额外的预处理步骤\n  \n- 窗口宽度为20个数据点时，灵敏度和准确率较低的原因可能是因为太短了不能充分捕获MUAP\n\n- HD-EMG使得潜在成分分析方法能够识别MU尖峰序列[15-17]\n\n- 神经驱动与肌纤维动作电位没有直接联系，较大MU对EMG的振幅影响较大，EMG存在干扰，EMG包含临近肌肉的信号使得解释困难\n\n- **缺点：**\n\n  - CNN严重依赖于CKC算法（由深度CNN识别的所有MU完全来自CKC算法的分解结果，不能识别新的运动单元一旦CNN确定）\n  - 时间分辨率较低，只有102Hz（步长为20时，每20个数据点产生一个输出）\n  - CKC和仿真的spikes还要降采样来匹配预测的时间分辨率\n\n- **优点：**\n\n  - 时间延迟短\n  - 使用了神经特征\n\n- 从引文中得到的结论：\n  > - 更大的MU比较小的MU产生的信号幅值更大\n  > - <font color = \"red\">神经驱动相比于表面肌电信号能够在更短的时间内准确分类人体动作：First, this direct information about neural coding enables to reach a nearly perfect classification to predict human movement with shorter segments of data than for the interference EMG.</font>\n\n# 相关论文链接：\n\n盲源分离算法利用HD-sEMG能够精确识别大量MU\n> Muceli S, Poppendieck W, Negro F, Y oshida K, Hoffmann K P , Butler J E, Gandevia S C and Farina D 2015 Accurate and representative decoding of the neural drive to muscles in\n> humans with multi-channel intramuscular thin-film electrodes J. Physiol. 593 3789–804\n\nCKC算法分解HD-EMG得到MUs\n> Holobar A and Zazula D 2007 Multichannel blind source separation using convolution kernel compensation IEEE Trans. Signal Process. 55 4487–96\n\n尖峰序列求和滤波得到神经驱动\n> De Luca C J, LeFever R S, McCue M P and Xenakis A P 1982 Behaviour of human motor units in different muscles during linearly varying contractions J. Physiol. 329 113–28\n\n","tags":["Image","JNE","Inervation"],"categories":["论文","Deep Learning"]},{"title":"The effective neural drive to muscles is the common synaptic input to motor","url":"/2023/04/19/论文/Characteristic/The-effective-neural-drive-to-muscles-is-the-common-synaptic-input-to-motor/","content":"\n这篇文章介绍了什么是对肌肉的有效驱动，重点在有效两个字，有效两个字对应的是一个带宽，该带宽通常是从DC到6-10Hz。所谓有效驱动就是这个带宽中的神经信号。而运动神经元相当于一个低通滤波器，对这个带宽内的信号进行加强，对高频信号进行衰减。运动单元的CST与突触的共同输入是高度相关的，共同输入信号相较于独立信号的信噪比越高，同时形成CST的运动单元越多（MU越多，放大倍数就越大，相当于无相位差的叠加），那么CST底通滤波后就与这个共同输入越接近。研究表明，力与神经驱动的低频部分相关。\n\n<!-- more -->\n\n# 1. 引言\n\n肌肉从其受支配的运动神经元池中接收到神经激活信号，这种神经信号是运动神经元尖峰放电活动的一个总和，被称为<mark>对肌肉的神经驱动</mark>。这种对肌肉的神经驱动是由运动神经元接收到的突触输入转变成放电序列而生成的，这种转变是一种非线性的映射关系。尽管如此，如果一个共同的成分是几个运动神经元的输入，那么这个成分将出现在每个运动神经元的输出端（与非线性成分一起），并且相对于其他成分，在对肌肉的神经驱动中会被加强。力与放电序列的公共部分高度相关，而与独立部分关系不大。\n\n# 2. 讨论\n\n对于小于运动神经元平均放电率的频率，运动神经元池决定了所有运动神经元共同的频率分量的被放大，使得共同输入几乎不失真地传输，并且非共同分量被强烈衰减。因此，运动神经元的行为类似于低通滤波器，其中高于平均放电速率的频率被衰减。例如，如果所有运动神经元以相同的频率放电，并且公共输入正弦曲线对于N个运动神经元中的每一个具有相同的幅度，则累积运动神经元输出处的公共分量相对于一个运动神经元的情况被放大N倍。<mark>运动神经元池不仅起到线性滤波器的作用（Gerstner，2000），而且有效地起到放大器的作用（信号幅度的纯缩放，没有相位失真）。</mark>\n\n我们将重点关注从DC到活动运动神经元的最小放电速率的带宽，该带宽对应于0-(6~10) Hz。在这个带宽中，公共输入是纯传输的，没有与放电速率相关的谱线，运动神经元的传递函数理论上是平坦的（纯放大或振幅缩放）。重要的是，<mark>这是力信号的大部分能量存在的带宽</mark>，因此该带宽内的神经驱动是对肌肉的有效驱动，即转化为力的驱动，而在该带宽之外的驱动被收缩肌特性过滤掉，并且对力的产生没有大的功能影响。我们将<mark>DC和最小运动神经元输出频率之间的低通带宽称为有效带宽，将该低通带宽内的运动神经元输出称为对肌肉的有效神经驱动</mark>。\n\n运动神经元的数量越大（运动神经元池），突触输入端共同成分对独立成分的信噪比越大，输出信号与公共输入的相似性就越接近（MN表示运动神经元）。这些结果可能表明，中枢神经系统有一种简单的方法来控制具有高突触噪声的非线性基本元件（运动神经元）的平稳运动。根据力水平可以分为两个区域：\n\n- 低水平力：在下图的未饱和部分，运动神经元的突触输入与输出的神经驱动之间是非线性的和有干扰的。\n- 高水平力：噪声逐渐衰减并且不会使中枢神经系统的共同输入信号失真。\n\n这两个区域之间的分隔点是渐进的，并不是某个单独的值，取决于突触输入中共同成分与独立成分之间的信噪比。这个信噪比和运动神经元的总数越大，分隔两个肌肉工作区域的相对力就越小。\n\n![image-20230514213737798](The-effective-neural-drive-to-muscles-is-the-common-synaptic-input-to-motor/image-20230514213737798.png)\n\n特定带宽在有效带宽内的公共输入在没有失真（没有相位变化）的情况下被传输到运动神经元输出，因为其所有傅立叶频率分量将以类似的增益被放大。\n\n![image-20230514212956578](The-effective-neural-drive-to-muscles-is-the-common-synaptic-input-to-motor/image-20230514212956578.png)\n\n之前的研究已经把运动单元尖峰序列的第一共同成分定义为低通滤波后尖峰序列的第一主成分，这个成分不仅是有效的神经驱动，还是一个有效的控制信号。\n\n![image-20230518205837510](The-effective-neural-drive-to-muscles-is-the-common-synaptic-input-to-motor/image-20230518205837510.png)\n\n注意，Spike Train就是指一个运动单元的放电时间，是一个点事件。<mark>CST就是所有MU的Spike Train之和</mark>\n\nCST的频谱中还包含平均放电率对应的成分，这是因为如果运动神经元有相似的募集阈值的话，他们之间的放电频率是相似。运动神经元放电率对应的范围为6Hz-（30~40)Hz，取决于收缩水平。\n\n目前的研究仅限于对肌肉的神经驱动的低频成分。这些分量是那些直接影响力产生的分量，因为更大的频率被肌肉的收缩特性有效地衰减。\n\nEEG-EMG一致性：然而，没有证据表明这种调制可能以何种特定方式发生，以及如何从较高频率的载波中提取低频信息，以便将其传输到肌肉的神经驱动\n\n# 3. 结论\n\n总之，这项研究已经证明，运动神经元的共同输入反映在运动神经元输出总和的低通带宽中，上限截止频率最高至运动神经元的最小放电率，并且需要足够（相对较小）数量的运动神经元。<mark>由于肌肉收缩的低通滤波效应</mark>，这个频率范围在功能上是最相关的。<mark>运动神经元池充当一个纯放大器</mark>，在公共输入上调谐，对于不同的公共傅立叶频率分量具有相似的增益。","tags":["CST"],"categories":["论文","Characteristic"]},{"title":"An EMG-Driven Musculoskeletal Model for Estimating Continuous Wrist Motion","url":"/2023/04/13/论文/Control/An-EMG-Driven-Musculoskeletal-Model-for-Estimating-Continuous-Wrist-Motion/","content":"\n文章使用了EMG和骨骼肌模型相结合的方法来估计手腕动作。EMG-driven并不是指代机器学习，而是通过肌肉激活程度引入。\n\n<!-- more -->\n\n# 1.笔记\n\nmodel-free和model-based：\n\n- model-free：data-driven，machine learning，black-box，不能反映神经指令和关节运动之间的关系\n- model-based：EMG-driven musculoskeletal model  \n\n也就是说，EMG-driven是需要结合骨骼肌模型的\n\n肌肉激活程度：\n$$\na_i(t)=\\dfrac{e^{Au_i(t)}-1}{e^A-1}\n$$\n\n\n\n","tags":["TNSRE","Musculoskeletal-Model","EMG-Driven"],"categories":["论文","Control"]},{"title":"关于hd-EMG分解的开源代码","url":"/2023/03/24/总结/关于hd-EMG分解的开源代码/","content":"\n**[1].** MATLAB implementation of (FAST) ICA decomposition of hd-sEMG signals to motor units:\n\n[GitHub - neuromechanist/hdEMG-Decomposition: MATLAB implementation of (FAST) ICA decomposition of hd-sEMG signals to motor units](https://github.com/neuromechanist/hdEMG-Decomposition)\n\n[hdEMG-Decomposition - File Exchange - MATLAB Central (mathworks.cn)](https://ww2.mathworks.cn/matlabcentral/fileexchange/117970-hdemg-decomposition)\n\n------\n\n\n\n**[2].**  package for decomposing multi-channel intramuscular and surface EMG signals into individual motor unit activity based off the blind source algorithm described in [`Negro et al. (2016)`](https://iopscience.iop.org/article/10.1088/1741-2560/13/2/026027/meta).\n\n[GitHub - The-Motor-Unit/EMGdecomPy: A package for decomposing multi-channel EMG signals into individual motor unit activity.](https://github.com/The-Motor-Unit/EMGdecomPy)\n\n[EMG_Decomposition - File Exchange - MATLAB Central (mathworks.cn)](https://ww2.mathworks.cn/matlabcentral/fileexchange/120083-emg_decomposition)\n\n------\n\n\n\n**[3].** Decomposing raw electromyography data into motor unit action potentials (MUAPs)\n\n[GitHub - Bayyys/EMG_Decomposition: Decomposing raw electromyography data into motor unit action potentials (MUAPs)](https://github.com/Bayyys/EMG_Decomposition)\n\n-----\n\n\n\n**[4].** Using supervised learning (Vision Transformer) to decompose HD-sEMG\n\n[GitHub - deremustapha/HD-sEMG-Decomposition: Using supervised learning (Vision Transformer) to decompose HD-sEMG](https://github.com/deremustapha/HD-sEMG-Decomposition)\n\n-----\n\n\n\n**[5].** UCLA\n\n[GitHub - shreeshkarjagi/EMG-Decomposition-Spike-Sorting-: Neuroengineering M260](https://github.com/shreeshkarjagi/EMG-Decomposition-Spike-Sorting-)\n\n","categories":["总结"]},{"title":"生理部分总结","url":"/2023/03/21/总结/生理部分总结/","content":"\n# 1. 神经-肌肉通路\n\n## 1.1 运动神经元\n\n运动神经元位于脊髓的腹角或脑干/运动皮质，在那里它接收来自神经系统其他部分的感觉和下行输入。运动神经元通常可以分为两类：\n\n- 上运动神经元：细胞体在脑干或运动皮质。它们的轴突可以直接延伸到脊髓与下运动神经元突触接触\n- 下运动神经元：细胞体在脊髓灰质，下图中紫色蝴蝶一样的部分是脊髓的灰质，灰质的腹角中汇集着运动神经元的细胞体\n\n![image-20230630100833548](生理部分总结/image-20230630100833548.png)\n\n<!--more-->\n\n在功能上，上运动神经元负责发布指令，下运动神经元负责控制肌肉和传递信息。脊髓中的运动神经元的轴突通过腹根离开脊髓，脑干中的运动神经元通过颅神经离开脑干，并在外周神经中投射到其目标肌肉及其支配的肌肉纤维。\n\n![image-20230630101851451](生理部分总结/image-20230630101851451.png)\n\n脊髓灰质腹角中的运动神经元又可以分为两类：\n\n- α运动神经元：连接梭外肌纤维，负责肌肉收缩\n- γ运动神经元：连接梭内肌纤维，保持肌梭敏感性，增益感觉神经元的反馈\n\n![image-20230630101422818](生理部分总结/image-20230630101422818.png)\n\n## 1.2 运动单位\n\n**运动单位（motor unit）**是神经肌肉系统的基本功能单位。它包括一个运动神经元（包括其树突和轴突），以及受轴突支配的肌肉纤维。每个运动神经元的轴突最终与肌肉上的肌纤维相连，运动神经与肌纤维的连接点称为神经肌肉接头。运动单元通常被认为是**最终共同通路  （final common pathway）**，因为感觉和下行输入汇聚到一个神经元的树突上，该神经元向其支配的肌肉纤维释放激活信号。\n\n一根肌纤维只接受一个α运动神经元的指令，但一个α运动神经元可以连接多个肌肉纤维。一个 MU 支配的所有肌纤维的集合称为**肌肉单位（muscle unit）**。一块肌肉上所有 MU 的集合被称为**运动神经元池（motor neuron pool）**，运动神经元池中的大多数 MU 只支配着较小的肌肉单位（肌纤维数量少），只有少数 MU 支配较大的肌肉单位，分布呈现指数分布状态。\n\n![image-20230630104219694](生理部分总结/image-20230630104219694.png)\n\n每一条运动神经元所支配的肌纤维数量与肌肉本身的大小并无实际关系，反而与肌肉运作时要达至的精确度和协调性有关。负责细致和精密工作的肌肉（如眼部肌肉），每一个运动单内可能只有一条至数条的肌纤维。反过来说，专责粗重工作的肌肉（如四头肌），每一个运动单位内就可以有数百以至数千条的肌纤维。在大部分的肌肉当中，运动单位内肌纤维的数目都有差异。 例如，某一块肌肉可能包含有25个运动单位，平均每个运动单位内有200条肌纤维，但最小的一个可能只有25条肌纤维，而最大的一个却可能有近500条肌纤维之多。\n## 1.3 动作电位\n\n运动神经元具有广泛的树突分支，可接受多达50000次突触接触，每次接触都能引发跨膜的向内或向外电流，从而产生兴奋性或抑制性突触后电位。当膜电位的变化超过电压阈值时，输入被整合，并将在触发区（轴丘）产生动作电位。运动神经元有四种主要类型的受体和离子通道，对突触输入产生反应。\n\n![image-20230630185241964](生理部分总结/image-20230630185241964.png)\n\n- 泄漏通道：无门通道（non-gated channel），一直开着，在化学力的作用下运输钠钾离子，负责形成静息电位。\n\n- 电压门通道：这些通道被膜电位的变化激活，例如膜电位升高会激活Na、K通道。\n\n- 离子突触通道：这些是配体门控受体，结合神经递质并传递产生兴奋性或抑制性突触后电位的电流。使膜电位去极化的兴奋性电流主要由谷氨酸门控受体产生，而使膜超极化的抑制性电流通常涉及甘氨酸门控受体或GABA门控受体。\n- 神经调节受体：一旦神经递质与这些受体结合，它们就会激活细胞内的第二信使通路，从而调节泄露、电压门控和离子通道。因此，神经调节受体通过调节运动神经元对离子输入的反应来控制运动神经元的兴奋性。\n\n细胞膜电势由离子在膜内外浓度差造成，浓度差和电势由钠钾离子泵维持。静息状态下细胞膜外正内负，静息电位为-70mv：\n\n- 细胞外的钠离子、氯离子、钙离子浓度高，钾离子浓度低\n- 细胞内的钾离子和负蛋白浓度高，钠离子、氯离子浓度低\n\n![image-20230630120205118](生理部分总结/image-20230630120205118.png)\n\n静息电位下，如果轴丘部分收到了一个很强的向内正电流，突如其来的细胞内的很多正电荷使得这一小块细胞膜的电位升高（比如从-70mv升到-50mv）。超过了膜上钠离子电压门通道的阈值电压，钠离子电压门通道被打开，钠离子顺着化学力和电子力冲动涌向细胞内，使得细胞内的电压更高，更多的钠离子通道被打开，从而更多的钠离子涌入，形成Hodgkin cycle正反馈循环，膜电位骤升变成正的。\n\n但是钠离子电压门通道开得快关得也快，1ms不到就关上了。相较而言，钾离子通道开得慢，开的时间长。在钠离子电压门通道关上后，钾离子电压门通道逐渐打开，钾离子顺着化学力涌向细胞外，让细胞内的电压降低，随着打开的钾离子电压门增多，更多的钾离子涌出，电压更低，直到低于钾离子电压门的阈值，这是一种负反馈。低于阈值后，打开状态下的钾离子电压门通道也被关闭，膜电位又在钠钾离子泵的作用下恢复到了平常的静息电位。\n\n![image-20230630162312165](生理部分总结/image-20230630162312165.png)\n\n神经元形成的动作电位峰值手原先的内外梨子浓度差影响，也就是说一条轴突上发送的动作电位峰值是一致的。神经元通过改变放电频率来传递不同的信息，如果刺激越强，那么神经元发送动作电位的频率也越快。但是频率不可能一直增大，因为神经元存在不应期，在不应期内，神经元是无法发放动作电位的。这也解释了电信号传递的方向性。神经元还有一个重要的结构叫做髓鞘，髓鞘是一节一节的，髓鞘包裹的部分只有泄露通道和离子泵，因此髓鞘部分产生不了动作电位，而在结节（郎飞氏结）的地方没有髓鞘包裹，有很多电压门通道，也只有在郎飞氏结的地方才能产生动作电位。髓鞘起着绝缘的作用，保证电流在到了郎飞氏结的时候还能够比阈值大。\n\n## 1.4 运动单位动作电位MUAP\n\n在人类有了行动的意向后，中枢神经系统会通过运动神经末端和它的运动终板，将电脉冲传递到神经肌肉接头处，促使神经元分泌乙酰胆碱，从而让肌细胞被激活。每一个肌纤维的激活所产生的运动电势叫做**单纤维动作电位**（Single Fiber Action Potential, SFAP）。每个运动单位全部肌肉纤维的SFAP共同构成了**运动单位动作电位**（Motor Unit Action Potential, MUAP），整个过程如下图所示。\n\n![image-20230630174226936](生理部分总结/image-20230630174226936.png)\n\n一旦运动中心下达了一条运动命令，一连串的神经元脉冲就会通过运动神经元的轴突传递到神经肌肉结合处，形成一系列MUAP，并由此构成运动单位动作电位序列（Motor Unit Action Potential Train, MUAPT）。MUAPT在皮肤上的传递会受到皮肤、脂肪等的过滤，通过电极检测到进而形成表面肌电信号。\n\n![image-20230630174832590](生理部分总结/image-20230630174832590.png)\n\n不同运动单位的动作电位形状可能不同，同时，在传输的过程中也可能存在变化。\n\n## 1.5 运动单位尖峰队列MUST\n\n相较于静息电位来说，动作电位像是一个个脉冲信号，因而叫做spike train。表面肌电信号分解最主要的目的就是得到单个运动单位的发放信息和波形信息，其中发放信息最为重要。事实上如果得到了准确的运动单位的发放信息，就不难得到其波形信息(在运动单位持续发放时间足够长的情况下)，<font color=\"red\">比如可以通过发放位置的平均波形来作为运动单位动作电位波形的估计(Spike Trigger Average,STA)。</font>FastICA输出的结果虽然不能直接被当成运动单位尖峰队列，但是它是对应于某个运动单位动作电位队列滤波后的结果，因此可以从FastICA的输出中提取出不同运动单位的发放时间信息。<font color=\"red\">比如，可以认为FastICA输出中波形的峰值位置就对应着某运动单位的发放时刻。 </font>\n\n![image-20230630184000612](生理部分总结/image-20230630184000612.png)\n\n尖峰队列是神经元的语言。人们倾向于将尖峰视为点事件，将尖峰队列视为点过程，我们用神经反应函数来描述这些：\n$$\n\\rho(t)=\\sum_{i=1}^k \\delta\\left(t-t_i\\right)\n$$\n\n## 1.6 高密度肌电卷积模型\n\n高密度肌电可以建模为如下表达式：\n$$\nx_i(n)=\\sum_{j=1}^N \\sum_{l=0}^{L-1} a_{i j}(l) t_j(n-l) ; i=1, \\ldots, M\n$$\n在这个模型中，有两个假设，第一个是假设在所有通道中，运动单位的发放时间是一致的。第二个假设便是每个运动单元在某个通道的波形，在信号持续时间段内是不变的。也就是说这是一个Shift invariant的系统。第二个假设对于肌电信号来说并不是总成立的。比如在肌肉收缩的过程中肌纤维的长度和运动单位到电极的距离都会发生变化，可能会导致动作电位的形变。因此该公式中可以引入时变的因素从而使得模型更为贴切。但是这同时也会让问题变得更加复杂。就目前的研究来说，肌电信号分解往往只考虑肌肉等长收缩(Isometric Contraction)情况，在这种情况下，肌肉组织并不发生形变，可以认为运动单元动作电位在采集过程中是保持一致的，这个模型已经能很真实地描述肌电信号的生成过程。\n\n通过FastICA、CKC等盲源分离算法，高密度表面肌电能够被分解成多个运动单元的放电序列MUST。MUST反应了运动神经元的放电时刻，从而能够对动作、肌力进行神经生理学上的分析。分解结果的示意图如下所示：\n\n![image-20230701113742016](生理部分总结/image-20230701113742016.png)","categories":["总结"]},{"title":"A Novel Myoelectric Control Scheme Supporting Synchronous Gesture Recognition and Muscle Force Estimation","url":"/2023/03/21/论文/Control/A-Novel-Myoelectric-Control-Scheme-Supporting-Synchronous-Gesture-Recognition-and-Muscle-Force-Estimation/","content":"\n这篇文章的强调点也是动作的选取，强调选取了日常生活中实用的动作。使用了MTL和Post-Processsing方法。\n\n<!-- more -->\n\n# 1. 引言\n\n肌电控制主要有三种策略：\n\n- 阈值控制\n\n- 比例控制\n\n- 模式识别控制：是一种实现多元控制的有效方法\n\n一个例子：一个肌电假手的抓取任务首先是调整手势使得形状贴合物体，然后采用合适的力抓取物体。\n\n> The early researches on myoelectric control generally focus on the realization of high-precision motion intention recognition, and most EMG pattern recognition schemes are carried out at the medium force level. A few researches that consider the motion intention and control force simultaneously appear now and then in recent years.  \n\n同步学习的一些方法：\n\n- Multivariate Bayesian hybrid expert model\n- multi-task learning based convolution neural network\n- AGrM\n\n目前存在的问题：\n\n1. 研究的动作可区分度都很高\n2. 识别率低（76.55%）。一些解决方法：time-dependent power spectral descriptors  （87.95%）\n\n传统的post-processing algorithms：\n\n- window based\n- result confidence based\n- error tolerant and control strategy optimized\n\n# 2. 实验\n\n人数：11人（11男）\n\n动作：11个\n\n电极位置：小臂屈肌部分\n\n实验曲线：\n\n- MVC\n- RFP task\n  - sinusoidal （0 - 60% MVC）：用于手势识别和力回归的训练数据获取\n  - constant (40% MVC)：用于autoencoder模型的训练\n\n- SFP task\n\n归一化：EMG使用所有通道的绝对值最大值归一化，力曲线使用MVC归一化。\n\n# 3. 方法\n\n将预处理的手势sEMG样本和相应的力包络分别输入长短期记忆（LSTM）网络和多层感知器（MLP），并通过MTL技术同步获得原始手势类别和瞬时力的结果。特别是应用了一种基于阈值方法的后处理算法，克服了力的变化对手势识别精度的影响。\n\n**MTL：**\n\n- 硬参数共享\n- 软参数共享\n\n**LSTM：** 识别动作\n\n- LSTM的输入等于电极通道的维度\n- LSTM的神经元个数取决于窗口长度\n- 每一个隐层后都有一个Relu层\n- 最后一个全连接层为softmax层\n\n**MLP（多层感知机）**：用于实时力估计（MLP 是一个由全连接层构成的多层神经网络，主要有输入层、隐藏层、和输出层）","tags":["TNSRE","Deep-Learning"],"categories":["论文","Control"]},{"title":"Physics-Informed Deep Learning for Musculoskeletal Modeling: Predicting Muscle Forces and Joint Kinematics From Surface EMG","url":"/2023/03/13/论文/Deep Learning/Physics-Informed-Deep-Learning-for-Musculoskeletal-Modeling-Predicting-Muscle-Forces-and-Joint-Kinematics-From-Surface-EMG/","content":"\n肌肉骨骼模型被广泛应用于生物力学的分析，能够很好地解释神经肌肉驱动、肌肉动力学、身体与关节运动参数之间的关联，但这种分析的效率较低，阻碍了实时的应用。数据驱动方法是一个有潜力的替代方法，拥有简单快速的优点，但不能反应深层的神经控制过程。这篇文章提出了一种用于肌肉骨骼建模的新方法：物理明确的深度学习框架，用物理域经验作为loss function的约束。实验室的设备测量的力是外部力，这篇文章提供了一种估计生物力的方法。\n\n<!-- more -->\n\n# 1. 引言\n\n肌肉骨骼模型是基于物理建模的，能够解释神经兴奋、肌肉运动以及关节参数之间的变化。通过使用一些非侵入式的信号，如EMG、GRFs、局部身体运动学等，能够估计生理属性，如肌力、关节弯矩等。然而，这些非侵入式的模型存在许多干扰，于是静态优化（包括逆运动学等）通常被用来解决这些冗余。\n\n对以上问题的一种替代解决方法是使用EMG驱动的神经-肌肉估计模型，包括：\n\n- 神经驱动的正向运动学模型\n- 静态优化元素\n\nEMG能够通过最优化关节弯矩的估计，把肌肉肌腱参数标定为独立的属性（如：肌腱松弛长度、最佳肌纤维长度）。EMG同时也改善了关节力矩的估计。尽管EMG驱动的模型克服了静态优化的局限并且已经可以实现，但是是耗时的，有着较高的延迟。\n\n为了解决高延迟，数据驱动模型（<font color=\"red\">Data-driven 和 EMG-driven 不是一个东西？</font>）被尝试着用来建立运动变量和神经肌肉状态之间的联系，比如，从 EMG 到关节运动参数和肌力。这种方法是不耗时的。一些学者的工作：\n\n- 使用LSTM通过HD-sEMG估计grasping forces\n- 使用CNN-Attention通过sEMG估计连续手指运动参数\n- 使用深度神经网络学习从运动空间到肌肉空间的映射特征\n\n同时估计肌力和关节负载/运动的工作：\n\n- RNN、CNN、全链接神经网络、主成分分析来预测估计的关节接触和肌肉力的趋势和大小\n- CNN预测ground reaction force和moments\n\n上述列举的这些工作都没有清晰的物理建模，属于“黑箱”模型。因此，为了解决physics-based和data-driven的缺点，本文提出了physics-informed deep learning musculoskeletal model framework.\n\n> Hu等人[21]利用长短期记忆（LSTM）网络来估计高密度表面肌电（sEMG）的抓取力。耿等人[22]提出了一种与注意力机制网络（CNN注意力）的卷积，用于从sEMG进行连续手指运动学预测。Rane等人[23]使用深度神经网络来学习从运动空间到肌肉空间的特征映射，因此可以从运动学预测肌肉骨骼力。[24]，[25]，[26]，[27]中也报道了类似的想法。除了单独预测肌肉力或关节运动学之外，还有一些工作可以同时预测肌肉力和关节载荷/运动。例如，Burton等人[28]实施了四种机器/深度学习方法，包括递归神经网络（RNN）、卷积神经网络（CNN）、完全连接的神经网络和主成分回归，以预测估计的关节接触和肌肉力的趋势和大小。Johnson等人[29]利用CNN预测实验室环境外的地面反作用力和力矩。\n\n# 2. 方法\n\n![image-20230314171029166](Physics-Informed-Deep-Learning-for-Musculoskeletal-Modeling-Predicting-Muscle-Forces-and-Joint-Kinematics-From-Surface-EMG/image-20230314171029166.png)\n\nCNN部分用于自动提取高阶特征，并且建立EMG信号和关节运动/肌力之间的关系。physics-informed部分用于确保关节运动和肌力之间深层的物理关系。\n\n## 2.1 CNN\n\n一个简单的CNN：\n- 一个卷积块\n  - convolutional layer（128个卷积核）\n    - 内核大小为3\n    - 边界填充为3\n    - 步长为1\n  - ReLU\n  - batchnorm\n  - dropout\n\n- 两个全连接块\n  - ReLU\n  - batchnorm\n  - dropout\n\n- 隐藏节点个数为128\n- 一个回归块\n\n在模型训练阶段，批量大小设置为1，CNN通过动量随机梯度下降训练。此外，最大迭代次数为1200，初始学习率设置为0.01，丢弃率为0.3。\n\nCNN的回归块输出得到肌力和关节运动学预测。\n\n## 2.2 Loss Functions\n\n1. MSE loss：为了最小化MSE of the ground truth and prediction\n2. physics-based loss：为了保留物理参数的限制\n\n在预测变量之间添加了深层的物理含义，构造的总的loss function：\n$$\n\\begin{aligned}\nL_{\\text {total }} & =L_F+L_\\theta+L_P \\\\\nL_F & =M S E(F) \\\\\nL_\\theta & =M S E(\\theta) \\\\\nL_P & =\\Phi(F, \\theta)\n\\end{aligned}\n$$\n其中：\n$$\n\\begin{aligned}\n& \\operatorname{MSE}(F)=\\frac{1}{T} \\sum_{t=1}^T \\sum_{n=1}^N\\left(F_t^n-\\hat{F}_t^n\\right)^2 \\\\\n& \\operatorname{MSE}(\\theta)=\\frac{1}{T} \\sum_{t=1}^T\\left(\\theta_t-\\hat{\\theta}_t\\right)^2 \\\\\n& \\Phi(F, \\theta)=\\frac{1}{T} \\sum_{t=1}^T\\left(M\\left(\\theta_t\\right) \\ddot{\\theta}_t+C\\left(\\theta_t, \\dot{\\theta}_t\\right)+G\\left(\\theta_t\\right)-\\tau_t\\right)^2\n\\end{aligned}\n$$\n将实验数据导入OpenSim，以缩放每个受试者的通用肌肉骨骼模型[34]。分别通过逆运动学（IK）和逆动力学（ID）工具计算关节运动学和关节扭矩。使用计算肌肉控制（CMC）工具计算肌肉力，以确保肌肉激活遵循测量的EMG\n\n选择膝盖关节作为关节角度和肌力的估计对象，`股二头肌短头`和`股直肌`分别作为屈肌和伸肌\n\n<font color=\"red\">什么是重采样？为什么要进行重采样？</font>\n\nOpenSim有三个工具：\n\n- IK：通过marker的数据能够得到手腕运动学参数\n- ID：得到关节力矩\n- CMC：得到手腕肌力\n\n## 2.3 ANOVA\n\n一区的文章一般都加入了ANOVA分析，能够更有说服力，考虑在文章中加入这部分内容以丰富discussion。\n\n# 3. 实验\n\n被试：6人\n\n两个task：手腕收缩和伸张。每个task重复6次\n\n在实验中，受试者的肩膀保持90°竖直和肘关节保持90°弯曲。\n\n# 4. 结果\n\n深度学习（CNN-based、ML-ELM）的比机器学习（SVR、ELM）的效果，因为深度学习能够自动提取更高阶的特征。本文提出的物理规律嵌入式架构可以修正CNN，因而达到了最好的预测效果。同时，由于CNN网络较简单，本文框架的性能也与复杂的纯CNN相近。\n\n<mark>注意intrasession和intersession的区分。</mark>\n\n本文提出的方法在不同速度的混合数据集、受试泛化能力、数据集规模、相同结构的CNN下都取得了更好的效果。本文对CNN的结构作了进一步研究，发现PINN-3型结构有着最好的效果。\n\n> 除了CNN之外，当我们想要从运动学测量中提取空间和时间表示时，数据驱动组件中的深度神经网络可以被CNN+LSTM替代[41]，或者当需要独立于领域的特征时，可以被生成对抗网络（GAN）替代[42]。此外，当只有少数训练数据可用时，应考虑few-shot学习[43]，或者在解决数据隐私问题时，首选联合学习[44]。我们还可以将希尔肌肉模型纳入所提出的框架中，预测的力应该等于希尔肌肉模型预测，这可以用作网络中的第二物理定律。","tags":["TNSRE","Deep-Learning","Musculoskeletal-Model"],"categories":["论文","Deep Learning"]},{"title":"马氏距离","url":"/2023/03/09/数学/马氏距离/","content":"\n参考链接：[马氏距离(Mahalanobis Distance) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/46626607)\n\n马氏距离（Mahalanobis distance）是一种用于计算两个样本点之间距离的方法。它考虑了各个特征之间的相关性，与欧氏距离不同，马氏距离可以反映出各个特征之间的协方差关系。\n\n在多元统计分析中，马氏距离常用于评估多个变量之间的相似性或差异性，特别适用于数据集中存在多个相关特征的情况。马氏距离是欧氏距离的一种推广形式(当多维随机变量之间是独立同分布的，那么它们之间的协方差矩阵就是单位矩阵)，可以用来衡量样本点与所在样本总体之间的距离。\n\n具体地，假设有两个样本点 $x$ 和 $y$，它们各自有 $p$ 个特征（即 $x$ 和 $y$ 分别为 $p$ 维向量），那么它们之间的马氏距离为：\n\n$$\nd_{M}(x,y)=\\sqrt{(x-y)^{T} S^{-1} (x-y)}\n$$\n其中，$S$ 是样本协方差矩阵，可以通过样本数据估计得到。马氏距离具有对称性和非负性，且满足三角不等式，因此可以作为距离度量来进行聚类、分类等任务。","categories":["数学"]},{"title":"线性最小均方误差估计","url":"/2023/03/05/数学/线性最小均方误差估计/","content":"\n参考链接：[LMMSE - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388508562)\n\n参考书籍：《统计信号处理基础》\n\nLMMSE（Linear Minimum Mean Squared Error）是一种信号处理方法，用于对输入信号进行估计或恢复。LMMSE方法基于线性估计器，通过最小化误差均方差的方式对信号进行估计。\n\n在信号处理领域，LMMSE方法常用于恢复被加噪声或失真的信号。假设有一个被噪声污染的信号 $y$，我们希望得到它的无噪声版本 $x$。假设 $y$ 和 $x$ 之间存在线性关系，即：$y=Hx+n$。其中，$H$ 是一个已知的线性变换矩阵，$n$ 是加性高斯噪声。我们可以使用LMMSE方法来估计$x$。\n\nLMMSE方法的基本思想是，首先利用信号和噪声的统计特性，构造一个最小均方误差准则函数，然后通过对准则函数求导的方式，求得最小误差下的估计器。对于上述的线性模型，LMMSE估计器的形式为：\n$$\n\\hat{x}=E{x|y}=x+E{H^{T}(HH^{T}+\\sigma_{n}^{2}I)^{-1}(y-Hx)}​\n$$\n其中，$\\sigma_n^2$  是噪声方差，$E{x|y}$ 表示在已知 $y$ 的情况下对 $x$ 的最小均方误差估计值，即后验均值估计。\n\nLMMSE方法具有良好的性能和广泛的应用，尤其在通信系统、图像处理、音频处理等领域得到了广泛应用。","categories":["数学"]},{"title":"统计信号处理","url":"/2023/03/05/数学/统计信号处理/","content":"\n生物信号、语音信号、雷达信号等随机信号具有易变性，因此通常使用属性而不是波形自身来度量，因为属性对变化的敏感度较低。\n\n参考书籍：《Fundamentals of statistical signal processing: Estimation theory》\n\n<!-- more -->\n\n# Chapter 1 无偏估计\n\n无偏估计值估计量的期望等于真实值：\n$$\nE(\\hat{\\theta})=\\theta\n$$\n与无偏估计相对应的是有偏估计，无偏估计并不一定是好的估计，只代表估计量的期望等于真值。\n\n# Chapter 12 线性贝叶斯估计量\n\n保留MMSE准则，但是限定估计量是线性的。\n\n线性估计量的形式：\n$$\n\\hat{\\theta}=\\sum_{n=0}^{N-1} a_n x[n]+a_N\n$$\n选择加权系数 $a_n$来使贝叶斯 MSE 最小。贝叶斯 MSE：\n$$\n\\operatorname{Bmse}(\\hat{\\theta})=E\\left[(\\theta-\\hat{\\theta})^2\\right]\n$$\n导出的估计量称为线性最小均方误差(LMMSE)估计量.\n\n---\n\n**一个例子帮助理解：**\n\n考虑一个参数θ，它根据单一数据 $x[0]$ 来估计, 其中 $x[0] \\sim \\mathcal{N}\\left(0, \\sigma^2\\right)$ 。如果待估计的参数是 $x[0]$ 现实的功率, 即 $\\theta=x^2[0]$，那么理想的估计量是：\n$$\n\\hat{\\theta}=x^2[0]\n$$\n因为最小贝叶斯 MSE 将等于零。很显然这个估计量是非线性的。然而, 如果我们试图应用 LMMSE 估计量, 即：\n$$\n\\hat{\\theta}=a_0 x[0]+a_1\n$$\n那么最佳加权系数 $a_0$ 和 $a_1$ 可以通过使：\n$$\n\\operatorname{Bmse}(\\hat{\\theta})=E\\left[(\\theta-\\hat{\\theta})^2\\right]=E\\left[\\left(\\theta-a_0 x[0]-a_1\\right)^2\\right]\n$$\n最小而求出。\n\n---\n\n**几何意义：**\n\n矢量长度的定义：对于一个零均值的变量来说，它的长度定义为方差的平方根（$\\|x\\|=\\sqrt{E\\left(x^2\\right)}$），方差越大矢量长度越长。\n\n如果两个矢量是正交的，那么我们不能用其中的一个来估计另一个参数，因为在x方向没有y的分量，所以我们可以只考虑投影带来的关系。\n\nLMMSE 估计量：\n$$\\hat{\\theta}=\\sum_{n=0}^{N-1} a_n x[n]$$\n\n优化目标：\n$$E\\left[(\\theta-\\hat{\\theta})^2\\right]=E\\left[\\left(\\theta-\\sum_{n=0}^{N-1} a_n x[n]\\right)^2\\right]=\\left\\|\\theta-\\sum_{n=0}^{N-1} a_n x[n]\\right\\|^2$$ \nθ与估计量 $\\hat{\\theta}$ 之差的期望与所有 $x[n]$ 张成的向量垂直，最终估计量 $\\hat{\\theta}$是$\\theta$在$x[n]$张成的轴上的投影的和。e.g. $\\hat{\\theta}=\\hat{\\theta}_0+\\hat{\\theta}_1$\n\n![](统计信号处理/image-20230308215313896.png)","categories":["数学"]},{"title":"随机信号","url":"/2023/03/05/数学/随机信号/","content":"\n# 1. 随机变量\n\n随机变量的每一个随机事件映射到实数轴上是<mark>一个</mark>实数。\n\n## 1.1 概率分布函数和概率密度函数\n\n**概率分布函数：** 随机变量的概率分布函数 ( probability distribution function) $P_X(x)$ 是所观察的该随机变量 $X$ 小于或等于数值 $x$ 这一事件的概率。它是随机变量所取数值 $x$ 的函数, 即：\n$$\nP_X(x)=P\\{X \\leqslant x\\}\n$$\n\n<!-- more -->\n\n**概率密度函数：** 随机变量概率密度函数 $p_X(x)$ 是概率分布函数 $P_X(x)$ 的导数, 即：\n$$\np_X(x)=\\frac{\\mathrm{d} P_X(x)}{\\mathrm{d} x}\n$$\n\n## 1.2 随机变量的数字特征\n\n- 数学期望\n  - 原点矩\n  - 中心矩\n\n- 特征函数\n\n## 1.3 常见的概率分布\n\n1. 高斯分布（正态分布）\n2. 瑞利分布\n3. 麦克斯韦分布\n4. 均匀分布\n5. 二项分布\n\n# 2. 随机过程\n\n**随机信号**：随机信号也叫做随机过程。带有信息的信号往往都具有不可预知的不确定性，这样的信号叫做随机信号。随机信号在出现之前，检测者无法预知；一旦出现以后，它却是某一个确定的时间函数。其随机性来自于两个方面：\n\n- 待测信号本身的不确定性：当这个信号终于以某种确定形式出现了，接收者才从中获取了所需要的信息\n- 外界的干扰信号或各种噪声\n\n与随机变量的区别：每一个随机信号都是一个随机事件，不过相比于抛硬币正反面这类随机事件，随机信号的每一个事件<mark>不能表示成一个实数</mark>，而是<mark>一个随时间变化的的函数</mark>。<font color = \"red\">随机过程的样本是一个个时间函数,它们的出现与否存在着不确定性。</font>\n\n**随机信号的一些例子**：电话中的语音信号、雷达信号、肌电信号等等。\n\n**随机过程的统计特征**：\n\n- 单个时间点：平均值、方差\n- 多个时间点：相关、协方差\n\n随机过程的概率密度函数和概率分布函数都可能随时间变化，因此随机过程在不同时刻的平均值和方差等统计量都可能不同。\n\n**随机过程分为**：\n\n- 平稳随机过程：统计量（或概率密度函数）与时间的起点无关\n- 非平稳随机过程：统计量（或概率密度函数）与时间的起点相关\n\n**各态历经性**：随机过程的统计平均等于其样本的时间平均，也就是每个样本的时间平均和自相关函数都相等。\n\n> 随机过程的每一个样本是一个与时间相关的函数，单个样本的时间平均值（或自相关函数）是一个定值，但多个样本在一起，这个时间平均值就变成了一个随机变量，而随机过程的统计平均就是对这个随机变量求期望。\n\n各台历经需要的条件：\n\n1. 随机过程的样本空间中各个样本的时间平均值必须相同\n2. 随机过程必须是平稳的\n\n随机信号的时频域分析：[第五章 信号处理与分析(非平稳信号) - 豆丁网 (docin.com)](https://www.docin.com/p-1628817820.html)","categories":["数学"]},{"title":"A Novel Muscle Innervation Zone Estimation Method Using Monopolar High Density Surface Electromyography","url":"/2023/02/28/论文/Decomposition/A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/","content":"\n这篇文章提出了一种方法能够从HD-EMG中估计神经区域。第二主成分与各通道的时间延迟线性相关，在IZ（innervation zone）附近的通道有最短的时间延迟。当噪声在各个通道独立分布时，这种方法使用单极信号达到了与互相关分析方法使用双极信号相同的效果。但在模拟的特殊通道污染中，基于PCA的方法相比于互相关分析达到了更好的效果。在实验数据中，这两种方法也高度一致。\n\n<!-- more -->\n\n# 1. 引言\n\n神经支配区域指神经末梢与肌肉纤维相接触的地方，通常位于肌纤维中点处的<mark>狭长一带（垂直于肌纤维）</mark>，MUAP从IZ往两个方向传播分别到达肌腱。\n\n- 传统的IZ估计方法通常是基于EMG的幅值、频率和互相关分析的，使用的算法有optical flow technique、robust linear analysis、 randon reansform、graph-cut segmentation。\n\nPCA方法通常用于改善通过单极EMG对力的估计，或者从单极EMG识别肌肉的初始激活。Laguna等人证明第二主成分系数与不同通道的时间延迟是成比例的：\n$$\n\\boldsymbol{\\psi} \\approx \\beta \\boldsymbol{\\theta}\n$$\n\n# 2. 方法\n\nPCA将M通道的EMG投影成M个不相关的成分：$$ S=W^T X $$（X是原始信号）。系数矩阵W（M×M）的每一列都包含所有M个通道与对应主分量的相关系数（可以理解为对主成分的贡献），这些列按照分量方差的降序排列（第一主成分对应的方差最大，其对应的向量是所有样本点在第一坐标轴上的投影，排在第一列）。\n\n<img title=\"\" src=\"A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/image-20230312153203298.png\" alt=\"image-20230312153203298\" data-align=\"left\">\n\n这篇文章把表面肌电信号建模为某一未知确定信号的延迟：\n$$\nx_i(t)=s\\left(t-\\theta_i\\right)+v_i(t), \\quad i=1, \\ldots, M\n$$\n对于小的时间延迟，考虑泰勒展开：\n$$\n\\boldsymbol{x}(t) \\approx s(t) \\mathbf{1}-s^{\\prime}(t) \\boldsymbol{\\theta}+\\frac{1}{2} s^{\\prime \\prime}(t) \\boldsymbol{\\theta}^2+\\boldsymbol{v}(t)\n$$\n第二主成分跟通道时间延迟向量是正相关的，通过第二主成分与通道延迟向量之间的关系，一旦我们通过PCA主成分分析观测信号得到第二主成分，那么就能够得到通道延迟向量，从而确定IZ位置（靠近IZ的通道时间延迟更短）。尽管$\\beta$在本文中没有导出，但可以根据各列的系数的导数估计IZ。\n\n# 3. 仿真验证\n\n- 模拟了120个运动单元，支配70000个肌肉纤维\n- 募集阈值建模为指数，大多数运动单元在低兴奋状态下就可以激活，少数运动单元有较高的阈值\n- 一旦达到募集阈值，运动单元开始以8Hz频率放电\n- 最后一个运动单元在40%MVC时激活\n- “onion skin”发放原则：后募集的大运动单元峰值发放频率低于先募集的小的运动单元\n- 最大运动单元的峰值发放频率为25Hz，最小运动单元的峰值发放频率为35Hz\n- 发放间隔建模为符合高斯概率分布函数的随机过程\n- tripole model 用于仿真MUAP\n- 电极阵列的列与肌肉纤维平行\n\n# 4. 实验验证\n\n- 人数：9人\n- 肌肉：肱二头肌\n- 实验设备：意大利OT\n\n![image-20230312170951763](A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/image-20230312170951763.png)\n\n# 5. 数据处理\n\n1. 数据标准化：0均值、单位方差\n\n2. 使用三次样条插值用于确定IZ位置,通过3次样条找的最低点\n\n3. 仿真数据分析：将PCA得到的IZ和预先设定的IZ做对比；将PCA得到的IZ和互相关、RMS幅值通过双极信号估计的IZ做对比\n   \n   实验数据分析：将PCA得到的IZ和互相关、RMS幅值通过双极信号估计的IZ做对比\n\n4. RMS判断IZ的方法通过两行相减得出\n   \n   > The IZ was identified as at row(i+1) if row(i)-row(i+2) had the smallest value.  The IZ location was identified at between row(i) and row(i+1) if row(i)-row(i+1) had the minimum value.  \n\n# 6. 实验结果\n\n第二主成分的系数可以表示出神经支配区域，通过三次样条插值能够找出最低点以验证：\n\n1.位于两个通道之间的：\n\n![image-20230312200223631](A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/image-20230312200223631.png)\n\n2.位于单个通道上：\n\n![image-20230312200438103](A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/image-20230312200438103.png)\n\n不同方法间的对比：\n![image-20230312201221393](A-Novel-Muscle-Innervation-Zone-Estimation-Method-Using-Monopolar-High-Density-Surface-Electromyography/image-20230312201221393.png)\n\n# 7. 结论\n\n基于PCA的方法对噪声更不敏感。以前的方法大多是根据双极电极来判断IZ的，基于PCA的方法使得能够通过单极的EMG信号判断IZ，并与互相关分析高度一致。\n\n# 8. 疑问\n\n- 如何使用互相关、RMS来确定神经支配区域","tags":["PCA","TNSRE","Inervation"],"categories":["论文","Decomposition"]},{"title":"实验平台搭建教程","url":"/2023/02/28/实验/实验平台搭建教程/","content":"本教程旨在对实验室 delsys 实验系统进行详细的阐述，方便同学进行实验。\n\n<!-- more -->\n# 上位机环境配置\n上位机代码仓库：[CQ-yangxh/QtSampling (github.com)](https://github.com/CQ-yangxh/QtSampling)\n\n1、上位机使用Qt进行开发，目前使用的是Qt5版本，Qt6版本对qcustomplt库的支持存在问题，建议安装Qt5版本，安装器链接：[Index of /archive (qt.io)](https://download.qt.io/archive/)（本博客安装的是Qt 5.12，代码原版本是5.15.2，推荐安装5.15.2）\n\n2、安装时一定要选择如下组件：\n![image-20230228160514050](实验平台搭建教程/image-20230228160514050.png)\n\n3、安装好后需要<font color='red'>安装USB3102A数据采集卡驱动</font>，直接安装App中的setup.exe即可：\n![image-20230228160641016](实验平台搭建教程/image-20230228160641016.png)\n\n4、Qt中的项目配置：\n- 首先打开test文件夹中的test.pro \n- 构建设置取消掉 shadow build\n![image-20230228160953440](实验平台搭建教程/image-20230228160953440.png)\n- 构建套件一定要选择32位，因为数据采集卡驱动也是32位编译的\n![image-20230228161046431](实验平台搭建教程/image-20230228161046431.png)\n- 然后直接debug（如果没有安装驱动是不能运行的）\n![image-20230228161122808](实验平台搭建教程/image-20230228161122808.png)\n\n# EMGworks Acquisition \n- 视频教程链接：[EMG data collection - YouTube](https://www.youtube.com/watch?v=iFx-Fd3RZ2I)\n- 用户手册：[EMGworks® Product Support - Delsys](https://delsys.com/support/emgworks/)\n\n1. 新建一个test\n![image-20230228162354433](实验平台搭建教程/image-20230228162354433.png)\n\n2. 连接肌电设备到电脑，点击Hardware选择相应的设备：\n![image-20230228163115911](实验平台搭建教程/image-20230228163115911.png)\n\n3. 拖拽无线肌电传感器到相应的肌肉位置处：\n![image-20230228163239903](实验平台搭建教程/image-20230228163239903.png)\n\n4. 添加数据处理流程，这里选择了绘制和存储：\n![image-20230228163305855](实验平台搭建教程/image-20230228163305855.png)\n\n5. 点击start开始测试：\n![image-20230228163343655](实验平台搭建教程/image-20230228163343655.png)\n\n## 注意：\n- 传感器一定要配对后才能使用\n\n  ![image-20230228164338222](实验平台搭建教程/image-20230228164338222.png)","categories":["实验"]},{"title":"Gradient Convolution Kernel Compensation Applied to Surface Electromyograms","url":"/2023/01/19/论文/Decomposition/Gradient-Convolution-Kernel-Compensation-Applied-to-Surface-Electromyograms/","content":"gCKC算法首先估计第j个MU与各个通道之间的相关向量：\n$$\n\\mathbf{c}_{t_j\\mathbf{x}}=E(t_j(n)\\mathbf{x}(n))\n$$\n但是由于事先不知道发放序列，因此需要首先对这个相关向量做一个初始化：\n$$\n\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}=\\mathbf{x}(n_i)\n$$\n---\n\n*2024/1/7*\n$$\n\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}=\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}-\\eta(k)\\sum_m\\frac{\\partial f(\\hat{t}_j(m))}{\\partial\\hat{t}_j(m)}\\mathbf{x}(m)\n$$\n这个公式实际上就是在把每个时刻的相关向量加起来，通过把损失函数的导数设置为凹函数，使得高脉冲的时刻被不断加强。因此可以在求和除以一个采样总点数，这样得到的向量就与前面的相关向量c一致，而不需要在学习率里面体现这个倍数关系了。\n\n<!-- more -->\n\n这里的ni代表至少有一个MU发放的时刻。这里相关向量的更新的理解是这样的，它的梯度是m时刻观测向量和该时刻spike偏导数的乘积。假设m时刻存在MU发放，那么迭代过程就是那些存在发放的时刻的观测向量会被加强，然后导致spike会不断增高，当增高到一定程度后，发放时刻就较为确定，相关向量内部的相对变化就不再明显，体现为分离向量收敛。如果MU没有在m时刻发放，那么它的的观测向量值应该很小，导致乘积就很小，所以在迭代的过程中会被压下去。\n\n<mark>值得注意的是，基于梯度的更新需要至少10秒长的信号来收敛。</mark>\n\n- 在第一步中，对未知的混合通道（卷积核）进行补偿\n- 在第二步中，使用自然梯度算法对估计的源脉冲序列进行盲优化\n\n注意在卷积模型的表达中，有两种形式，一种是对观测矩阵进行了扩展的，另一种是没有对观测矩阵进行扩展的。\n\n- 第一种：\n\n$$\n\\mathbf{x}\\left(n\\right)=\\mathbf{H}\\bar{\\mathbf{t}}\\left(n\\right)+\\omega\\left(n\\right)\n$$\n\n$$\n\\bar{\\mathbf{t}}\\left(n\\right)=\\left[t_{1}\\left(n\\right),t_{1}\\left(n-1\\right),...,t_{1}\\left(n-L+1\\right),...,t_{N}\\left(n\\right),...,t_N\\left(n-L+1\\right)]^T\\right. \n$$\n\n- 第二种：\n\n$$\n\\overline{\\mathbf{y}}(n)=\\mathbf{A}\\overline{\\mathbf{t}}(n)+\\overline{\\boldsymbol{\\omega}}(n)\n$$\n\n$$\n\\begin{aligned}\\bar{\\mathbf{t}}(n)=[t_1(n),t_1(n-1),\\ldots,t_1(n-L-K+2),\\ldots,\\\\t_N(n),\\ldots,t_N(n-L-K+2)]^T\\end{aligned}\n$$\n\n代价函数选择参考文献《Non-invasive characterization of motor unit behaviour in pathological tremor》：\n$$\nF(t) = 2\\cdot atan(t)-2\\cdot t+t\\cdot\\log(1+t^2)\n$$\n\n","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"Deep transfer learning compared to subject-specific models for sEMG decoders","url":"/2023/01/15/论文/Deep Learning/Deep-transfer-learning-compared-to-subject-specific-models-for-sEMG-decoders/","content":"\nEMG具有很高的受试者间变异性。这篇文章的目标是研究当只有有限数量的训练数据可用时，为新用户校准深度学习模型的方法。这是特定受试者建模和迁移学习的首次比较。文章比较了不同条件下的特定受试者模型、预训练再微调模型。本文的目标是深入了解在何种情况下基于迁移学习的sEMG分类器用户校准表现良好的问题。\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1研究目标\n\n文献使用了两种方法：\n\n1. 特定受试者模型\n2. 迁移学习\n\n这篇文章研究了权重初始化对两个不同的预训练深度学习模型在新的受试者数据上进行重新校准的迁移学习的有效性，并将其性能与受试者特定模型进行了比较。一般来说，基于机器学习的sEMG解码器因此必须针对每个新对象进行校准。大多数现有的sEMG解码器研究都是基于单个受试者对数据进行训练和评估，这在本文中称为`特定受试者建模型`。迄今为止，研究文献中特定受试者模型仅与特定受试者模型进行了比较，迁移学习模型仅与迁移学习模型进行了对比。然而，有必要了解两种建模方法在数据需求、训练时间和准确性方面的相互比较。\n\n**受试者间变异性**：电极放置、疲劳、热量、皮肤脂肪比和性别等其他因素也会影响 sEMG 测量的受试者间和受试者内方差。\n\n最近，一些工作使用`few shot learning`、`具有递归神经网络的自适应层`和`卷积神经网络（CNN）上的自适应批处理归一化`来解决人际差异的问题。\n\n## 1.2研究方法\n\n通常，迁移学习表示一种机器学习应用，能够将在一种情况下学习的知识转移到不同但<mark>相关的情况</mark>上。所述的<mark>相关的情况</mark>可能是稍微不同的输出任务、输入表示、输入和输出之间的映射或数据生成过程。在我们的案例中，我们希望使用迁移学习来对来自一个新的、看不见的受试的数据进行分类。任务和输入保持不变，但由于sEMG信号的人际变异性，预计每个受试者之间的输入特征和输入-输出的映射的不同。\n\n# 2.结论\n\n- 在所有设置中，本文的迁移学习方法在没有微调的预训练模型上平均提高了5%，在特定受试者模型上提高了12%，同时平均减少了22%的训练时间。我们的结果表明，与特定受试者模型相比，迁移学习能够在更少的训练样本上实现更快的学习。\n\n> 在之前发表的研究中，<mark>深度神经网络</mark>显示了sEMG信号的有希望的分类精度，并优于传统的统计和机器学习模型，尤其是在人工特征工程更少的复杂分类任务中。","tags":["Deep-Learning"],"categories":["论文","Deep Learning"]},{"title":"Central nervous system modulates the neuromechanical delay in a broad range for the control of muscle force","url":"/2023/01/14/论文/Characteristic/Central-nervous-system-modulates-the-neuromechanical-delay-in-a-broad-range-for-the-control-of-muscle-force/","content":"\n这篇文章提出了一种精确测量神经驱动到肌肉力之间延迟的方法，把这种延迟成为neuromechanical delay (NMD)  。\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1研究目标\n\n由于运动神经元的动态敏感性以及肌纤维去极化后拉伸肌腱单元的系列弹性组件（SEC）所需的时间，神经编码向力的转换具有延迟。神经机械延迟（NMD）定义为在可变力的自愿收缩过程中，神经对肌肉的驱动和力量之间的延迟。<mark>为了计算神经驱动和力之间的延迟，将带通滤波器（带宽：2Hz）应用于CST和力信号（四阶零相位巴特沃斯滤波器）。滤波后，将CST和力信号分为一个周期时间帧，并计算每个时间帧的CST和作用力之间的互相关，然后在所有时间帧上取平均值。互相关函数峰值的时滞提供了NMD的估计。</mark>\n\nNMD和EMD之间的区别：\n\n- NMD是在具有任何<mark>力变化率</mark>的任务期间神经驱动和力之间的延迟。\n- EMD估计值由<mark>表面EMG</mark>信号开始与力开始之间的时间差获得。\n\n## 1.2实验设置\n\n**人数：**`8男`\n\n**Two sessions：**`2 seperated day`\n\n**MVC：**`3 contraction`\n\n**Trials：**`3 frequencies` and `3 amplitude`，9 trials in all combination, 3 mins left for recovery between two trials\n\n**EMG设备：**`OT Bioelettronica, Torino`\n\n## 1.3数据处理\n\n**HD-EMG带通滤波：**`20-500Hz，2阶巴特沃斯滤波器`\n\n**MU剔除：**`＜30 dB的MU`or`存在间隔＞2s的MU`\n\n**ANOVA：**`评估计算的NMD和力精度`\n\n**回归：**`线性和非线性模型用于对NMD和DR关于力倒数的回归`\n\n**NMD的计算方法：**`CST和力信号之间的互相关系数，相关度最大处的时间代表延迟`\n\n![image-20230115160944311](Central-nervous-system-modulates-the-neuromechanical-delay-in-a-broad-range-for-the-control-of-muscle-force/image-20230115160944311.png)\n\n**A and a**：MUST 和 force\n\n**B and b**：力信号和以及对 A 和 a 中的运动单元放电序列进行低通滤波（2Hz），以产生运动单元的平滑放电率。（<font color='red'>为什么对 MUST 进行低通滤波就得到 smoothed discharge rate？</font>）\n\n**C and c**：将单个运动单元放电序列求和以生成累积尖峰序列（CST）（<font color='red'>求和的时候有些时刻会有多个 MU 同时放电，这个时候的求和是代数求和还是只用1表示这个时刻存在放电就行</font>）。求和后，用2Hz 低通滤波器对 CST 进行滤波。\n\n# 2.结论\n\n- 频率或振幅的增加导致了NMD的降低，最短的NMD对应于最高的目标频率和峰峰值：\n\n  ![image-20230115161943801](Central-nervous-system-modulates-the-neuromechanical-delay-in-a-broad-range-for-the-control-of-muscle-force/image-20230115161943801.png)\n\n- 神经对肌肉的驱动（MUST）到力的产生之间的延迟大约在200ms左右，由中枢神经系统根据收缩速度进行调节。NMD本质上与运动单元抽动特性相关，因此可以根据尺寸原理进行调节。\n\n- NMD取决于运动神经元的动态敏感性（1）和肌肉腱系统的固有特性，因此中枢神经系统只能通过改变肌肉单位的激活来调节NMD。\n\n- 放电率和力的导数之间的关系：（运动单元池的所有放电脉冲总和，除以运动单元数再除以时间）\n\n  ![image-20230115164156913](Central-nervous-system-modulates-the-neuromechanical-delay-in-a-broad-range-for-the-control-of-muscle-force/image-20230115164156913.png)\n\n- 手部肌肉和腿部肌肉的NMD差异很大\n\n> - 运动单元的募集阈值取决于力的改变速度，NMD越短，收缩越快\n> - 运动神经元的募集取决于它们接受的净兴奋性输入\n\n# 3.问题\n\n1. 如何通过低通滤波得到smoothed discharge rate\n2. CST的求和过程中重叠的脉冲该怎么处理\n3. 如何对CST进行滤波得到对力的近似估计","tags":["CST"],"categories":["论文","Characteristic"]},{"title":"Open Access Dataset Toolbox and Benchmark Processing Results of High-Density Surface Electromyogram Recordings","url":"/2023/01/09/数据库/Open-Access-Dataset-Toolbox-and-Benchmark-Processing-Results-of-High-Density-Surface-Electromyogram-Recordings/","content":"\n- 放电频率的计算\n\n  计算每个相邻19.5ms窗口（40个采样点）中每个MU的尖峰序列的发放频率。然后用8阶10Hz低通巴特沃斯滤波器对该激发频率进行滤波。<font color='red'>(MU的发放间隔一般在20-200ms之间，这里只间隔19.5ms，那最多只能有一个发放时刻，这个窗口的选取意义是什么？)</font>\n\n- SIL的含义\n\n  分解MUs的平均SIL。SIL度量MUST与噪声（背景噪声和其他潜在源信号）的分离程度。较高的平均SIL代表较好的分解性能。","categories":["数据库"]},{"title":"杂记","url":"/2023/01/07/总结/杂记/","content":"\nMotor units with a pulse-to-noise ratio ([13](https://journals.physiology.org/doi/full/10.1152/japplphysiol.00135.2018#B14)) <30 dB and/or with discharges separated by >2 s were discarded from further analysis. The individual motor unit discharge timings were summed to generate a cumulative spike train (CST). \n\n力的大小主要通过两种途径改变：\n\n- 运动单元的放电频率：运动单元的放电频率越高，产生的力越大 \n- 运动单元的募集数量：募集的运动单元数量越多，产生的力越大\n","categories":["总结"]},{"title":"Cumulative Spike Train Outperforms the Root-Mean-Square Metric in Muscle Excitation Estimation from Dynamic High-Density EMG","url":"/2023/01/07/论文/Characteristic/Cumulative-Spike-Train-Outperforms-the-Root-Mean-Square-Metric-in-Muscle-Excitation-Estimation-from-Dynamic-High-Density-EMG/","content":"\n通过这篇文章了解CST的性质和计算方法。cumulative MU spike trains (CST) were calculated using 5, 10 and 15 identified MUs 。5、10、15个MU计算的CST比NRMSE的性能好~4、5、6%。\n\n<!-- more -->\n\n# 1 笔记 \n\n## 1.1 引言\n\n更先进的肌肉激励技术建立在通过分解hdEMG信号直接识别MU尖峰序列的基础上。这些技术将MUAP与兴奋模式完全分离，但在很大程度上仅对等长肌肉收缩进行了测试。没有详细研究动态条件，主要是因为缺乏可靠的动态hdEMG分解技术。最近，引入了循环平稳卷积核补偿（csCKC）技术，用于识别动态肌肉收缩中的MU尖峰序列。在这项研究中，我们系统地量化了等距和动态条件下基于RMS的肌肉兴奋估计的误差，并将其与基于csCKC的累积尖峰训练（CST）估计的性能进行了比较。为此，我们使用了合成的hdEMG信号，该信号具有已知的肌肉兴奋和曲线，并且使用了从肱二头肌实验估计的MUAP。\n\n>Afterwards, 5, 10 and 15 remaining MUs were randomly selected and used to calculate three different CSTs [2]. Similarly, reference CST was calculated by summing up the spike trains of all the simulated MUs. In order to cut-off the high frequency noise, all the CSTs <mark>were convolved by 0.25 s long rectangular window</mark>.  \n\n上面这句话阐述了如何对CST进行低通滤波。这里选用的是250ms的矩形窗（对应采样率2048Hz）。文献《Behaviour of human motor units in different muscles during linearly varying contractions》采用的是400ms海宁窗。\n\n## 1.2 实验设置\n\n**被试人数**：5人\n\n**高密度电极**：13 * 5 （OT）\n\n**EMG 采样率**：2048\n\n**EMG 滤波**：20-700Hz\n\n## 1.3 HD-EMG分解\n\ncsCKC分解，PNR低于30dB的MU丢弃。\n\n\n\n","tags":["CST"],"categories":["论文","Characteristic"]},{"title":"基于运动单元的肌肉力估计新方法","url":"/2023/01/07/论文/Decomposition/基于运动单元的肌肉力估计新方法/","content":"\n这篇文献在运动单元分解方面讲解得较为简单易懂，主要是文中基本涉及到了MUST分解、MUAP估计等分解方面的流程，并且在相关部分引用的文献确实能够解答一些疑惑，对运动单元分解的理解有很大的帮助。\n\n<!-- more -->\n\n# 1. 笔记\n\n## 1.1 引言\n\n目前研究肌肉力的方法仍然局限于 sEMG 与力宏观参数之间的关系， 比如均方根( root mean square， ＲMS) 、积分肌电( integral electromyogram，IEMG) 、平均功率频率 ( mean power frequency，MPF) 、中位频率( median frequency， MF) 等等时频域的参数， 而从运动单元角度描述 sEMG 与力的关系较少。  随着分解技术的发展，通过运动单元来估计肌肉力成为可能。  \n\n## 1.2 实验设置\n\n实验前需要对皮肤用医用研磨膏、砂纸去掉肱二头肌皮肤上角质层，并用酒精消毒。把电极阵列均匀涂上导电膏，贴在肱二头肌上，用胶带固定，保证电极与皮肤的充分接触。  \n\n**人数**：5——3男2女\n\n**MVC**：受试者用手 3 次最大力推手柄，每次保持 2 s，每次用最大力，取 3 次最大力的平均值作为该受试者最大收缩力\n\n**力水平设置：**\n- 5% MVC\n- 10% MVC\n- 15% MVC\n- 20 % MVC\n\n## 1.3 结论\n\n随着肌肉力的增加 ， MU 的募集数目基本上都在增加。\n\n需要手动调整发放时间，运动单元发放间隔在［20ms， 200 ms］ 范围内。\n\n采用棘波触发平均技术STA 提取的 MU 波形， 由于采用 64 电极阵列，得到 64 个波形。STA 实施方法如下: \n\n1. 把分解得到的发放时刻作为中心， 前 30 ms、中间段 36 ms 以及后 30 ms 作为 MU 波形提取长度\n2. 去掉整个波形平均值得到 MU 波形\n\n研究表明，在肌肉疲劳的情况下，肌肉运动单元会降低发放频率。  ","tags":["MUAP","MUST","STA"],"categories":["论文","Decomposition"]},{"title":"Surface electromyography  physiology, engineering and applications","url":"/2023/01/04/论文/Characteristic/Surface-electromyography-physiology-engineering-and-applications-1/","content":"\n关于肌电最新研究的介绍书籍。\n\n<!-- more -->\n\n# 第一章 肌肉激活和力量产生的生理学\n\n**运动单元：**\n\n神经肌肉系统的基本功能单位是运动单位。它包括一个运动神经元，包括其树突和轴突，以及受轴突支配的肌肉纤维。\n\n在大部分的肌肉当中，运动单位内肌纤维的数目都有差异。 例如，某一块肌肉可能包含有**25个运动单位**，平均每个运动单位内有200条肌纤维，但最小的一个可能只有25条肌纤维，而最大的一个却可能有近500条肌纤维之多。\n\n每一条运动神经元所支配的肌纤维数量与肌肉本身的大小并无实际关系，反而与肌肉运作时要达至的精确度和协调性有关。负责细致和精密工作的肌肉（如眼部肌肉），每一个运动单内可能只有一条至数条的肌纤维。反过来说，专责粗重工作的肌肉（如四头肌），每一个运动单位内就可以有数百以至数千条的肌纤维。\n\n**运动神经元：**\n\n运动神经元位于脊髓的腹角或脑干，在那里它接受来自神经系统其他部分的感觉和下行输入。每个运动神经元的轴突通过腹根离开脊髓，并投射到周围神经到其目标肌肉和它支配的肌肉纤维。由于运动神经元产生的动作电位通常会导致所有属于运动单元的肌肉纤维产生动作电位，肌肉纤维动作电位的EMG记录提供了脊髓或脑干中运动神经元激活的信息。\n\n**运动神经元池：**\n\n支配<font color =\"red\">单个肌肉</font>的运动神经元群被称为运动核或运动神经元池，运动核中的运动神经元数量从几十个到几百个不等。每个肌肉的运动神经元池通常纵向延伸到脊髓的几个节段，在每个节段水平上，近端肌肉的运动神经元池比远端肌肉的运动神经元池更倾向于腹侧和外侧，前端肌肉的运动神经元池比后端肌肉的运动神经元池更偏向外侧。\n\n**肌肉单元：**\n\n由单个轴突支配的肌纤维被称为肌肉单元，其大小在每个运动单元池中不同。每个运动单元支配一些肌肉纤维(肌肉单元)。在自愿收缩时，相比于后募集的运动单元，先募集的运动单元支配的肌肉纤维更少更小。肌肉中的大多数运动单元具有小肌肉单元，只有少数运动单元具有大肌肉单元。肌肉单位纤维的密度为每100个肌肉纤维中3至20个。此外，单个肌肉单位的纤维通常不是从肌肉的一端延伸到另一端，而是终止于肌肉束内。\n\n**神经驱动**和**肌肉激活：**\n\n有必要区分从脊髓释放的运动单元动作电位的数量和肌电图电极记录的肌肉纤维动作电位的数量。这种区别用术语“神经驱动”表示运动单元动作电位，用术语“肌肉激活”表示肌肉纤维动作电位（muscle fiber action potential）。\n\n**运动神经元动作电位的产生：**\n\n- 泄露通道：主要负责形成静息电位\n- 电压门通道\n- 离子突触通道\n- 神经调节受体\n\n各通道涉及到K、Na离子的出入，详细请参考page25。\n\n![image-20230104222905456](Surface-electromyography-physiology-engineering-and-applications-1/image-20230104222905456.png)\n\n运动神经元接收的电流、其释放动作电位的速率和肌肉单位施加的力之间的关系。（底部）用微电极注入运动神经元的电流。（中间）运动神经元的膜电位（电压）随着注入电流的逐渐增加而发生的变化。当膜电位的变化超过电压阈值时，运动神经元被激活（募集阈值）并开始释放动作电位。插图显示了动作电位之间的膜电位轨迹，其被截断以强调后超极化（AHP）阶段。（上部）响应于电流增加和肌肉单元产生的力相应增加的瞬时放电速率（pps=每秒脉冲数）的曲线图。\n\n运动神经元膜电位随突触电流的变化而变化，这在很大程度上取决于树突的数量和大小。小运动神经元具有最不广泛的树突网络（低输入电导），因此膜电位在突触电流的影响下变化最大。由于所有运动神经元的电压阈值值相似，触发区（轴突丘）中膜电位的变化将超过电压阈值，小运动神经元的突触电流最少，因此这些神经元将首先随着突触输入的逐渐增加而被招募（尽管兴奋性输入通常在最大的运动神经元中最大，在最小的运动神经元最小，但结合运动神经元的固有特性时，募集顺序仍按从最小到最大的顺序进行）。此外，运动神经元在其被募集（募集阈值）后释放动作电位的速率（速率编码）与其接收的电流成正比。\n\n**肌肉产生的力：**\n\n肌肉单位产生的力在很大程度上取决于其神经支配数量，其在运动单位池内呈指数变化（图1.2B），并且肌肉的平均神经支配数量不同（表1.1）。在弱收缩期间精确分级力的能力可能取决于所涉及肌肉中小肌肉单位的大小和数量。相比之下，大的肌肉单位可能只在快速或有力的收缩时发生。\n\n**肌肉纤维动作电位：**\n\n由于神经-肌肉突触通常提供运动神经元与其肌肉纤维之间的安全传输，轴突动作电位总是产生超过电压阈值的端板电位，并产生与收缩蛋白结合的肌肉纤维动作电位。每个肌纤维动作电位从神经-肌肉突触开始，并向肌纤维末端的两个方向传播。尽管动作电位沿肌肉纤维传播的速度（称为传导速度）取决于肌肉纤维的直径，但它受到肌肉长度变化、皮肤温度和代谢产物胞外浓度等因素的调节。","tags":["MUAP","MUST","MU"],"categories":["论文","Characteristic"]},{"title":"Hyser database","url":"/2022/12/29/数据库/Hyser-database/","content":"\n[Open Access Dataset and Toolbox of High-Density Surface Electromyogram Recordings v1.0.0 (physionet.org)](https://physionet.org/content/hd-semg/1.0.0/)\n\n<!-- more -->\n\n# 1.概述\n\n我们提供了一个*高密度表面肌电图*（HD-sEMG）*记录*（名为“*Hyser*”）的开放访问数据集，以及用于神经接口研究的工具箱。我们从20名受试者那里获得了数据，每个受试者在不同的日期按照相同的实验范式参加了两次实验。使用我们的数据集，研究人员可以开发34个手势的模式识别以及HD-sEMG和五个手指力之间的回归的先进技术。这些技术对于直观控制神经假体和神经外骨骼至关重要。我们的工具箱可用于：（1）使用标准基准方法分析五个数据集中的每一个，以及（2）通过独立成分分析将HD-sEMG信号分解为运动单元动作电位。\n\n# 2.背景\n\n基于表面肌电图（sEMG）的神经接口[1]最近引起了越来越多的关注。具体来说，通过从sEMG信号中解码截肢者的运动意图信息，可以自动检测残肢残余肌肉的收缩，然后用于直观地控制神经假体和神经外骨骼[2]。随着柔性传感技术的进步，高密度sEMG（HD-sEMG）具有覆盖特定肌肉上方更大皮肤区域的大量通道，可以提供高分辨率的肌肉激活图[3]。然而，HD-sEMG数据集非常稀缺。此外，没有用于手部假肢的HD-sEMG数据集来控制五个手指的力量（我们松散地使用术语手指来指代给定手上的手指和拇指）。因此，我们提供了一个*高密度表面肌电图记录*（名为“*Hyser*”）的开放访问数据集。\n\nHyser数据集由5个子数据集组成：（1）模式识别（PR）数据集，该数据集是在日常常用的34个手势下获得的，（2）最大自愿肌肉收缩（MVC）数据集，该数据集是在每个受试者单独收缩他们的5个手指时获得的（MVC信号可用于归一化力数据），（3）在每个手指收缩期间获得的一自由度（DoF）数据集（跟踪目标力轨迹），（4）在规定的多个手指组合收缩期间获得的N-DoF数据集（跟踪目标力轨迹），以及（5）在手指组合随机收缩期间获得的随机任务数据集，不遵循任何规定的力轨迹。\n\n不同手势的模式识别[4]和HD-sEMG和手指力[2]之间的回归都可以使用我们的Hyser数据集进行研究。此外，我们的工具箱可用于：（1）使用标准基准方法分析五个数据集中的每一个[2]和（2）通过独立的分量分析将HD-sEMG信号分解为运动单元动作电位[5]。我们希望我们的数据集能够提供一个平台，以促进神经接口技术的广泛研究以及神经康复领域工程师之间的合作。\n\n# 3.方法\n\n- 20名受试者，包括12名男性和8名女性（22至34岁），手指完好无损，参加了这项研究。所有受试者都签署了书面知情同意书。该实验经复旦大学伦理委员会审核通过（批准文号：BE2035）。\n\n- 对于PR数据集，当受试者执行34种不同的手势时，获得了256通道HD-sEMG。对于每个手势，执行动态任务（1 s持续时间，从受试者的放松状态到所需的手势）和保持任务（4 s持续时间，从受试者的放松状态到所需的手势，然后保持该手势）。\n\n- 对于MVC数据集，1-DoF数据集，N-DoF数据集和随机数据集，同步获取256通道HD-sEMG和地面实况力值。\n\n  EMG采集位置：\n\n![image-20230429112024197](Hyser-database/image-20230429112024197.png)\n\n​\t\t一共5个手指，对每个手指，按三角形力曲线发力，持续时间为25s，三角形力曲线从<mark>伸</mark>的30%MVC到<mark>屈</mark>的30%MVC，重复<mark>3次</mark>，执行<mark>等长收缩</mark>。\n\n![image-20230429112922371](Hyser-database/image-20230429112922371.png)\n\n​\t\tHD-sEMG信号以<mark>2048 Hz采样率</mark>采集。以<mark>100 Hz</mark>采样率采集地面实况力信号。\n\n- 在预处理阶段，首先使用10--500 Hz 8阶巴特沃兹带通滤波器对采集的HD-sEMG信号进行滤波。然后使用陷波滤波器组合来衰减50 Hz的电力线干扰和高达400 Hz的所有谐波分量。 力数据由8阶10 Hz低通巴特沃兹滤波器滤波。我们在数据集中提供原始的HD-sEMG信号和预处理的HD-sEMG信号。\n\n- 此外，我们提供了一个用于HD-sEMG分析的工具箱，它执行：（1）使用基于线性判别分析（LDA）和基于深度学习的手势分类分析模式识别数据集，（2）分析数据集2--4（来自背景部分中概述的5个子数据集），（3）使用ICA将HD-sEMG信号分解为MU尖峰序列。我们工具箱中的所有分析都是通过 MATLAB 实现的。请注意，要完全实现我们的工具箱，用户仍然需要 MATLAB 许可证。\n\n# 4.数据描述\n\n五个数据集对应的数据存储在五个文件夹中，分别是\"pr_dataset\"（37.1GB）, \"mvc_dataset\"（7.8GB）,\"1dof_dataset\"（29.3GB）, \"ndof_dataset\"（58.6GB）, \"random_dataset\"（9.8GB）。对于 PR 数据集，真实手势标签存储在“.txt”文件中，具有逗号分隔值格式。所有其他信号段（HD-sEMG信号和地面实况力轨迹）都以波形数据库（WFDB）格式存储，其中一个“.dat”文件存储所有16位有符号类型量化值，一个“.hea”文件（除文件扩展名外，文件名与“.dat”文件相同）存储比例因子。\n\narray1+array2：伸肌\n\narray3+array4：屈肌\n\n# 5. MU分解结果\n\n**SIL 阈值**：0.6\n\n**识别到的 MU 数目**：18.28（±5.82）+14.29(±7.32) 。前面为伸肌，后面为屈肌\n\n\n\n","categories":["数据库"]},{"title":"Multichannel Blind Source Separation Using Convolution Kernel Compensation","url":"/2022/12/24/论文/Decomposition/Multichannel-Blind-Source-Separation-Using-Convolution-Kernel-Compensation/","content":"\nDEMUSE Tool是提出这个算法的学者开发的matlab工具箱，但是不开源，其官网链接为：[DEMUSE Tool (um.si)](https://demuse.feri.um.si/)。这个网站中对sEMG的产生机理、CKC算法做了非常详细的描述，十分值得一看。Holobar主页：https://so3.cljtscd.com/\n\n<!-- more -->\n\n---\n\n*2023/12/11*\n\n- 为什么叫卷积核补偿算法？\n\n  因为表面肌电信号是一个卷积混合模型，而矩阵H就是卷积核，通过计算马氏距离的平方，CKC算法对这个卷积核进行了补偿，直接估计了MUST。\n  \n- 对该算法的理解\n\n  该算法通过线性最小均方误差估计器对脉冲序列进行估计：\n  $$\n  \\hat{t}_j(n)=\\mathbf{c}_{t_j\\mathbf{x}}^T\\mathbf{C}_{\\mathbf{x}\\mathbf{x}}^{-\\mathbf{1}}\\mathbf{x}(n)=\\mathbf{c}_{t_j\\bar{\\mathbf{t}}}\\mathbf{H}^T\\left(\\mathbf{HC}_{\\overline{\\mathbf{t}}\\overline{\\mathbf{t}}}\\mathbf{H}^T+\\mathbf{C}_{\\omega\\omega}\\right)^{-1}\\mathbf{H}\\bar{\\mathbf{t}}(n)\n  $$\n  但是 $\\mathbf{c}_{t_j\\bar{\\mathbf{t}}}^T$  事先不知道，因此首先需要赋一个初值。不失一般性，假设第 j 个 MU 在 n1时刻发放，那么设 $\\hat{\\mathbf{c}}_{t_j\\mathbf{x}}=\\mathbf{x}(n_1)$，那么得到发放序列的第一个估计：\n  $$\n\\hat{t}_j(n)=\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}^T\\mathbf{C}_{\\mathbf{x}\\mathbf{x}}^{-1}\\mathbf{x}(n)\n  $$\n  选取$\\hat{t}_j(n)$中最大峰值的时刻作为可能的第二次发放的时刻，并更新$\\hat{\\mathbf{c}}_{t_j\\mathbf{x}}$：\n  $$\n\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}=\\frac{\\mathbf{\\hat{c}}_{t_j\\mathbf{x}}+\\mathbf{x}(n_2)}2\n  $$\n  然后按照上述过程不断循环。<font color=\"red\">有一个问题是，如何初始化这个n1呢？（已通过激活指数解决）</font>\n\n*2023/12/26*\n\n- 对该算法的理解：\n\n  我们知道，分离向量是找到一个时刻，然后相关矩阵的逆矩阵乘以该时刻的<mark>观测值列向量</mark>就得到了分离向量。文章说先是计算激活指数，然后如果第j个MU在n0时刻发放的话，那么$$ s_{n0}(n)=\\bar{X}^T(n_0)C_{\\overline{X}\\overline{X}}^{-1}\\bar{X}(n) $$就是第j个MU的IPT估计，后续只需要通过下述表达式改进这个<mark>观测值列向量</mark>就行：\n  $$\n  C_{\\bar{X}_{sj}}=\\frac1{\\operatorname{card}(\\varphi_n)}\\sum\\bar{X}(\\varphi_n)\n  $$\n\n_2023/12/29_\n\n- 为什么有这么一个取平均的操作？\n\n  注意到 CKC 算法的关键是估计相关向量 $\\mathbf{c}_{t_j\\mathbf{x}}$，但是由于 $t_j$ 事先是不知道，因此无法直接计算。而 $\\mathbf{c}_{t_j\\mathbf{x}}=E(t_j(n)\\mathbf{x}(n))$ 这个计算公式表明，$\\mathbf{c}_{t_j\\mathbf{x}}$ 是第 $j$ 个 MU 发放时刻 $t$ 的发放时刻处，观测向量的期望，而期望就是取平均，所有才有了取平均估计相关向量这么一个操作。\n\n_2024/1/2_\n\n- 对相关矩阵进行截取操作\n\n  这个操作是为了减小噪声带来的干扰，在SNR=15dB时，截取程度为0%，在SNR为0dB时，截取程度为20%。\n\n_2024/1/10_\n\n- n0时刻的相关向量分离得到的spike train，只有那些在n0时刻发放的mu对这个spike train有贡献，也就是说，使用n0时刻的观测向量作为相关向量，只要是在n0时刻发放的mu，它们的脉冲都会被加强，只是其他时刻的脉冲幅值加强程度没有n0时刻强。而其他没有在n0时刻发放的mu则在幅值上贡献的非常少。所以一般情况下某个时刻只有一个脉冲序列发放，因此该时刻的分离向量分离得到的spike，幅值较高的都来自于这个脉冲序列。\n\n- 两个互补假设：从vn0和vn1做内积得到的spike train中选取脉冲时刻nr，这个nr对应的脉冲序列有两种情况（1）如果Gn0∩Gn1不为空，那么做内积之后的集合代表了同时在n0和n1发放的mu，因此这个mu的脉冲被加强，所以nr也是这个mu的脉冲，所以至少有一个mu在n0和n1和nr发放；（2）如果Gn0∩Gn1为空，那么至少存在两个脉冲，都在nr处发放，其中一个在n0和nr处发放，另一个在n1和nr处发放。\n\n- 取哪个时刻的观测向量作为相关向量，那么该时刻的脉冲就被加强，对应mu的其他脉冲也加强，只是幅值稍低。所以分解算法的收敛条件是对所有发放时刻的观测向量取期望作为相关向量，使用这样一个平均的相关向量进行分离得到的spikes在幅值上都是接近的。所以这就是最终的收敛条件。\n\n  ![image-20240112160151805](Multichannel-Blind-Source-Separation-Using-Convolution-Kernel-Compensation/image-20240112160151805.png)\n\n- CKC算法一般取4个发放时刻，通过两个假设以及这几个时刻的spike数目来对这些spike的归属进行判断，如果都是来自于同一个MU，那么通过对这些发放时刻的观测向量取均值，得到相关向量，然后得到spike。\n\n2024/3/6\n\n- 对相关矩阵 $C$ 的理解，假设有这么一个信号：\n  $$\n  \\begin{gathered}\\mathbf{y}=\\begin{bmatrix}a1&a2&a3&...\\\\b1&b2&b3&...\\end{bmatrix}\\\\C_\\mathbf{y}=E[\\mathbf{y}(n)\\mathbf{y}(n)^T]=\\frac13(\\begin{bmatrix}a1a1&a1b1\\\\a1b1&b1b1\\end{bmatrix}+\\begin{bmatrix}a2a2&a2b2\\\\a2b2&b2b2\\end{bmatrix}+\\begin{bmatrix}a3a3&a3b3\\\\a3b3&b3b3\\end{bmatrix}+...)\\end{gathered}\n  $$\n  可以看到如果两个通道中没有 MUAP 重合，那么交叉项就很小，矩阵对角占优。\n\n# 1. 笔记\n\n$$\nx_i(n)=\\sum_{j=1}^N \\sum_{l=0}^{L-1} a_{i j}(l) t_j(n-l) ; \\quad i=1, \\ldots, M\n$$\n\nsymbol 的长度为 L，也就是 $a_{ij}$ 的长度是 L。如果不考虑 N 个源的叠加，那么就是 $a_{ij}(n)$ 与 $t(n)$ 的卷积，该表达式的意义就是对于某一个观察或检测，其值等于一个源的发放时间与观测位置处 symbol 的卷积，再对所有源求和的一个结果。\n\n**超定和欠定主要是看混合矩阵A的行KM与列N(L+K-1)的大小，KM大则是超定，KM小则是欠定。**\n\n采样率高了之后，两个峰值之间的采样点就多了，因此就相当于变得稀疏了。\n\n> Moreover, when sampling frequency is high enough (with respect to the symbol rate), the pulse trains become highly sparse.\n\n$$\n\\overline{\\mathbf{y}}(n)=\\mathbf{A} \\overline{\\mathbf{t}}(n)+\\overline{\\boldsymbol{\\omega}}(n)\n$$\n\n混合矩阵A中包含的信息实际上是被忽略了的，CKC算法更关注脉冲序列的性质。\n\n> CKC 算法用于求取脉冲序列，也就是上式中的 $\\overline{\\mathbf{t}}(n)$，求得的结果是对 $\\overline{\\mathbf{t}}(n)$ 的最佳线性贝叶斯估计，线性贝叶斯估计是求取一组最佳的权重，将信号每一个时间点的值加权求和来估计参数。\n\n## 1.0 符号说明\n\n- 时间扩展向量（在 n 这个时刻对 N 个源信号扩展）， 维度：1 × N (K+L-1)：\n  $$ \\begin{array}{r}\n  \\overline{\\mathbf{t}}(n)=\\left[t_1(n), t_1(n-1), \\ldots, t_1(n-L-K+2), \\ldots,\\right.\n  \\left.t_N(n), \\ldots, t_N(n-L-K+2)\\right]^T\n  \\end{array}$$\n\n- 时间扩展向量中的第j个元素（这个元素可能是n时刻的，也可能是n时刻前的）：$\\bar{t}_j(n)$\n-   把 $\\overline{\\mathbf{t}}(n)$ 中的第 j 个元素在每个 n 时刻都取出来构成向量：$\\overline{\\mathbf{t}}_j=\\left\\{\\bar{t}_j(n) ; n=0,1, \\ldots\\right\\}$\n- 全局活跃指数：$\\gamma=\\{\\gamma(n) ; n=0,1, \\ldots\\}$ ，$n_k$时刻不为0，则至少存在一个j，使得$\\overline{\\mathbf{t}}(n_k)$中的第j个元素 = 1。即： $\\gamma\\left(n_k\\right)>0 \\Leftrightarrow \\exists j;\\bar{t}_j(n) =1$。\n- 当 $n_0$ 时刻存在 $g_0$ 个 j 时，j 的一个集合：\n  $$ G_{n_0}=\\left\\{j_{n_0, 1}, \\ldots, j_{n_0, g_0}\\right\\} \\text {, i.e., } j \\in G_{n_0} \\Leftrightarrow \\bar{t}_j\\left(n_0\\right)=1$$\n- 观测扩展向量：\n  $$ \\begin{aligned}\\overline{\\mathbf{y}}(n)=[y_1(n),y_1(n-1),\\ldots,y_1(n-K+1),\\ldots,y_M(n),\\ldots,y_M(n-K+1)]^T\\end{aligned} $$\n\n## 1.1 超定情况\n\nsymbols的个数N少于观测的个数M（源的个数少于通道的个数），脉冲序列相关性很弱（比如有少量但确实存在的脉冲重叠）。此外，假设观测值是遍历的，并用扩展观测值的相关矩阵表示。最后，假设扩展因子足够大，且矩阵是满列秩的。\n\n激活指数（<font color=\"red\">怎么得到的这个表达式？</font>）：\n$$\n\\begin{aligned}\n\\gamma(n) & =\\overline{\\mathbf{x}}^T(n) \\mathbf{C}_{\\overline{\\mathbf{xx}}}^{-1} \\overline{\\mathbf{x}}(n) \\\\\n& =\\overline{\\mathbf{t}}^T(n) \\mathbf{A}^T\\left(\\mathbf{A}^T\\right)^{-1} \\mathbf{C}_{\\overline{\\mathbf{tt}}} \\mathbf{A}^{-1} \\mathbf{A} \\overline{\\mathbf{t}}(n) \\\\\n& =\\overline{\\mathbf{t}}^T(n) \\mathbf{C}_{\\overline{\\mathbf{t t}}}^{-1} \\overline{\\mathbf{t}}(n)\n\\end{aligned}\n$$\n激活数的发放时间表示形式只需要把公式 $$\\overline{\\mathbf{x}}(n)=\\mathbf{A} \\overline{\\mathbf{t}}(n)+\\overline{\\boldsymbol{\\omega}}(n)$$ 忽略噪声代入即可。激活指数是全局脉冲序列活动的一个指标，在某个时刻时，只有当至少有一个脉冲序列在此刻发放，那么激活指数才不为0，因为C中的元素是时刻之间的自相关系数和互相关系数，均不为0（其逆也不为0），所以只要存在一个MU的发放脉冲，那么相乘相加后一定是大于0的。\n\n当我们用存在发放时刻的观测序列去代替原观测序列后，有如下表达式：\n$$\n\\begin{aligned}\n\\nu_{n_0}(n) & =\\overline{\\mathbf{x}}^T\\left(n_0\\right) \\mathbf{C}_{\\overline{\\mathbf{x x}}}^{-1} \\overline{\\mathbf{x}}(n)=\\overline{\\mathbf{t}}^T\\left(n_0\\right) \\mathbf{C}_{\\overline{\\mathbf{t t}}}^{-1} \\overline{\\mathbf{t}}(n) \\\\\n& =\\sum_{k \\in G_{n_0}} \\sum_{j=1}^{N(L+K-1)} c_{j k}^{\\mathrm{inv}} \\bar{t}_j(n)\n\\end{aligned}\n$$\n\n注意，这个表达式中的j代表的是时间扩展向量中的第j个元素，在左边项取了n0后，t的值就变成了1或者0，0项在求和过程中可以忽略，1作为系数时也省略不写，因此可以化简成上式求和的形式。上式中j代表的是行，k代表的是列，可以看到行是全部索引完的，而列只取矩阵中激活的列，即t中每一个元素与C中的列对应相乘，最后再求和。\n\n附录A证明，C拥有优越的对角线，是对角占优的，所有可以忽略掉非对角线的部分，得到如下公式：\n$$\n\\nu_{n_0}(n) \\approx \\sum_{j \\in G_{n_0}} c_{j j}^{\\operatorname{inv}} \\bar{t}_j(n) .\n$$\n注意，上述公式中，n是遍历所有采样点的，只有当n=n0时，$\\nu_{n_0}$才不等于0（因为j是在n0时取的，一旦错位最终结果就是0），这样也就在时间轴上找到了n0。但是也存在一些偶然情况，比如考虑n0时刻，其脉冲集合是$G_{n_0}$，而当n遍历到n2时，这时如果n2时间序列的第$j_{n_0,1}$个元素恰好与n0时间序列的$j_{n_0,2}$重合，那么该式得到的结果也不是0，这样就会找到两个时刻点n0和n2，因此，还需要对这些时刻进行分离，示意图如下：\n\n![image-20230309210631973](Multichannel-Blind-Source-Separation-Using-Convolution-Kernel-Compensation/image-20230309210631973.png)\n\n## 1.2 脉冲序列的分离\n\n从上图可以看到，$G_{n_0}$ 和 $G_{n_2}$ 中至少存在一个脉冲重叠。对 $\\nu_{n_0}$ 和 $\\nu_{n_2}$ 做内积（$\\nu_{n_0}(n) \\cdot \\nu_{n_1}(n) ;$  $n=0,1,2, \\ldots$），得到一个序列，记为 $\\mathbf{h}_{n_0, n_1}$，再随机选择 R-2个脉冲记为 $n_r ; r=2, \\ldots, R-1$。对于 $n_r$，有两个互补（两者之一必成立）结论：\n![image-20230315162816044](Multichannel-Blind-Source-Separation-Using-Convolution-Kernel-Compensation/image-20230315162816044.png)\n对每一个 $n_r ; r=2, \\ldots, R-1$，求 $\\mathbf{v}_{n_r}$，并生成集合 $G_{n_r}=\\left\\{j_{n_r, 1}, \\ldots, j_{n_r, g_r}\\right\\}$。再对所有的 $\\nu_{n_r}(n)$ 求内积得到最终序列。\n\n","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"Adaptive Real-Time Identification of Motor Unit Discharges From Non-Stationary High-Density Surface Electromyographic Signals","url":"/2022/12/11/论文/Dynamic/Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/","content":"\n重要程度: ⭐⭐⭐⭐⭐\n\n阅读这篇文献是因为阅读的 _Non-Invasive Analysis of Motor Unit Activation During Simultaneous and Continuous Wrist Movements_ 这篇文献在介绍其分解流程时引用了这篇文献，想通过该文献来详细了解分解流程。这篇文章介绍了如何实时分解高密度肌电得到运动单元。方法也比较简单，就是先训练得到 MUST 的分离矩阵和相关参数，然后对在线采集的高密度肌电直接使用训练得到的分离矩阵和相关参数从而得到 MUST。文章从仿真数据和真实数据两个方面进行了验证，重点关注了一下实验范式。\n\n<font color='red'>这篇文章还研究动态下的分解效果，通过数据手套来记录关节数据，重点参考。提出的更新算法也主要是对动态的数据有用。</font>之前有文章研究了实时的分解，但是局限在静态的条件下，也有文章研究了动态的分解，但是是离线的，这篇文章同时实现了实时的MUST识别，还能够适用于非静态的条件。\n\n本文的思路是这样的，要研究实时的分解效果，也就是研究在一个滑动窗中间的分解效果：首先通过前10s分解得到分离参数，然后对剩余的信号采用滑动窗口，在这个窗口中，采用了更新策略分解出的 MU 更多，而直接使用静态 gckc 算法得到的 MU 更少。思路很重要：等式 (1) 中的混合矩阵 H 在等长收缩中是恒定的，但在非等长条件下随时间变化，这需要相应的分离向量进行更新。\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1 引言\n\n>  a decomposition method robust to changes of motor unit action potential (MUAP) has been proposed and can be used for the identification of motor unit firings during dynamic contractions.   \n\n<font color='red'>什么是静态？静态就是兴奋的水平（频率）和MUAP的波形不变。</font>\n\n对于兴奋程度改变，MUAP改变的情况，不能直接把离线的分离向量用在在线的分解上，因此需要对分离向量等参数进行更新。但是之前使用的CNN是可以的。\n\n## 1.2 分解流程\n\nTwo sessions:\n\n1. offline session：得到估计参数、分离MUST的矩阵、以及spike提取的阈值\n2. online session：滑动窗口中，将预处理过后的EMG信号与分离矩阵直接相乘，得到发放序列\n\n<mark>在离线步骤中，首先使用卷积核补偿（CKC）算法将表面肌电信号分解为MUST</mark>。\n\n多通道表面EMG信号的生成模型可以描述为一系列脉冲的卷积混合，代表运动单元的<mark>放电模式(diacharge pattern)</mark>。该混合模型中滤波器的<mark>脉冲响应</mark>是运动单元的动作电位，其持续时间有限。混合过程可以矩阵形式写成：\n\n$$\ny(n)=H \\bar{s}+\\omega(n)\n$$\nCKC方法补偿方程上述方程中的未知混合矩阵H，并估计第j个电机单元的尖峰序列为：\n$$\n\\widehat{s}_j(n)=w_j^T \\bar{y}(n) \\\\\nw_j=C_{\\bar{y} \\bar{y}}^{-1} c_{s_j \\bar{y}}\n$$\nPNR 的计算公式：\n$$\n\\mathrm{PNR}_j=10\\cdot\\log\\left(\\frac{E(\\widehat{s}_j(n)|_{\\widehat{s}_j(n)\\geq r})}{E(\\widehat{s}_j(n)|_{\\widehat{s}_j(n)<r})}\\right)\n$$\n整个算法流程：\n\n![image-20221211211613749](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20221211211613749.png)\n\n**对online估计所做的改进：**\n\n将离线阶段中获得的分离向量应用于在线分解仅当离线和在线阶段的信号特性之间保持相似时，才能确保在线阶段中的EMG分解的有效性。比如在信号是静止的情况下。然而，在一般情况下，初始的分离向量是需要持续自适应的。\n\n**为了适应非静态条件**，文章提出了一种更新策略，在每次识别新的放电时间序列时调整分离向量$w_j$的方法，效果如下：\n\n![image-20221211210827239](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20221211210827239.png)\n\n分离向量和聚类中心的更新公式如下：\n$$\n\\begin{aligned}\n&C_{\\bar{y}\\bar{y}} =C_{\\bar{y}\\bar{y}}+C_{\\triangle\\bar{y}\\triangle\\bar{y}}  \\\\\n&c_{s_{j}\\bar{y}} =c_{s_j\\bar{y}}+\\ell\\cdot\\frac1{card(\\Psi_j)}\\sum_{n_k\\in\\Psi_j}\\triangle\\bar{y}(n_k) \\\\\n&T_{ij}=\\frac{w_1T_{ij}+w_2T_{ij}^{^{\\prime}}}{w_1+w_2},i=1,2\n\\end{aligned}\n$$\n这里是对分离向量进行更新，这个更新类似于梯度的更新。协方差矩阵表示的是随机变量之间的相关性（注意：相关系数就是根据协方差计算的）。这里在分段后更新了协方差矩阵，相当于加强了这一小段中随机变量的特性\n\n**online 估计的滑动窗口**：200 ms  \n<font color='red'>一个新的概念有待了解</font>：尖峰间隔变异性\n\n## 1.3 实验范式\n\n### 1.3.1 仿真EMG：\n\n<font color=\"red\">通过把MUST卷积MUAP得到仿真的EMG。</font>在每次仿真中，前10秒的信号用于离线训练，而剩余的60秒信号用于测试在线分解的性能。\n\n- 数据集1：10%，30%，50%持续兴奋下的数据，持续70s。\n\n  > In dataset Sim1, three contraction conditions were simulated with different input excitation levels (10%, 30%, or 50%). In this dataset, the input excitation was constant and lasted for 70 s. The number of recruited motor units was 52 (10% excitation), 77 (30%), and 89 (50%).  \n\n  这说明是通过改变募集 MU 的数目来改变兴奋程度的，一定程度上印证了兴奋之和募集 MU 数目以及发放频率有关，MUAP 的幅值是不会改变的。\n\n- 数据集2：兴奋首先保持10s（这10s 应该是和数据集1中的兴奋是一致的），然后在60s 内变化，兴奋的水平 3 $\\times$ 4 兴奋的改变速度 $=$ 12组\n\n![image-20221214114311631](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20221214114311631.png)\n- 数据集3：兴奋的水平是保持不变的，<mark>改变MUAP波形（stretching the MUAP duration and compressing the MUAP amplitude  ）</mark>。局限性：保持兴奋不变，意味着发放频率和募集的 MU 数目不变，只改变 MUAP 的形状。\n\n![image-20221214114402665](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20221214114402665.png)\n\n红色和蓝色分别代表肌肉完全伸张和完全收缩情况下的MUAP，可以看到波形虽然有区别，但是是差不多的。\n\n如何量化兴奋程度参考文献：  \n\n> Models of recruitment andrate coding organization in motor-unit pools\n\n### 1.3.2 实验数据\n\n真实采集的数据集和模拟仿真的数据集是一一对应的，分为EXP1，EXP2，EXP3。实验数据长40s，前10s用作训练得到分离向量，后30s用作在线分解：\n\n- 在EXP1中，受试者被要求以最大自主收缩（MVC）力的10%、30%和50%的恒定力进行等长抓握\n- 在EXP2中，受试者被要求遵循模拟2中描述的力轨迹。为了简化实验，只在三个水平上保持6秒的斜坡\n- 在EXP3中，受试者被要求进行非等长动态抓握，抓握周期被设定为6秒。受试者在<mark>动态抓握</mark>过程中被要求尽量保持收缩水平，但不严格。\n\n从这个实验范式的设置中可以看出：（1）真实的力对应模拟的兴奋水平；（2）通过改变等长收缩来改变MUAP的形状\n\n**人数**：5——4男1女\n\n**设备**：\n\n- EMG采集：ELSCH064NM3, 8 × 8 channels, OT Bioelettronica, Italy，3片64通道电极片\n- 运动学采集：14通道，5 DT Data Glove 14 Ultra, 5DT Inc. USA \n\n**数据预处理**：\n\n- 20-500Hz 滤波\n- <mark>50Hz 工频干扰及其谐波滤波，梳状滤波器</mark>\n\n## 1.4 分解评估\n\n对于仿真数据集（灵敏度是识别出了多少，准确度是识别出的正确的有多少）：\n$$\n\\begin{aligned}\n\\text { Sensitivity } & =\\frac{T P}{T P+F N} \\\\\n\\text { Precision } & =\\frac{T P}{T P+F P}\n\\end{aligned}\n$$\n![image-20231008210215975](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20231008210215975.png)\n\n上图是仿真数据集2的分解结果，可以看到随着兴奋程度的增加，分解的MU数目减少，并且时间越长（最左边是30s，最右边是6s），得到的MU数目越多。\n\n对于实验数据：PNR（基于信号的评价标准）\n$$\n\\mathrm{PNR}_j=10 \\cdot \\log \\left(\\frac{E\\left(\\left.\\widehat{s}_j(n)\\right|_{\\widehat{s}_j(n) \\geq r}\\right)}{E\\left(\\left.\\widehat{s}_j(n)\\right|_{\\widehat{s}_j(n)<r}\\right)}\\right)\n$$\n\n## 1.5 结论\n\n延迟：滑动窗口的计算耗时＜50ms，在线分解10s的信号延迟＜250ms，\n\n仿真数据集：\n\n- 在线分解中，sim1的灵敏度和准确度都大于80%\n- 在线分解中，sim1的灵敏度大于80%，准确度大于70%\n- 更新策略在sim1、2中改善不大，但在sim3（对应于动态情形）中对灵敏度和准确度的提升巨大\n- PNR和sen以及pre之间的回归决定系数\n\n  ![image-20230111134956070](Adaptive-Real-Time-Identification-of-Motor-Unit-Discharges-From-Non-Stationary-High-Density-Surface-Electromyographic-Signals/image-20230111134956070.png)\n\n实验数据集：\n\n- <font color=\"red\">平均PNR为24dB</font>，对应于sensitivity>80%，precision>75%\n\n## 1.7 分解的条件\n\n等距收缩中的非静态参数来自MU的募集、去募集以及放电频率的变化，这两个参数只影响源信号（<font color=\"red\">?</font>），不影响混合过程，本文提出的更新策略对这种变化是稳健的。\n\n在基于CKC的分解算法中，基于混合过程来计算分离向量。等式中的混合矩阵 H 在等长收缩中是恒定的，但在非等长收缩下随时间变化，这需要相应的分离向量更新。动态非等长收缩中，电极与肌肉的相对位置发生变化，导致MUAP的变化以及混合模式的变化\n\n# 2. 问题\n\n- 滑动窗口的步长是多少，这篇文章是怎么执行滑动窗口的    \n  \n> 文章说延迟250ms，那么推算步长应该是200ms，窗口不重叠\n\n- 滑动窗口是200ms，但是muap的长度一般就100ms了，是不是窗口里面一个MU只能识别出1个或者0个discharge\n\n- 这种方法只适用于分解出训练中出现的MU？\n\n- 使用持续兴奋的数据集得到的分离向量，用在兴奋变化的数据集上，这样吗？\n\n","tags":["MUST","上交","Real-Time"],"categories":["论文","Dynamic"]},{"title":"Spike-Triggered Average","url":"/2022/12/08/论文/Decomposition/Spike-Triggered-Average/","content":"Spike-Triggered Average算法简单来说就是首先设置一个窗口长度，然后把这个窗口放置到发放时间处的采集信号下，把所有窗口中的采集点对应相加，最后再除以窗口数量。\n\n<!-- more -->\n\n![image-20230107211333896](Spike-Triggered-Average/image-20230107211333896.png)\n\n","tags":["STA"],"categories":["论文","Decomposition"]},{"title":"Amplitude cancellation reduces the size of motor unit potentials averaged from the surface EMG","url":"/2022/12/08/论文/Cancellation/Amplitude-cancellation-reduces-the-size-of-motor-unit-potentials-averaged-from-the-surface-EMG/","content":"文章介绍了三个生理学参数对幅值抵消的影响，并从STA得到的MUAP分析了幅值抵消带给结果的影响。幅值抵消减小了由sEMG averaged而来的运动单元动作电位。这篇文章研究了幅值抵消对MUAP的影响，主要是通过<font color=\"red\">excitation level, motor unit conduction velocity, motor unit synchronization</font>这三个参数来控制amplitude cancellation。文章还比较了从<font color=\"red\">干扰、没有幅值抵消、以及整流的EMG信号中通过STA方法得到的运动单位电位</font>与<font color=\"red\">从表面检测到的运动单位动作电位</font>。结果表明，生理学上的属性改变（对应着cancellation的强弱）一定程度上违背了STA的基本假设，同时也影响了输出电位的幅值。\n\n<!-- more -->\n\n# 1.笔记\n\n**STA算法依赖于许多假设：**\n\n1. 触发和目标响应之间的延迟固定\n2. 响应和其他信号之间没有相关联的活动\n3. 对每个触发事件的响应波形是一样的\n4. 足够多的触发事件以提取响应\n\n（当将该技术应用于表面肌电的平均值时，可能会违反某些假设。）\n\n**基于运动单元群的计算机仿真：**\n\n1. 确定120个运动神经元群体对不同刺激水平的反应的募集和释放时间\n2. 根据每个运动单元的模拟肌肉纤维动作电位的数量、位置和传导速度生成运动单元电位\n3.  通过对运动单位动作电位序列求和来模拟表面肌电\n4. 在参考运动单元的每个动作电位之前和之后<mark>50ms</mark>计算尖峰触发平均值\n\nMU 的募集初始频率为8 pps，也就是说兴奋一旦超过阈值，就开始以8 pps的频率放电。\n\n兴奋对应于运动神经元池的突触输入水平，是通过输入电流来代表兴奋。\n\n**几种条件下MU分解的对比图：**\n\n![image-20221209170408831](Amplitude-cancellation-reduces-the-size-of-motor-unit-potentials-averaged-from-the-surface-EMG/image-20221209170408831.png)\n\n**STA的处理过程：**\n\n1. 以正峰值为中心前后共取100ms\n2. 每个sta的前40ms用来计算基线噪声\n3. 正峰值前10ms和负峰值后10ms之间的面积用来代表sta的绝对值\n\n**Cancellation的计算方法：**\n\n计算interference EMG中丢失的那部分信号\n\n# 2.文章中包含的结论\n\n> - MU的数目和运动单元力之间是指数关系\n> - 仿真MU的募集阈值分布服从指数函数，低阈值的MU多，高阈值的MU少\n> - 募集阈值高的MU峰值放电频率相较于阈值低的MU更小\n> - 峰值放电率随着募集阈值的增加而线性下降\n> - 容积导体是一种各向异性且不均匀的介质\n> - **幅值抵消的计算**：通过比较 MUAP 整流之前和整流之后的 sEMG 的幅值来量化\n> - 神经支配区的中心位于近端附件纤维长度的40%处。一个运动单元中，the end plate和每根纤维插入肌腱的情况在5mm范围内随机变化（均匀分布）\n> - 一旦兴奋超过运动单元的募集阈值，运动单元就开始以一定发放频率（如：每秒8个脉冲）放电，发放频率随着兴奋的增加而线性增加。最大兴奋表示为：使**最后募集**的运动神经元达到其**峰值发放率**所需的兴奋水平。比如研究表明，*第一个募集MU的最大发放率为35 pps，而峰值发放率随着募集阈值的增加而线性下降，最后一个募集MU分配的峰值发放率为25 pps。最后一个单元的募集接近50%的最大兴奋*。","tags":["Cancellation"],"categories":["论文","Cancellation"]},{"title":"基于盲源分离技术的高密度表面肌电分解","url":"/2022/12/08/论文/Decomposition/基于盲源分离技术的高密度表面肌电分解/","content":"\n肌电信号分解可以看成是肌电形成的逆过程。肌电分解的主要目的是将肌电信号还原成其基本的组成成分：运动单位动作电位序列（MUAPT）。从而可以将肌电信号中的单个的运动单位识别出来并进行归类，进而得到参与此次肌肉活动的运动单位的个数、种类、发放信息及波形信息。（<font color=\"red\">存疑，是先得到MUAPT？还是MUST</font>） 。尽管FastICA算法非常契合表面肌电信号分解的需求，但FastICA是基于瞬时线性混合模型推导的，而表面肌电信号更符合卷积模型\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1 改进FastICA及sEMG模型\n\nFastICA的特性与表面肌电分解的需求非常符合 ：\n\n1. FastICA是基于信号的非高斯性来估计源信号。而在肌电信号分解中，源信号运动单位动作电位序列正是稀疏的超高斯信号。这是符合FastICA的理论假设的。也可以说，FastICA是在肌电分解中是利用了运动单位动作电位序列的稀疏性来进行分解的。同时，不同运动单位的发放可以认为是互相独立的，这也符合FastICA 基本假设。\n2. 相较于其他独立分量分析方法，FastICA的收敛速度快，鲁棒性更好。并且从迭代方程式来看，FastICA不同于其它基于梯度的优化方法，不需要设置步长参数，这一点给算法的使用带来很大方便。\n3. FastICA可以逐个估计源信号。这个的特性是最为重要的。在表面肌电信号分解中，运动单位动作电位叠加十分严重，且运动单位个数未知，信号的信噪比也非常低。要一次性估计出所有运动单位几乎是不可能的任务。而FastICA的这个特性，在探索型数据分析上是十分重要的，它大大简化了求解问题的难度。可以说这是其他大部分盲源分离方法所不具有的优势。\n\n**传统的表面肌电模型如下，记为模型A：**\n$$\nx_i(t)=\\sum_j a_{i j} s_j(t), \\quad \\text { for } i=1, \\cdots, M ; j=1, \\cdots, N\n$$\n在这个模型中考虑表面肌电分解的问题, $x_i(t)$ 表示第 $i$ 个通道采集到的表面肌电信号, 而 $s_j(t)$ 则对应着第 $j$ 个运动单位的运动单位动作电位序列。 从该模型中可以看出, 模型假设不同的通道的表面肌电信号是由同样一批运动单位动作电位序列通过不同的权重 $a_{i j}$ 线性叠加得到的。问题就出在这里。 这样的假设意味着, 对每个运动单位来说, 它在不同电极通道中的运动单位动作电位序列的波形是一致的, 所不同的只是波形的幅值大小。这样的假设显然过于简单了, 其并没有考虑到皮肤、脂肪等对动作电位的滤波作用, 也没有考虑运动电位传播到电极处所需要的传播延迟。事实上，由于皮肤和皮下组织的容积导体效应和电极的不同位置的影响，运动单位的波形在每个电极通道中都是各不相同的。\n\n**要更为准确地描述表面肌电信号，应该考虑下面这样一个的卷积模型，记为模型B：**\n$$\nx_i(t)=\\sum_{j=1}^N \\sum_{\\tau=0}^{L-1} a_{i j}(\\tau) s_j(t-\\tau) + n(t); \\quad i=1,2, \\ldots, M\n$$\n在模型 B 中, $a_{i j}$ 和 $s_j(t)$ 的含义都相对模型 A 发生了较为明显的变化，$n(t)$ 是均值为0的高斯白噪声。 $s_{\\jmath}(t)$ <mark>从运动单位动作电位序列抽象成了运动单位的发放时间序列</mark>。在这里 $s_j(t)$ 是一个<mark>0-1</mark>序列：\n$$\ns_j(t)=\\sum_k \\delta\\left(t-T_j(k)\\right)\n$$\n表示第 $j$ 个运动单位是否在某个时刻 $t$ 发放。 $T_j(k)$ 表示第 $j$ 个运动单位的第 $k$ 次发放时刻, $\\delta$ 表示 delta 函数（Dirac Delta Function）。而模型 A 中 $s_j(t)$ 中的波形信息被转移到了 $a_{i j}$ 中, $a_{i j}$ 从叠加权重变成了波形向量。$a_{\\imath j}(t), \\quad t=0, \\cdots, L-1$ 这个向量就代表第 $j$ 个运动单位在第 $i$ 通道中的波形, 波形长度为 $L$, 同时假设对 $\\forall k \\in N$, 有: $T_j(k+1)-T_j(k)>L$ 。并且对于第 $j$ 个运动单位来说, 其在不同的通道中的波形 $a_{i j}(t)$ 可以是不一样的。简单来说模型 B 的含义便是对某一个通道 $i$ 来说, 第 $j$ 个运动单位的波形与其发放时刻卷积, 就形成了第 $j$ 个运动单位在这个通道中的运动单位动作电位序列, 将所有参与发放的运动单位的运动单位动作电位序列叠加, 就得到该通道采集的表面肌电信号 $x_i(t)$ 。在这个模型中, 有两个假设，这两个假设很重要，涉及到 MUAP 波形的估计：\n- 一个是假设<font color=\"red\">在所有通道中, 运动单位的发放时间是一致的</font>。（运动单位一旦发放，其动作电位便会沿着肌纤维传播开来，被各个电极采集到。至于传播延迟，则可以体现在 $a_{i j}(t)$ 偏移量上面。）\n- 第二个假设便是<font color=\"red\">每个运动单位在某个通道的波形，在信号持续时间段内是不变的</font>。也就是说这是一个Shift-invariant的系统。第二个假设对于肌电信号来说并不是总成立的。比如在肌肉收缩的过程中肌纤维的长度和运动单位到电极的距离都会发生变化，可能会导致动作电位的形变。因此模型B中可以引入时变的因素从而使得模型更为贴切。但是这同时也会让问题变得更加复杂。就目前来说，肌电信号分解往往只考虑肌肉等长收缩(Isometric Contraction)情况，在这种情况下，肌肉组织并不发生形变，可以认为运动单位动作电位在采集过程中是保持一致的。\n\n表面肌电信号分解最主要的目的就是得到单个运动单位的发放信息和波形信息，<mark>其中发放信息最为重要。</mark>事实上如果得到了准确的运动单位的发放信息，就不难得到其波形信息(在运动单位持续发放时间足够长的情况下)，<font color=\"red\">比如可以通过发放位置的平均波形来作为运动单位动作电位波形的估计(Spike Trigger Average,STA)。</font>\n\n若是将FastICA直接应用到用卷积模型描述的肌电信号上，效果会十分不好。可以采用扩展矩阵的策略来解决这个问题。事实上，可以将上述卷积混合模型<mark>进行扩展，以达到近似解卷积的效果。</mark>延迟因子往往根据数据的采样率来确定。一般来说，对于采样率为2kHz的表面肌电信号，K的选择在5个采样点到30个采样点之间会比较合适。  \n\nFastICA输出的结果虽然不能直接被当成运动单位动作电位序列，但是它是对应于某个运动单位动作电位序列滤波后的结果，因此可以从FastICA的输出中提取出不同运动单位的发放时间信息。<font color=\"red\">比如，可以认为FastICA输出中波形的峰值位置就对应着某运动单位的发放时刻。 </font>\n\n## 1.2 sEMG模拟过程\n\n运动单位动作电位的波形则由表面肌电模型从单纤维动作电位(SFAP)开始模拟，运动单位的每一根肌纤维在电极处形成的单纤维动作电位进行叠加便是该运动单位在该电极处的运动单位动作电位(MUAP)，运动单位动作电位与该运动单位的发放时间序列卷积，便是运动单位动作电位序列(MUAPT)，这也是肌电分解想要关注的对象。最后所有参与发放的运动单位动作电位序列进行叠加，便得到表面肌电信号。  \n\n## 1.3 算法评估\n\n![image-20221209151729491](基于盲源分离技术的高密度表面肌电分解/image-20221209151729491.png)\n\n![image-20221211164338861](基于盲源分离技术的高密度表面肌电分解/image-20221211164338861.png)","tags":["Decomposition","博士论文","FastICA"],"categories":["论文","Decomposition"]},{"title":"Accurate identification of motor unit discharge patterns from high-density surface EMG and validation with a novel signal-based performance metric","url":"/2022/12/05/论文/Decomposition/Accurate-identification-of-motor-unit-discharge-patterns-from-high-density-surface-EMG-and-validation-with-a-novel-signal-based-performance-metric/","content":"几乎所有 PNR >30 dB 的 MUs 所表现出的灵敏度>90%（识别出来的 positive / 理论上全部的 positive），虚警率<2%（错误 positive / 错误的 positive、negative 之和）。因此，PNR 中30 dB 的阈值可以作为选择可靠分解单元的简单方法。研究还表明，高密度表面肌电图可在高达最大收缩力70%的情况下可靠分解。<mark>为了提高分解性能 (Holobar and Zazula 2007)，向量 y (n)可以用所有肌电测量的 K 个样本的矢量化块代替。</mark>\n\n<!-- more -->\n\n# 1. 笔记\n\n**为什么要对肌电信号进行扩展**：\n>In order to increase the decomposition performance (Holobar and Zazula 2007), the vector y (n) may be substituted by a vectorized block of K samples from all EMG measurements\n\n## 1.1 PNR\n\n关于分解的准确性，Nawab等人(2010)提出了一种基于信号的验证方法，称为重构-测试程序。然而，这种方法衡量的是分解的一致性而不是准确性(Farina和Enoka 2011, De Luca和Nawab 2011)。McGill 等人(McGill and Marateb 2011)提出了另一种基于信号的方法来分解留置肌电图信号，并利用统计决策理论和贝叶斯框架来整合MU动作电位波形和MU放电模式的信息。该方法计算成本高，目前不适用于超过8个已识别的MUs。\n\nCKC方法已在低收缩力下的代表性模拟和实验信号中得到验证(Holobar et al 2010)。在这项研究中，我们证明了CKC分解也可以在高等长收缩力下提供精确的分解，因此我们将这种方法的潜在应用扩展到几乎任何收缩水平。这一证明是通过与肌内肌电图分解进行比较，以及通过一种基于信号的精度估计的新度量获得的，该度量在本文中通过分析得到，并构成了该研究的第二个贡献。所提出的精度度量建立在线性估计理论基础上，提供了一个计算上便宜且可靠的均方误差(MSE)指标，用于每个已识别MU的真实放电模式与其基于ckc的估计之间。在本研究中，模拟和实验信号分析将表明，这一指标与识别MU放电的敏感性及其虚警率显著相关。\n\nPNR的计算公式：\n$$\n\\mathrm{PNR}(j)=\\mathrm{PNR}(\\hat{t}_j(n))=10\\cdot\\log\\left(\\dfrac{E\\big(\\hat{t}_j^2(n)\\big|_{\\hat{t}_j(n)\\geqslant r}\\big)}{E\\big(\\hat{t}_j^2(n)\\big|_{\\hat{t}_j(n)<r}\\big)}\\right)\n$$\n $E\\big(\\hat{t}_j^2(n)\\big|_{\\hat{t}_j(n)\\geqslant r}\\big)$ 这一项可以由 $E(x|_{t_j(n)=1}) \\approx E(x|_{\\hat{t}_j(n)\\geqslant r})$  这一项代替。$E\\big(\\hat{t}_j^2(n)\\big|_{\\hat{t}_j(n)<r}\\big)$ 这一项可以由 $E(x|_{t_j(n)=0}) \\approx E(x|_{\\hat{t}_j(n)< r})$ 这项代替。\n```matlab\npnr = 10*log10(mean(signal_cluster)/mean(noise_cluster));\n```\n\n## 1.2 实验\n\n9名受试者的优势胫骨前肌和9名受试者中的6名优势肱二头肌同时获得表面肌电图和肌内肌电图信号。在最大自愿收缩(MVC)的5%、10%、15%、20%、50%、60%和70%的等距恒力收缩过程中获得15 s长信号。\n\n## 1.3 数据分析\n\n**仿真数据：**\n下图分别描述了分解灵敏度Se和虚警率Fa对PNR的依赖关系：\n\n![image-20221231161026963](Accurate-identification-of-motor-unit-discharge-patterns-from-high-density-surface-EMG-and-validation-with-a-novel-signal-based-performance-metric/image-20221231161026963.png)\n\n![image-20221231161048995](Accurate-identification-of-motor-unit-discharge-patterns-from-high-density-surface-EMG-and-validation-with-a-novel-signal-based-performance-metric/image-20221231161048995.png)\n\n**实验数据：**\n以肌内肌电图识别的MU放电模式为参考，计算由两种分解技术识别的MU的灵敏度(如式(8))和虚警率(如式(9))。在匹配表面肌电图和肌内肌电图的分解结果时，只有当两个肌电信号共享至少30%的放电时，才被认为是共同识别的。\n\n平滑放电率是收缩强度的函数（<mark>通过对瞬时放电率进行低通滤波计算平滑放电率，截止频率设置为2hz。</mark>）。事实上，胫骨前肌在5% MVC时为11.5±2.1 pps，在70% MVC时为23.2±3.0 pps。同样，在肱二头肌中，MU放电速率在5% MVC时为12.4±2.3 /秒，在70% MVC时为20.3±2.9 /秒。\n\n从合成面肌电信号和实验面肌电信号的结果来看，引入的PNR测量方法与MU放电识别的灵敏度和虚警率显著相关:\n$$\n\\operatorname{Se}(j)=a_1+a_2 \\log \\left(\\operatorname{PNR}(j)-a_3\\right)\n$$\n\n$$\n\\mathrm{Fa}(j)=b_1-b_2 \\log \\left(\\mathrm{PNR}(j)-b_3\\right)\n$$\n\n本研究经实验验证，PNR大于30 dB的大多数MUs灵敏度大于90%，虚警率低于1%。这种关系在很大程度上<mark>独立于</mark>测试的信噪比电平(从0到20 dB)和收缩水平(从5%到70% MVC)。此外，回归参数a和b的值，在不同的信噪比和肌肉兴奋水平上没有显著变化(表1和表2)，允许相对可靠地抽象引入的PNR测量与每个识别MU的分解灵敏度和虚警率之间的一般关系。\n\n识别出的MU的PNR的分布图显示大多集中在30-40dB：\n\n![image-20221231163927905](Accurate-identification-of-motor-unit-discharge-patterns-from-high-density-surface-EMG-and-validation-with-a-novel-signal-based-performance-metric/image-20221231163927905.png)\n\n**结论：**<mark>仿真和实验鉴定的PNR > 30 dB的MUs具有> 90%的灵敏度和低于2%的虚警率。</mark>\n\n","tags":["PNR","JNE"],"categories":["论文","Decomposition"]},{"title":"Multi-channel intramuscular and surface EMG decomposition by convolutive blind source separation","url":"/2022/12/05/论文/Decomposition/Multi-channel-intramuscular-and-surface-EMG-decomposition-by-convolutive-blind-source-separation/","content":"\n这篇文章通过稀疏度来得到分离向量，而不是FASTICA中的非高斯性和独立性。整个分解算法分为两个迭代过程，第一个迭代过程类似于fastICA，第二个迭代过程类似于CKC。该方法的主要假设是，两个运动单元脉冲序列的叠加总是比单个运动单元的叠加更具可变性（方差更大）。\n\n<!-- more -->\n\n# 1.笔记\n\n卷积混合可以表示成扩展向量的线性瞬时混合模型。\n\n卷积混合模型：\n$$\n\\underline{\\underline{x}}(k)=\\sum_{l=0}^{L-1} \\underline{\\underline{H}}(l) \\underline{\\underline{s}}(k-l)+\\underline{\\underline{n}}(k) \\\\\nx_i(k)=\\sum_{l=0}^{L-1} \\sum_{j=1}^n h_{i j}(l) s_j(k-l)+n_i(k) \\\\\n\\underline{\\underline{x}}(k) = \n\\left[\\begin{array}{c}\nx_1(k) \\\\\nx_2(k) \\\\\n\\vdots \\\\\nx_m(k)\n\\end{array}\\right]\n$$\n扩展后的线性瞬时混合模型：\n$$\n\\begin{aligned}\n& \\underline{\\underline{\\tilde{x}}}(k)=\\underline{\\underline{\\tilde{H}}} \\underline{\\underline{\\tilde{s}}}(k)+\\underline{\\underline{\\tilde{n}}}(k) \\\\\n& \\underline{\\underline{\\tilde{s}}}(k)=\\left[\\tilde{s}_1(k), \\tilde{s}_2(k), \\ldots, \\tilde{s}_n(k)\\right]^T \\\\\n& \\underline{\\underline{\\tilde{x}}}(k)=\\left[\\tilde{x}_1(k), \\tilde{x}_2(k), \\ldots, \\tilde{x}_m(k)\\right]^T \\\\\n& \\underline{\\underline{\\tilde{n}}}(k)=\\left[\\tilde{n}_1(k), \\tilde{n}_2(k), \\ldots, \\tilde{n}_m(k)\\right]^T \\\\\n& \\tilde{h}_{i j}= {\\left[\\begin{array}{cccccc}\nh_{i j}[0] & \\cdots & h_{i j}[L-1] & 0 & \\cdots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\cdots & 0 & h_{i j}[0] & \\cdots & h_{i j}[L-1]\n\\end{array}\\right] } \\\\\n& \\underline{\\underline{\\tilde{H}}}= {\\left[\\begin{array}{ccc}\n\\tilde{h}_{11} & \\cdots & \\tilde{h}_{1 n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\tilde{h}_{m 1} & \\cdots & \\tilde{h}_{m n}\n\\end{array}\\right] }\n\\end{aligned}\n$$\n对上述符号的理解就是：\n$$\n\\left.\\underline{\\underline{\\tilde{H}}}=\\left[\\begin{array}{cccc}MUAP_{1,1}(t)&MUAP_{1,2}(t)&\\cdots&MUAP_{1,NR}(t)\\\\\\vdots&\\vdots&\\vdots&\\vdots\\\\MUAP_{NM,1}(t)&MUAP_{NM,2}(t)&\\cdots&MUAP_{NM,NR}(t)\\end{array}\\right.\\right]\n$$\n<mark>注意，这里的MUAPT是扩展后的MUAPT！</mark>\n\n这种分离方法的前提是，<mark>需要满足一个条件：</mark>$R \\geqslant(n / m) L$。因此MUAP相对较长的话需要扩展的多一点来满足上述条件。\n\n> Currently, the only sufficiently validated method for testing the accuracy of EMG decomposition in the absence of a gold standard provided by expert decomposition, is the comparison of the decomposition results of two or more EMG signal sets that share some common sources (discharge timings) (De Luca et al 2006, Holobar et al 2010, Holobar and Farina 2014), but also have a number of different sources and different action potential shapes.  \n\n算法有效性的一种评价方法就是比较分解两套或者多套EMG数据的结果，这些数据必须包含共同的源。\n\n## 1.1 为什么要扩展？\n\n为了增大观测数和源数之间的比例。\n\n> In order to increase the ratio between the number of observations and the number of sources and, thus, conditionality of the described mixing process, the observations are also usually extended, adding R delayed versions of each observation.  \n\n扩展要满足一个要求才能用最小二乘法求解：\n$$\nR\\geqslant(n/m)L\n$$\n上式中R是扩展的参数，n是源的个数，m是观测的通道数，L是MUAP的长度，这在调参的时候需要注意。\n\n由于源的大多数样本为零，因此可以作为尖峰队列这种特定结构，并且在对源扩展了之后也保持了稀疏性。直观地说，这是由于具有相关激发的源的总和总是不如单个源稀疏，除非激发完全一致（可能性非常小）。\n\n扩展系数与识别到的MU数目之间的关系：\n\n![image-20230901214955664](Multi-channel-intramuscular-and-surface-EMG-decomposition-by-convolutive-blind-source-separation/image-20230901214955664.png)\n\n## 1.2 如何执行分离向量的初始化？\n\n对白化后的矩阵，取一列观测向量，先求和，再求平方，峰值最大处可以视为肌肉的激活程度最高，出现运动单元放电的可能性最大，取该列向量来初始化分离向量。\n\n## 1.3 为什么要执行白化？\n\n现实世界中的独立信号往往都是非高斯的，而非高斯信号线性混合后的混迭信号会比源信号更趋近于高斯分布（中心极限定理）。因此可以说“非高斯就是独立的”。为此，算法的目标就由直接度量独立性转变为度量输出的非高斯性，也即是需要使得输出的概率密度距离高斯分布最远。Aapo HyVarinen当时提出使用峭度或者负熵来作为非高斯性度量。<font color = \"red\">信息论指出，在方差一定的情况下，高斯变量具有最大的熵，因此负熵的值恒非负，当且仅当p(y)为高斯分布时候其值为0。因此负熵的值越大则意味着该变量的非高斯性就越强。</font>白化的详细原理参考笔记：[白化学习笔记](白化.md)\n\n## 1.4 如何执行白化？\n\n本文中的白化步骤为：\n\n- 对扩展后的矩阵计算协方差\n- 对协方差矩阵进行特征值分解\n- 计算特征值中最小一半的平均值\n- 将小于平均值的特征值替换成平均值\n- 根据公式得到白化矩阵\n\n正则化过程是为了减小求解的数值不稳定性（基于假设噪声的方差等于最小一半特征值的均值）。这个值太小会引入部分噪声，影响估计；这个值太大会导致一些源信号被忽略掉。\n\nThe coefficient of variation of inter-spike intervals (CVoISI)描述的是相邻脉冲之间的时间间隔的变异系数，这个值应该越小越好。50%以上的MU应该剔除。计算cv时，先对MUST取差分得到间隔，然后用间隔的标准差初一间隔的均值。\n\nRate of Agreement是指采用两种方法分解，并将结果比较，根据计算公式可以看到，这个值是属于0-1的，越接近1说明两种方法的吻合度越高，分解结果也越可信。当RoA大于30%就可以认为是同一个MU。当two source method不可行时，由于SIL于RoA具有高度的线性关系，因此可以通过计算归一化的SIL来检验分解的有效性。\n\nSIL计算公式：\n$$\n\\begin{aligned}\n& \\text{silhouete score}=\\frac{b-a}{max(a,b)}\\\\\n& a=inter-cluster\\;sum\\;of\\;point-to-centroid\\;distances\\\\\n& b=intra-cluster\\;sum\\;of\\;point-to-centroid\\;distances\\\\\n\\end{aligned}\n$$\nSIL称为轮廓系数，由簇内不相似度a(i) ，簇间不相似度b(i) 计算得来，反应的是聚类的效果，SIL计算代码如下：\n\n```matlab\nintra_sums = sum(abs(noise_cluster - noise_centroid)) + sum(abs(peak_cluster - peak_centroid));\ninter_sums = sum(abs(noise_cluster - peak_centroid)) + sum(abs(peak_cluster - noise_centroid));\n\nsil = (inter_sums - intra_sums)/max([intra_sums inter_sums]);\n```\n\ncontrast function既可以衡量独立性，也可以衡量稀疏性，同一脉冲序列的两个不同延迟的线性混合总是比原始脉冲序列更密集。稀疏度是放电速率的函数：放电速率越大，源的稀疏度越低。\n\n人神经的不应期决定了最小的放电间隔（对应放电频率为30-40 pps）\n\n## 1.5 聚类评估\n\n本文中将聚类的SIL阈值设置为了0.9。本文中认为SIL虽然与PNR的定义不同，但是都是可靠的，并且SIL能够直接用于RoA的计算。\n\n## 1.6 伪代码\n\n- 最外层for循环，m次，m为观测通道数\n  - 第一个while循环，fast ICA\n  - 第二个while循环，CKC，这个循环是为了移除错误的尖峰\n\n也就是说分解的源最多就是观测的通道数，但这几乎不可能。（有文章是把这个for循环的m次设置成大于通道数的）\n\n# 2. 算法改进\n\n> Any other criteria for stopping the second iteration would also be acceptable. For example, it would be possible to apply the SIL measure to this second iteration (note that this measure would also increase with the number of iterations, being an efficient criterion for determining convergence).   \n\n","tags":["Decomposition"],"categories":["论文","Decomposition"]},{"title":"等长伸膝动作的运动单元放电特征分析","url":"/2022/12/05/论文/Decomposition/等长伸膝动作的运动单元放电特征分析/","content":"\nCKC算法分解的一篇中文文献，以帮助更好地理解MUAP和MUST，了解CKC算法的具体作用，输入输出，文献中有对CKC算法的概述。\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1 引言\n\n运动神经元负责将脊髓和大脑发出的信息传到肌肉，其放电信息表征着中枢神经系统传输到肌肉的<mark>驱动信息</mark>。运动神经元的动作电位会传输到所支配的肌纤维，引起肌纤维收缩并产生力。运动单元动作电位（motor unit action potential，MUAP）是一个运动单元中所有肌纤维动作电位的叠加。\n\n由于<font color=\"red\">容积导体</font>和<font color=\"red\">幅值抵消</font>现象的存在，表面肌电信号并不能完全地反应神经驱动信息。从表面肌电信号中提取出的时域和频域特征也只能从一定程度上反应神经元放电活动。为了克服表面肌电的固有缺陷，肌电分解（electromyography decomposition）技术逐渐发展起来。基于肌电分解技术可以识别出运动单元的动作电位脉冲串，提取MUAP波形，从而对神经电生理活动进行分析。\n\n基于<mark>盲源分离（blind source separation）</mark>或<mark>模板匹配（template matching）</mark>框架，各种解码算法被相继提出，并且在多肌肉不同收缩状态下得到了验证。\n\n多通道的肌电信号的生成模型是一个多输入多输出的模型，可以看做是一系列神经元放电脉冲串及其动作电位波形的卷积混合： \n$$\nx_i(n)=\\sum_{j=1}^N \\sum_{l=0}^{L-1} h_{i j}(l) s_j(n-l)+\\omega_i(n)\n$$\n\n## 1.2 实验设置\n\n**实验人数**：12人\n\n**MVC 获取**：缓慢增加收缩力至最大值并保持5s，这一过程重复3次，最终计算保持阶段收缩力的平均值作为 MVC\n\n**力曲线设置：**\n\n- 任务1：梯形曲线长度为30 s，包含10 s的上升阶段、10 s的平稳阶段和10 s的下降阶段\n- 任务2：梯形曲线长度为14 s，包含2 s的上升阶段、10 s的平稳阶段和2 s的下降阶段\n\n**力水平设置：**\n\n- 10%MVC  \n- 30%MVC  \n- 50%MVC  \n- 70%MVC  \n\n（每个研究对象需要完成8次伸膝动作（2种曲线 × 4种等级），每次动作之间休息 1~2 min以防止肌肉疲劳）\n\n**通道数**：64 * 2（OT Bioelettronica，Italy ），每一行电极沿肌肉纤维方向\n\n**备皮工作**：用75%的医用酒精棉擦拭皮肤干净，待酒精挥发后利用双面胶海绵垫将电极贴附在相应肌肉的肌腹位置。实验所用的电极为湿电极，使用前需先涂抹导电膏。\n\n## 1.3 数据处理\n\n### 1.3.1 预处理\n\n**EMG预处理：**\n\n1. 采用4阶巴特沃斯滤波器对肌电信号进行20 ~500 Hz的带通滤波；\n\n2. 采用梳状滤波器进行50 Hz阻断滤波以消除工频干扰；\n\n3. 人工判断信号异常的通道并将其去除。\n\n**力信号预处理**：首先升采样至2 048 Hz，然后采用4阶巴特沃斯滤波器进行10 Hz 的低通滤波\n\n### 1.3.2 EMG分解\n\n<mark>股内侧肌和股外侧肌分别解码。</mark>\n\n**步骤：**\n\n1. CKC算法解码HD-sEMG得到MUST；\n2. STA方法提取每个运动单元在每个通道的放电波形MUAP；\n3. 每个MU的MUST和MUAP卷积，所有MU的卷积结果求和得到EMG；\n\n**特征提取：**\n\n- 累积脉冲串（cumulative spike train，CST）特征：对每次动作的肌电信号进行解码得到 MUST，然后将这些 MUST 合并形成 CST， 然后采用400 ms 的汉宁窗对 CST 进行平滑滤波，得到 CST 特征。\n- 主成分分析（principal component analysis，PCA）特征：同样基于 400 ms 的汉宁窗，对每次动作解码得到的所有 MUST 分别进行平滑滤波，然后进行 PCA，提取第一主成分 （first principal component）作为PCA特征。\n- 均方根值（root mean square，RMS）特征：采用滑动窗的方式对每一通道的肌电信号计算RMS，然后对所用通道的 RMS 进行平均形成 RMS 特征。滑动窗为矩形窗，窗长400 ms，每次滑动1个采样点。\n\n### 1.3.3 运动单元追踪\n\nMUAP波形匹配来追踪不同动作之间的运动单元。\n\n### 1.3.4 相关性分析\n\n1. 对每一通道的肌电信号进行2 Hz的低通滤波（4阶巴特沃斯滤波器）；\n2. 对所有通道的低通滤波信号做平均；\n3. 基于互相关分析（标准化法）计算肌电信号和力之间的时移，并将肌电信号或力信号平移到相关性最大的时刻 （<mark>对齐</mark>）。\n\n# 2.结论\n\n一般情况下肌肉中运动单元的募集遵循“大小原则”，即肌纤维数量少、收缩力较小的运动单元先被募集，纤维数量多、收缩力较大的运动单元后被募集。运动单元在被募集的初始阶段，其放电频率较低，后来会随着激活程度的增加（肌肉收缩力的增加）而提高，直至达到最大值，此时放电频率保持稳定，不会再随着激活程度的增加而提高。一般来说，高阈值的运动单元其稳定放电频率要<mark>低于</mark>低阈值的运动单元。\n\n在等长收缩（isometric contraction）中，快速发力会降低运动单元的募集阈值，并且伴随放电频率的增加，因此在快速收缩过程中，更多高阈值运动单元被募集。\n\n从理论上讲，相对于RMS特征，从运动单元放电活动中提取的CST和PCA特征与收缩力之间的相关性应该更高，以往的研究也证明了这一点。但值得注意的是，CST 和 PCA 特征对收缩力的估计效果与运动单元的解码数量非常敏感。由于现有算法的局限性，无法解码出足够多运动单元。如图4a 所示，在收缩力较低时无运动单元放电脉冲被解码到，所以此时CST特征和PCA特征均为零。在运动单元数量足够高的情况下，CST 和 PCA 特征  与收缩力之间的相关性更高。根据研究结果，建议运动单元的解码数量应该在<mark>5</mark>以上。本项研究中虽然CST和PCA特征与力之间的相关性略低于RMS特征，但平均相关系数仍然在 0.8 以上。\n\n","tags":["CST","PCA","上交"],"categories":["论文","Decomposition"]},{"title":"Non-Invasive Analysis of Motor Unit Activation During Simultaneous and Continuous Wrist Movements","url":"/2022/12/05/论文/Characteristic/Non-Invasive-Analysis-of-Motor-Unit-Activation-During-Simultaneous-and-Continuous-Wrist-Movements/","content":"\n文章使用了三种神经特征来对力矩进行估计。分别是CST的放电频率、MUST的放电频率、PCA主成分。这篇文章中使用CKC算法进行分解，使用聚类进行有效MUST的提取。文章实验分为两个session，第一个session考虑单动作，第二个session考虑双动作，把第一个session的动作级联后得到的分离矩阵运用到第二个session的EMG数据中直接分解得到MUST。<mark>文章结果表明CST的鲁棒性是比RMS更好的，EMG通道之间的串扰可能会导致通过RMS力矩估计的准确率降低。</mark>\n\n<!-- more -->\n\n# 1.笔记\n\n## 1.1 Introduction\n\n**不能完全反映神经活动的原因**：\n\n- 容积导体：类似于低通滤波的作用\n- 幅值抵消：由于动作电位的重叠\n\n<mark>植入式电极可以在没有容积导体干扰的情况下直接获得MUAP，因此，MUST可以通过比较和计数MUAP来获得。**MUAP和MUST是一一对应的**</mark>\n\n> With needle/wire electrodes implanted inside the muscle, the motor unit action potentials (MUAP) can be observed without volume conduction and crosstalk. Therefore, the MUST can be obtained by comparing and counting the MUAP.   \n\n之前的研究主要集中在单个自由度的动作，本文选用了手腕关节，手腕关节拥有多自由度。除此之外，运动单元到运动学参数的映射通常使用基于data-driven的模式识别、聚类、主成分分析等方法，并没有把运动单元和动作直接联系起来。\n\n**表面肌电的两类分解算法**：\n\n- Blind source separation\n- Template matching\n\n**Data-driven 和 EMG-driven 的区别**：\n\n​    （1）Data-driven是一个黑箱模型，是model-free的，这里的model指代的是关节运动之类的运动学模型。Data-driven是直接将EMG映射到力/力矩、速度、角位移上，优点是训练完之后，模型的计算速度快。\n\n​    （2）EMG-driven的全称是EMG-driven musculoskeletal model，EMG只是参与计算肌肉活性，通过Hill模型，使用肌肉活性和肌腱长度作为输入来计算个体肌肉力，其核心还是骨骼肌模型（肌肉-肌腱模型、关节运动学模型）。肌肉活性的计算公式如下：\n$$\na_i(t)=\\dfrac{e^{Au_i(t)}-1}{e^A-1}\n$$\n\n## 1.2 Experiment\n\n被试：12，9男性，3女性。\n\n被试被要求在低和中力水平下，执行动态和静态的手腕收缩。一个session包含4个task（对应4个动作），每个task包含3个重复trial。trial之间休息1-2分钟，斌面肌肉疲劳。session中的1个trial用作训练，剩下的trial和session2用作测试。\n\n1. session1包含4个<mark>单自由度</mark>的动作：等长收缩\n   - 伸展\n   - 收缩\n   - 内翻\n   - 外翻\n\n   ![image-20230421204749427](Non-Invasive-Analysis-of-Motor-Unit-Activation-During-Simultaneous-and-Continuous-Wrist-Movements/image-20230421204749427.png)\n\n   平均每个动作识别到 44 ± 13 个运动单元\n\n   ![image-20230421210338235](Non-Invasive-Analysis-of-Motor-Unit-Activation-During-Simultaneous-and-Continuous-Wrist-Movements/image-20230421210338235.png)\n\n2. session2包含4组<mark>两自由度</mark>的动作\n\n![](Non-Invasive-Analysis-of-Motor-Unit-Activation-During-Simultaneous-and-Continuous-Wrist-Movements/image-20221215204556250.png)\n\n​\t注：session2中两个动作的曲线有重叠部分\n\n3. 通道数：使用 3 * 64=192 个电极进行 HD-EMG 的采集。\n\n4. 实验曲线是一个梯形，上升阶段2.5秒，保持5秒水平，下降阶段2.5秒。\n\n## 1.3 Method\n\n文章对session1的动作先进行了级联，级联后进行训练，得到了MUST的分离矩阵和相关参数，然后把这些分离矩阵和相关参数运用到session2的数据中直接得到MUST（session1和session2的动作有区别，session2考虑了动作的协同）。\n\nsession2的task对应session1的哪个MUST分离矩阵呢？——session2包含哪两个动作就用哪两个动作级联。\n\n**EMG分解方法：**\n\nstep1. 使用CKC算法将EMG分解成MUST\n\nstep2. 使用聚类算法（设置聚类的数目为2）区分脉冲和基线噪声（传统的方法采用设置阈值目视检查）\n\n**EMG分解准确率的评价方法：**<mark>PNR (pulse-to-noise)</mark>，PNR与MUST高度相关，并用于间接评估本工作中的<mark>分解性能</mark>，训练的平均PNR大于 25 dB\n\n**神经特征提取：**\n\nMU首先被分组，与动作一一对应，两个动作共同的MU在分析中被忽略。\n\n1. 表征单个运动神经元的放电活动\n   - MUST：把滑动窗口中尖峰的的数量作为 MUST 的实时放电率，使用多元线性回归来拟合 MUST 和弯矩。\n$$\n   y_i=\\sum_{m=1}^{M_i} a_{i m} x_{i m}+b_i\n$$\n\n2. 表征神经对肌肉的共同输入\n   - PCA：从全部 MUST 池中得到的主成分，用主成分表征。PCA：从全部 MUST 池中得到的主成分，用主成分表征。\n   - CST：将 MUST 池划分成两组，对应两个动作，每组中分别得到的 CST，用 CST 的频率作为特征。选取了 300 ms 宽、100 ms 步长的滑动窗口，使用一元线性回归来拟合弯矩和 CST 的放电频率。\n\t\t   $$y_i=a_i x_i+b_i$$\n\t\tCST 的实时放电率与力曲线非常的接近：\n\t\t![image-20230419170121928](Non-Invasive-Analysis-of-Motor-Unit-Activation-During-Simultaneous-and-Continuous-Wrist-Movements/image-20230419170121928.png) \n\t\t如何从 MUST 得到 CST 的参考文献：\n\t\t>Central nervous system modulates the neuromechanical delay in a broad range for the control of muscle force\n\n（这里的CST和MUST都是通过滑动窗口计算的放电频率。除此之外，还提取了时域的RMS来和神经特征作为对比。）\n\n**MUAP分析参数：**\n\n- peak-to-peak value\n- duration\n- area of MUAP（obtained by computing the definite integral of action potentials within the duration.）  \n\n**特征评估：**\n\n- 使用ANOVA来评估3种神经特征对估计的影响\n\n**回归算法：**\n\n- <mark>linear regression model</mark>\n\n## 1.3 Conclusion\n\n1. 运动单元大多数情况下只在一个动作下激活并且可以与这个动作关联起来，这种关联在两个动作时也同样适用，<font color=\"red\">两个动作中同时激活的MU在数据处理中被忽略掉，对应Fig 3.4.5图中的灰线部分</font>。CST已被证明可以代表从脊髓传递到肌肉的共同驱动力，本文结果表明，CST与手腕力矩高度相关\n\n2. RMS用来和神经特征做对比，在训练集上，RMS在大多数情况下性能是优于神经特征的，然而在测试集上，RMS的估计性能会显著降低，CST的估计结果从决定系数和RMSE上来说均显著好于RMS。这说明神经特征的鲁棒性更好\n\n3. RMS性能低下的原因可能是由于：（1）EMG通道之间的串扰；（2）2-DOF下动作电位的叠加，存在幅值抵消的特性\n\n   > _Amplitude cancellationof motor-unit action potentials in the surface electromyogram can be estimated with spike-triggered averaging_\n\n4. 文章尝试直接把MUST映射到力矩的输出上，这比CST的维度更高，但效果并没有比CST好，特别是在光滑度上，CST要优异很多（但是文章适用的是多元线性回归，效果不理想的原因也可能是受限于方法，因为神经元是非线性的，同时，单独考虑MUST可能引入单个MU中的震荡）\n\n5. MUAP的分析结果表明，PPV值在四种动作中明显不同。pronation 和supination 的MUAP激活区域几乎相同；然而flexion 和extension 的激活区域很容易区分\n\n6. PCA能够从多个MUST中提取出低维信息，能够代表从神经驱动。因此比传统的EMG-based的方法有更好的性能\n\n7. MUAP的一些参数能够反映一些肌肉特性，比如MUAP的幅值和长度能够反映肌肉的疲劳程度\n\n8. MUAP的空间信息能够帮助改善力矩的估计\n\n9. MUAP的空间特征在不同被试之间是相似的，这说明这些特征能够用在被试之间的估计\n\n","tags":["MUST","CST","PCA","上交"],"categories":["论文","Characteristic"]},{"title":"基于深度机器学习的体态与手势感知计算关键技术研究","url":"/2022/12/03/论文/Decomposition/基于深度机器学习的体态与手势感知计算关键技术研究/","content":"\n一般来说，基于瞬时肌电图像的手势识别可以被定义为图像分类问题，可以通过标准的有监督学习来解决：<mark>给定具有手势标签的瞬时肌电图像集合作为训练数据，训练一个分类器来识别每一幅新的肌电图像所对应的手势。</mark>\n\n因为电极位移，肌肉疲劳，电极和皮肤之间的阻抗变化等因素的干扰，肌电信号与采集会话高度相关，已经训练好的手势分类器直接被应用在新的会话时通常准确率较低。针对基于肌电信号的会话间手势识别，已有方法通常需要用户在新的会话开始时进行标定，然后使用标定数据来适配模型。 <mark> 基于深度机器学习的领域自适应框架，用于提升基于肌电信号的会话间手势识别的准确率，同时降低模型适配过程中所需要的用户交互的复杂度。  </mark>\n\n<!-- more -->\n\n# 笔记\n\n每个MU激活过程中的<mark>“放电”(discharge)或“发射”(firing)</mark>产生了运动单元动作电位(motor unit action potential，MUAP)。MUAP是组成MU的每个纤维所贡献的电位的总和。","tags":["Image","博士论文","自适应分类器"],"categories":["论文","Decomposition"]},{"title":"表面肌电信号的运动单位动作电位检测","url":"/2022/11/30/论文/Decomposition/表面肌电信号的运动单位动作电位检测/","content":"<!-- more -->\n# 笔记\n\n<mark>肌肉收缩力越大，募集MU越多，sEMG信号MUAP波形间的叠加程度和波形变异越高，分解方法也就不再适用</mark>\n\n","tags":["博士论文"],"categories":["论文","Decomposition"]},{"title":"基于经验模板的表面肌电运动单元动作电位序列分解方法研究","url":"/2022/11/30/论文/Decomposition/基于经验模板的表面肌电运动单元动作电位序列分解方法研究/","content":"\n这篇硕士论文介绍了单纤维动作电位（SFAP），运动单元动作电位（MUAP）的波形，运动单元动作电位与单纤维动作单位的关系，运动单元动作电位序列（MUAPTs）。\n\n<!-- more -->\n\n# 笔记\n\n## MUAP的形成\n\n动作电位形成后由终板沿肌纤维向两侧传导，形成单纤维动作电位（ Single Fiber Action Potential, SFAP）。通常情况下， SFAP 的波形主要由肌纤维直径、肌纤维的相对位置、 AP 传导速度和所使用的检测电极等因素共同决定。 SFAP 波形幅值与肌纤维直径成正比例关系； AP 传导速度越快，相应 SFAP 波形的时程越小。\n\n> 汤晓芙. 神经病学——神经系统临床电生理学(下)(肌电图学及其他)[M]. 北京: 人民军医出版社, 2002.\n>\n> 刘磊，岳文浩. 神经肌电图原理[M]. 北京: 科学出版社, 1983.  \n>\n> 安媛. 手指活动影响前臂多腱肌运动单元募集模式的初步研究[D]. 重庆大学, 2012.  \n\n当运动单元（MU）被激活时，其包含的所有肌纤维的 SFAP 在检测电极处综合叠加形成运动单位动作电位（Motor Unit Action Potential, MUAP），如图 2. 3 所示。从图中可以看出，不同肌纤维的终板位置不同，导致各个 SFAP 传导至检测电极的时延和相位不同；而各肌纤维终板与检测电极的相对距离的最大值决定了此MUAP 的持续时间，SFAP 的时延和相位共同决定了 MUAP 的相位，单相、双相或多相，在正常肌肉中，双相或三相结构的 MUAP 波形是最常见的，只有极少数MUAP 波形呈现多相结构。 \n\n![image-20221130180015342](基于经验模板的表面肌电运动单元动作电位序列分解方法研究/image-20221130180015342.png)\n\n<mark>MUAPT的定义：</mark>\n$$\n\\operatorname{MUAPT}_j(t)=\\sum_{k=1}^{M_j} M U A P_{j k}\\left(t-\\delta_{j k}\\right)\n$$\n其中, MUAP $\\mathrm{jk}$ 表示运动单元$j$ 发放的第 $k$ 个 MUAP; $M_j$ 表示运动单元 $j$ 所发放的 MUAP 总个数; $\\delta_{j k}$ 为运动单元 $j$ 发放的第 $k$ 个 MUAP 在 MUAPT 中出现的时刻点 。\n\n由于神经-肌肉控制系统的复杂性，迄今为止，有关中枢神经系统对 MU募集和 MUAP 的发放特性目前仍是一个未解之谜。经典的理论认为 MU 的募集遵循”大小原理“，即 MU 按体积从小到大的顺序依次募集，较小的 MU 在较低的收缩力水平下兴奋，较大的 MU 在较高的收缩力水平下兴奋。\n\n**MUAP和EMG的关系：**\n\n![image-20221130221730927](基于经验模板的表面肌电运动单元动作电位序列分解方法研究/image-20221130221730927.png)\n\n## MUAP的识别\n\n**造成MUAP波形识别困难的因素：**\n\n1. 波形湮灭：这是 MUAP 波形识别所面临的最大挑战。当某一时刻同时有多个 MUAP 发放时，幅值大的 MUAP 波形就会覆盖掉幅值小的 MUAP 波形；   \n\n2. 波形叠加：除了波形湮灭这种完全叠加以外，如果不同 MU发放的 MUAP 时刻点十分相近， MUAP 波形的部分叠加也会大大增加 MUAP 的识别难度；  \n\n3. 波形相似：不同 MU 所发放的 MUAP 波形具有一定的相似性；  \n\n4. 波形变异：同一 MU 所发放的 MUAP 波形也并非一成不变的，不同肌肉状态下所放的 MUAP 波形存在着一定的差异，如肌肉疲劳时所发放的 MUAP 波形与疲\n   劳前所发放的 MUAP 波形就略为不同  \n\n   ![image-20221130201632205](基于经验模板的表面肌电运动单元动作电位序列分解方法研究/image-20221130201632205.png)\n\n目前， sEMG 信号分解技术可以大致分为<mark>两种类型</mark>：\n\n- 一类是系统辨识法。该方法从系统理论的角度出发，将神经-肌肉系统看作是一个多输入多输出（ MIMO）系统，把 MUAPTs 混合形成 sEMG 信号的假设成是线性混合或是非线性混合的过程。通过盲源分离等方法将多通道 sEMG 信号分解成为不同的分量，所得到的分量中与 MUAP 发放具有相似特性的即看作是 MUAPT。\n\n  ![image-20221130204756672](基于经验模板的表面肌电运动单元动作电位序列分解方法研究/image-20221130204756672.png)\n\n- 另一类是 MUAP 形态学方法。这类方法以 MUAP 的生理背景为基础并未对 MUAPT 的具体混合形式进行假设，是从客观存在的 MUAP 波形特点出发，采用波形检测、波形分类和叠加波形分解的方式进行分解。下面分别对两种不同的 sEMG 分解方法的思路进行叙述。  \n\n除此之外，De Luca团队还提出了<mark>reconstruct-and-test</mark>评价方法：\n\n- 该方法的基本思路是先用 sEMG 分解算法分解得到不同 MUAP 序列，然后，将所分解得到的 MUAP 序列相加，并加入高斯噪声，再完成一次分解。最后，通过对比分析两次分解得到的 MUAP 序列的信息来评价算法的准确性。\n\n  ![image-20221130205514609](基于经验模板的表面肌电运动单元动作电位序列分解方法研究/image-20221130205514609.png)\n\n**综上所述，就现有的 sEMG 分解效果评价方法而言，比较完善的评价方案是先通过仿真 sEMG 信号从理论上验证算法的分解准确性，然后通过实验研究对算法的有效性进行验证。它既克服了同步采集 iEMG 给受试者带来的创伤，又具有比较高的可行度","tags":["硕士论文"],"categories":["论文","Decomposition"]},{"title":"Analysis of motor units with high-density surface electromyography","url":"/2022/11/30/论文/Characteristic/Analysis-of-motor-units-with-high-density-surface-electromyography/","content":"\n这篇文章主要介绍了高密度肌电和侵入式肌电的对比，高密度肌电的必要性，空间滤波和空间采样等等。文章中引出了关于肌电的两种混合模型：1. 线性瞬时混合模型；2.卷积混合模型。这在以前阅读的文章中没有详细提及。文章还引出了获得MUAP的两种方法：1.直接获得；2.STA方法。\n\n<!-- more -->\n\n# 1. 笔记\n\n## 1.1 引言\n\n植入式电极受容积导体的影响小，表面电极受的影响大。由于电信号在组织的扩散作用导致了低通滤波的效果，以及采集电极的限制，表面肌电信号中检测到的不同运动单元的动作电位比较相似，如下图所示：\n\n![image-20221231100101926](Analysis-of-motor-units-with-high-density-surface-electromyography/image-20221231100101926.png)\n\n同时受干扰的表面肌电信号也包含更多的源（因为这个原因，20年前，表面肌电信号被作为经典的干扰信号进行分析，所以叫做*interference signal / interfercence EMG*，采用的是全局变量如RMS等，没有对神经特征进行分析，得到的结论往往不一定正确）。\n\n表面肌电信号运动单元分解并不能取代植入式电极的检测，而是在很多场景下提供了一种非侵入式的分析方法，同时相比于植入式电极，能够分析运动单元的性质，能同时检测多个运动单元。\n\n- **空间滤波 spatial filtering**：空间滤波抵消了容积导体的低通滤波效应，并减少对记录信号有显著贡献的运动单元的数量，还提高了对运动单元动作电位的辨别能力。这是通过高通空间滤波器来实现的，该滤波器增强了肌肉内不同深度的运动单元产生的动作电位之间的振幅差异（二维滤波器，例如拉普拉斯滤波器）。\n\n- **空间采样 spatial sampling**：在多个位置记录表面肌电增强了区分单独运动单元动作电位的能力。\n\n## 1.2 EMG采集技术\n\n**如果记录网格与肌纤维方向一致，则在传播过程中电位幅值在空间分布上保持类似的形状，尽管传播方向上组织的均匀性可能会发生变化。**\n\n![image-20221207174512694](Analysis-of-motor-units-with-high-density-surface-electromyography/image-20221207174512694.png)\n\n神经支配区域、肌纤维膜的平均特征，如动作电位传播速度通常不需要运动单元分解，从表面肌电图分析即可得到。然而，这种方法通常在具有复杂纤维结构的肌肉中失败。脊髓的神经输出和肌电图振幅之间的联系取决于信号产生的许多内在因素，如运动单元电位的正相位和负相位之间的抵消程度。\n\n**高密度的必要性**：仅用几个电极记录动作电位时，表面动作电位差异显著的运动单元数量很少。尽管在某些特殊情况下，运动单元活动只能通过少数表面肌电图通道识别。\n\n![image-20221231112044143](Analysis-of-motor-units-with-high-density-surface-electromyography/image-20221231112044143.png)\n\n以a图为例，尽凭一个电极或者仅凭中间这一列是无法区分出这两个运动电位的。（这张图是怎么的来的呢？同时采集表面肌电信号和侵入式肌电信号，侵入式肌电是比较准确的，把侵入式肌电检测到的运动单元动作电位作为触发事件，通过STA方法得到表面运动单元动作电位）。\n\n## 1.3 分解\n\n模板匹配技术已被提出用于高密度表面肌电图的分解。使用这种方法，动作电位从信号中连续检测出来，并通过将其形状与表示一组运动单元的模板电位相匹配来进行分类，以类似于肌内肌电图分解的方式。这些方法很少分离在时间上重叠的不同运动单元的动作电位，因此往往只能提供不完整的运动单元放电模式。\n\n模板匹配方法的局限性推动了基于盲源分离和高阶统计量的运动单元识别技术的发展。盲源分离方法不依赖于动作电位形状的先验估计，对动作电位的叠加不敏感，是目前最有希望解决表面肌电图分解问题的方法。因此，该技术可以提供完整的单个运动单元放电模式的解码。\n\n盲源分离方法将单个运动单元的贡献建模为统计上独立(或至少弱相关)的信号。然而，除了统计独立性之外，该方法不假设电机单元放电模式的任何其他性质，因此也可以应用于<mark>不规则的脉冲间隔条件</mark>。\n\n为了分离源，提出了两种表面肌电混合过程的数学模型:\n\n- 根据**线性瞬时混合模型**(Garcıá et al, 2005;Nakamura et al, 2004a,b)，将单个运动单元的动作电位按未知因素进行幅值缩放，并求和得到观测到的表面肌电信号。利用该模型，可以有效地解决源分离问题；然而，该模型的局限性在于它没有考虑到不同记录位置的动作电位形状的差异，这是由于容积导体和动作电位传播的卷积效应造成的。\n- 另一方面，**卷积混合模型**(Holobar和Zazula, 2004)将每个电机单元的放电序列表示为离散的二进制源信号，即狄拉克delta函数的和。运动单元动作电位被建模为有限长度因果滤波器的未知脉冲响应，可以是任意形状。因此，基于卷积混合模型的分解技术不依赖于底层肌肉结构，相对于基于瞬时混合模型的方法具有更好的性能。\n\n在卷积分解方法中，卷积核补偿(CKC)方法(Holobar and Zazula, 2007)在不识别底层混合过程的情况下估计单个电机单元的放电模式，从而大大减少了计算时间(Holobar and Zazula, 2004, 2007)。图6显示了当应用于等长、可变力的拇短外展肌收缩过程中记录的信号时，该方法所进行的分解。CKC方法已在模拟和实验条件下对若干肌肉进行了<mark>中等收缩水平</mark>的测试，并已被证明可以提供大量运动单元的放电模式，其精度可与肌内肌电图分解相媲美。\n\n![image-20221231143704490](Analysis-of-motor-units-with-high-density-surface-electromyography/image-20221231143704490.png)\n\n## 1.4 肌纤维属性分析\n\n通过电极网格检测到的运动单元动作电位的空间表示，有可能识别神经支配区和肌腱末梢、纤维长度的位置和纤维取向。\n\n**获得 MUAP 的两种方法**：当通过完全分解识别主动运动单元的放电模式时，表面运动单元电位的空间表示可以直接从<font color=\"red\">分割阶段</font>获得，也可以通过使用识别的发放序列作为触发器对干扰肌电图进行<font color=\"red\">STA</font>获得。","tags":["MUAP","STA"],"categories":["论文","Characteristic"]},{"title":"Tutorial analysis of motor unit discharge characteristics from high density surface EMG signals","url":"/2022/11/24/论文/Decomposition/Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/","content":"包括对全局EMG信号特征的提取与生理学研究中运动单元活动的识别之间的差异的讨论，以及如何获取、检查和分解HDEMG信号的全面指南，以及运动单元放电特征的稳健提取。\n\n<!-- more -->\n\n# 1. 为什么看这篇文献\n\n- 了解运动单元分解的详细流程，如何得到放电时间，希望通过本文章对MUAP和MUST有一个更清晰的认识\n\n# 2. 笔记\n\nHD-EMG分解是一个半自动过程，这是因为需要对分解的结果进行全面的检查。\n\n## 2.1 Introduction\n\n运动单元是一个转换器，把突触对神经的输入转换为力，包含<mark>一组</mark>肌肉纤维和<mark>一个</mark>α运动神经元。神经信息由运动单元通过<mark>轴突动作电位</mark>（即为对肌肉的<font color=\"red\">神经驱动</font>，可以近似表示为MUST）传递，轴突动作电位在受神经支配的<mark>肌肉纤维</mark>中引发动作电位（即为<font color=\"red\">运动单元动作电位MUAP</font>），运动单位动作电位的<mark>总和和时间过程</mark>决定了在运动任务期间用放置在皮肤上的电极记录的表面肌电图（EMG）的特征：\n\n![image-20221125103049582](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221125103049582.png)\n\n上图表明：轴突动作电位和运动单元动作电位之间的一一对应。（**注意**：这里的肌肉应该包含很多运动单元的肌纤维，一个肌纤维只属于一个运动单元，只能接收一个α运动神经元的指令；这里的 MUAPs 已经是经过容积导体后的波形，所以波形的幅值存在差异）。MUAPs 由 MUST 转换而来，但由于容积导体的影响，运动单元动作电位的幅度会变化，并且这些变化并不总是与运动单元的尺寸相关。由于这些效应，肌肉的神经驱动力与 EMG 振幅之间的关联并不总是线性的。对肌肉的神经驱动只能通过运动单元放电时间来估计。\n\n从表面肌电信号中识别MUAPs能够让我们得知个体运动神经元的放电活动。<mark>基于这种方法，运动神经元是人类唯一可以无创记录的神经细胞。</mark>非侵入式高密度表面肌电图提供了皮肤表面运动单元动作电位的空间采样，通过<mark>盲源分离（BSS）</mark>可以识别运动单元放电时间（在等长收缩任务中）。尽管BSS分解程序是以自动方式执行的，但它们需要用户检查已识别的运动单元尖峰序列。\n\n## 2.2 Global EMG estimates vs. Decomposition\n\n运动单元动作电位的特性取决于许多因素，例如，动作电位振幅和传导速度与肌肉纤维的直径成比例；运动单元动作电位的幅度还取决于受神经支配的肌肉纤维的数量，这与运动单元募集阈值（对应于运动单元第一次放电的自愿发力水平，<font color=\"red\">Estimating motor unit discharge patterns这篇文章中采用pps来表示募集阈值？</font>）相关。然而，这种关联受到容积导体的影响，因此受到肌肉纤维和记录电极之间的距离的影响。这导致募集阈值和运动单位动作电位幅值之间的关联通常较弱(<font color=\"red\">?</font>)，这影响了EMG幅值和神经对肌肉的驱动之间的关系，以及EMG幅值和力之间的关联（**总结就是EMG的幅值和<mark>力</mark>以及<mark>神经驱动</mark>之间的关联受到了影响，Fig 2.显示高阈值的运动单元MUAP幅值并不一定高**）。\n\n与EMG幅值分析不同，单个运动单元放电时间的识别提供了对肌肉的神经驱动的直接估计。例如，当从梭形肌肉进行记录时，最好将EMG阵列的中心定位在初级神经支配区上方。在其他类型的肌肉（例如，三角肌）中，BSS对电极阵列的位置不太敏感，尽管电极仍需要放置在肌腹上方。\n\n## 2.3 HD-sEMG Acquisition\n\n<font color=\"red\">电极的放置位置是需要选择的，并不是随便放。</font>在应用高密度电极网格之前，应将皮肤剃光，轻轻研磨，并用酒精溶液和研磨膏清洁（Piervirgili等人，2014）。盲源分离基于这样的假设：\n\n> 运动单元的动作电位是独立唯一的，电极应放置在使得不同MUAP的幅值差异最大的地方。\n\n![image-20221125222351782](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221125222351782.png)\n\n上图中的B和C两图对比，可以看到C图的基线处有高水平的噪声。一个通道（小插图中的灰色线）在较低频率下显示的功率高于所有其他通道，这表明该通道信噪比差。HDEMG信号的公认基线噪声水平约为10–40µV RMS，但这一要求可能随收缩强度而变化。可以通过单极显示而非双极来目视检查异常通道。\n\n根据经验经验，在低EMG振幅下，信号噪声应不超过信号功率的一半，以确保可靠分解。除了电极-皮肤和信号放大器的噪声（信号噪声），EMG分解只能识别相对较少的活动运动单元，未识别到的运动单元的活动是分解过程中的额外噪声源，通常也是主要噪声源。\n\nEMG的带通滤波通常在10-20Hz至400-500Hz之间滤波，能保证EMG的大部分功率。带宽越小，不同运动单元的动作电位的相似性越大。然而，较小的带宽确实会降低噪声水平。如果可能，建议使用零相位滤波器，以避免不同运动单元动作电位的可变延迟，并保持运动单元动作电位的能量集中在短时间间隔内。非线性滤波改变了EMG的混合模型，应该避免。在可用于识别具有低信噪比的信道的方法中，一种方法是通过估计网格中每个电极的功率谱密度并将其与基线进行比较来检查信号的质量。在识别出具有高信噪比的电极之后，可以使用滤波技术（例如陷波滤波器）去除潜在的电力线干扰。\n\n## 2.4 Decomposition\n\n流程：\n\n1. 采集HDEMG记录\n2. 通过BSS分离源（运动单元）\n3. 目视检查\n4. 绘制可靠的识别出的运动单元的光栅图\n\n<mark>BSS程序通常通过迭代优化运动单元分离滤波器并将其应用于EMG信号，一次估计一个运动单元尖峰序列（放电时间）。</mark>完整的流程如下：\n\n![image-20221127212204308](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221127212204308.png)\n\n从上图的标识可以看到，<font color=\"red\">识别出的尖峰序列（spike trains）是存在高低差的</font>，这需要目视检查去掉一些低于阈值的尖峰来调整盲源分离器（调整后应该就从图b变成图B了），目视检查的流程如下图所示：\n\n![image-20221127212445774](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221127212445774.png)\n\n注意看左边图之间的对比，B是在A的基础上设置了一个阈值，去掉了低于阈值的尖峰；重构滤波器，再次应用到HD-sEMG信号中，得到了图C；图C中发现漏掉了两个尖峰，于是再手动加上这两个尖峰。这样人工优化分离器可以得到一个稳定的结果<font color=\"red\">（目前还不知道如何根据放电频率来设置阈值）</font>。<mark>请注意，此部分手动选择仅用于分离器的计算，而不用于分解的输出</mark>。在排除信号质量较差的尖峰序列间隔后，应重新计算电机单元滤波器并将其应用于整个EMG信号，以便重新估计（客观地，无需任何人工干预）整个运动单元尖峰序列。<mark>目前的BSS算法要求EMG信号至少5s以上。</mark>\n\n## 2.5 Decomposition accuracy\n\n评价指标：\n\n- 直接法：双源法（详细的 iEMG和sEMG分解准确率对比可以参考文献《Decoding the neural drive to muscles from the surface electromyogram》）\n- 间接法：\n  - PNR\n  - silhoutette distance\n  - sta后MUAP的比较\n\n所有这些测量都是渐近的，并随着尖峰序列中识别的尖峰的数量增加其精度。因此，它们不应用于评估少于30个尖峰的尖峰序列的准确性（Holobar等人，2014）或评估尖峰序列中每个单个尖峰的准确性。\n\n由于运动单元动作电位形状在等长收缩期间可能发生变化，因此在尖峰触发平均值中应使用相对较少的运动单元放电时间。我们根据经验观察到，3–5秒（约30–100个峰值）足以在持续和快速等长收缩期间稳健地提取运动动作电位波形。\n\n## 2.6 Motor unit properties\n\n根据所识别的运动单元的放电时间，可以识别参与的运动单元的特性。一个关键特性是募集阈值，其对应于第一个运动单元动作电位发生时的力。由运动神经元（肌肉单位）支配的肌肉纤维产生的力以延迟发生，该延迟取决于轴突传导速度和肌肉纤维的性质（主动和被动）。为了获得募集和解除募集阈值的可靠估计，受试者必须练习进行缓慢的线性斜坡收缩。\n\n用于估计募集阈值和测量运动单元放电特性的一种常用方法是梯形力轨迹，控制力的增加和减少率（5–20%MVC/s）至中等平台力（最大力的35–70%）。鉴于目前HD-EMG分解在跨募集阈值均匀采样运动单位方面的局限性，最佳方法是根据测试肌肉和收缩类型使用一系列目标力（最大力的30至70–90%）。\n\n可以从运动单元放电时间中提取的另一个信息是根据募集和解除募集时的放电率估计运动神经元持续内向电流<mark>（persistent inward currents）</mark>的强度。从运动单元动作电位波形的形状，还可以提取其他生理信息。该信息包括电机单元波形的分析，如振幅和传导速度（参见第1-2段和图2）。通过对运动单元放电时间和动作电位波形的分析，可以同时分析神经和外周特性。例如，不同肌肉的运动单元募集阈值和运动单位传导速度之间的强关联。\n\n## 2.7 Motor unit tracking\n\n只有在干预前后能够识别出相同的运动单元时，才能在纵向研究期间（如康复干预后）比较运动单元特性。HD-EMG记录的一个优点是它们通常提供运动单元动作电位的高空间分辨率。对于大型电极网格，两个运动单元在所有通道中显示完全相同的动作电位波形的可能性很小，<mark>这意味着当网格在不同的任务中放置在相似位置时，可以在多个任务中跟踪运动单元，这可以用于跨日跨周的研究当中</mark>。当多个运动单元彼此之间具有高互相关（偶尔发生）时，应将这些运动单元从跟踪中移除。\n\n![image-20221129200045625](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129200045625.png)\n\n![image-20221129200252345](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129200252345.png)\n\n对运动单位的追踪是通过比较运动单位动作电位实现的，一旦某个运动单位被追踪，那么就可以比较在两个session中的放电特性（discharge characteristics）：\n\n- discharge rate\n- recruitment threshold\n\n运动单元募集速度表示连续运动单元之间第一次放电时间的间隔（<font color=\"red\">这个不是很懂，相当于是第一个放电时间竖线之间的间隔？但按照募集的顺序，有的后募集但是在图上体现出放电时间早于先募集的是怎么回事？</font>）\n\n## 2.8 Influencing factors in motor unit decomposition:  \n\n分解算法对以下三个因素很敏感：\n\n- the muscles investigated：\n- the volume conductor properties of the specific subject\n- the contraction intensity：当胫骨前肌的力从35%增加到70%时，识别到的MU数目减少了30%。但是从2.9的结果看，并不是只要强度增加，识别到的MU数目就减少。\n\n同时皮下脂肪厚的被试更可能识别出较少的MUs，这是因为容积导体会使得不同MU信号的带宽减小。\n还没有足够数据来表明性别之间识别出的MU存在差别。\n\n## 2.9 Conclusions\n\n不同肌肉能够识别到的运动单元的数量：\n\n![image-20221129200939603](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129200939603.png) ![image-20221129200953927](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129200953927.png)\n\n# 3. 文章得到了哪些结论\n\n- 动作电位振幅和传导速度，其与肌肉纤维的直径成比例\n- 运动单元动作电位的幅度还取决于受神经支配的肌肉纤维的数量，这与运动单元募集阈值相关\n- 分解的输出结果受肌肉、被试的容积导体性质、以及收缩强度限制。这些限制主要是因为记录电极与肌肉单元之间的距离和肌纤维动作电位的重叠。通常，<mark>随着收缩力的增加，通过分解能够识别的运动单元的数量会减少（<font color=\"red\">只是能够识别的减少了，实际上募集的MU更多了。</font>）</mark>。比如，以胫骨前肌来说，这是一种可靠的分解肌肉（Del Vecchio和Farina，2019；Negro等人，2016a），<font color=\"red\">我们观察到当目标力从最大力的35%增加到70%时，可以识别的运动单元数量减少了30%</font>。同样，对于皮下层较厚的受试者，识别的运动单元数量也有减少的趋势。这些趋势是由于当容积导体减少信号带宽时，不同运动单元的动作电位波形中的辨别信息减少\n- <mark>spike trains</mark>和<mark>discharge times</mark>还是有区别的，spike trains包含了放电的时间，但同时其幅值还代表了权重，但这个权重应该是没有意义的。discharge times对应的是raster\n\n# 4. 文章有哪些疑问\n\n- 互相关图？CST是用来干嘛的，25ms的汉宁窗干嘛的？搞清楚下面几张图：\n\n  ![image-20221129195300583](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129195300583.png) ![image-20221129195313224.png](Tutorial-analysis-of-motor-unit-discharge-characteristics-from-high-density-surface-EMG-signals/image-20221129195313224.png)\n\n- 是不是  <font color=\"red\">虽然识别出来的尖峰幅值存在不同，高低表示MUAP的权重，但这是因为MUAP受传播、容积导体等影响后的结果，而神经驱动理论上来说每一次动作电位的幅值应该是一样的，因此我们估计神经驱动只需要关注放电的时间，所以这才是后面的图中所有竖线都一样长的原因？</font>\n\n","tags":["MUAP","MUST","Decomposition"],"categories":["论文","Decomposition"]},{"title":"Estimating motor unit discharge patterns from high-density surface electromyogram","url":"/2022/11/21/论文/Characteristic/Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/","content":"\n为了进一步理解《A convolutional neural network to identify motor units from high-density surface electromyography signals in real time》，通过这篇文章弄清了这样一个过程：CKC算法分解sEMG得到了MUST（运动单元的放电时间，也叫discharge parttern），MUST通过spike-triggered averaging (STA)方法得到表面MUAP。这篇文章分别通过仿真EMG、拇短展肌、肱二头肌、上斜方肌和股外侧肌实验阐述了MU的募集阈值，放电时间，募集先后，表面MUAP的形成这几方面的研究。\n\n<!-- more -->\n\n# 1. 为什么看这篇文献\n\n- 怎样从高密度机电中识别出运动单元\n- 怎样识别出运动单元的放电时间\n- 卷积核补偿算法是如何运用的\n\n# 2. 笔记\n\n文章是在low-level force-varying contractions条件下进行的。\n\n## 2.1 Introduction\n\n电信号由所有激活的运动单元贡献而成，因此要将合成的EMG信号分解成各个独立的运动单元动作电位（composite signal into its constituent MUAP trains）。活跃运动单元的经典识别方式是由植入式电极来完成的，具有高度的选择性，不会混杂过多的其他运动单元的电信号，<font color=\"red\">但不能代表运动单元中所有的纤维，也不能每次都检测相同的位置。同时，肌纤维的一些属性，如动作电位的传播速度，或者运动单元的解剖特性，如纤维长度、纤维朝向不能确定。</font>\n\n信号分解方面的一些研究（文中提到的以下内容均不能自动识别完整的MU放电模式或是只能同时识别少量激活MU）：<mark>模板匹配；有限元分析；盲源分离；高阶统计</mark>\n\n本文使用**CKC算法**完成：\n\n1. 同时识别大量激活的MU\n2. 跟踪MU募集的早晚(<font color=\"red\">这部分内容需要再详细看一下，募集的时间顺序</font>)\n3. 从不同解剖结构的肌肉中识别MU\n4. 分解得到运动单元动作电位\n\n## 2.2 Data Acquire\n\n13 * 5 采集阵列\n\n信噪比20DB的仿真信号\n\n## 2.3 Materials and methods\n\n### 2.3.1 EMG Signal Simulation\n\n（1）在给定兴奋水平下，决定运动神经元募集和放电时间\n（2）根据每个运动单元的肌纤维的数量、位置、传导速度生成MUAPs\n\n> MU具有正态分布的传导速度，平均值和标准偏差为4.0±0.3 m/s（Farina等人，2000），最小的MU具有最慢的传导速度（Andreassen和Arendt-Nielsen，1987）。属于同一MU的纤维具有相同的传导速度。细胞内动作电位的模拟基于Rosenfalk（1969）的分析描述。\n\n（3）对MUAPs求和模拟sEMG\n\n### 2.3.2 Discharge Pattern\n\n在模拟的12秒长收缩中，肌肉的兴奋水平在前6秒从0%增加到10%，在后6秒从10%下降到0%。在10%激发水平下激活的MU数量为120个中的63个。<font color=\"red\">一旦激发超过指定的募集阈值，每个MU以每秒8个脉冲（pps）的速度放电，并且放电速率随激发线性增加（0.3pps/%）。</font>所有模拟MU的峰值放电速率为35pps。最后一个单位在50%的最大激励下募集。\n\n## 2.4 Experiments\n\n**（1）8名受试者的拇短展肌肌电图的分解结果：**\n\n![image-20221122003643691](Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/image-20221122003643691.png)\n\n募集阈值定义为前5个放电的平均频率，去募集阈值定义为后5个放电的平均频率（这里考虑用倒数来计算，两个放电之间的时间间隔取倒数，然后求平均）。表中MU的性质（瞬时放电率、脉冲间间隔变异性和重构的MUAP形状）需要与已知的生理范围作对比，也就是说需要有一个参考结果，这样才能评估分解精度。\n\n<font color=\"red\">施加的力与所识别MU的数量之间的高度相关性，所识别的MU募集数目随着收缩力的增加而逐渐增加。</font>\n\n新募集的MU以9.0±1.6 pps开始放电，并随着力的增加逐渐增加放电速率（达到15.6±2.1 pps）。在斜坡的下降侧，MU放电速率降低至8.8±1.5 pps，MU以与募集相反的顺序逐渐去募集。MU的募集阈值在研究的力范围内大致均匀分布，并与MU峰值放电率呈负相关。\n\n**（2）从拇短展肌（受试者G）确定的MU的瞬时放电率：**\n\n![image-20221121173352199](Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/image-20221121173352199.png)\n\nsubplot 2 每个点表示给定时刻的MU放电（也就是MUST），灰色线表示施加的肌肉力。subplot 1 描述了MU 5和MU 6的细节。<font color=\"red\">subplot 2 可以看到所有MU募集的过程，随着力的增大，会有新的MU募集。</font>\n\n![image-20221121164528441](Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/image-20221121164528441.png)\n\n<font color=\"red\">这张图中的波形就是MUAP在各个通道处的波形（表面MUAP）！！！注意图注中的STA方法，通过STA可以从MUST得到表面MUAP。CKC方法估计MU放电时间，但不估计动作电位的形状。因此，MUAP形状通过sEMG的spike-triggered averaging（Keenan，2006）来估计，使用识别的MU放电时间作为triggers。</font>\n\n这张图中还有一个值得注意的地方，黑色实心圆圈代表靠近神经处，空心圆圈代表靠近肌肉处，可以看到**神经处的动作电位是要比肌肉处的提前的**。\n\n**（3）仿真sEMG：**\n\nCKC方法对噪声和动作电位叠加都是高度鲁棒的。MUAP trains的总和占总sEMG能量的60%以上。Residual部分主要是由于大量小、深的MU产生的相对较小的MUAP，这些MUAP被分解算法视为<mark>噪声</mark>:\n\n![image-20221121173424122](Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/image-20221121173424122.png)\n\n**（4）肱二头肌、上斜方肌和股外侧肌：**\n\n随着肌力的增加，MU逐渐被募集。并且ramp-down比ramp-up的MUAPs和更接近sEMG.\n\n![image-20221121164612078](Estimating-motor-unit-discharge-patterns-from-high-density-surface-electromyogram/image-20221121164612078.png)\n\n# 3. 文章使用了哪些方法\n\n1. CKC算法分解sEMG和iEMG\n2. 仿真emg，拇短展肌，肱二头肌/上斜方肌/股外侧肌\n\n# 4. 文章得到了哪些结论\n\n1. 通过分解得到的放电时间和植入式电极得到的放电时间的一致性达到了98+-1%\n\n# 5. 文章有哪些疑问\n\n- MUAP和SFAP具体是一个什么形式的波形\n\n  > 每一个肌纤维的活化所产生的运动电势叫做单纤维动作电位（SFAP）。每个运动单位全部肌肉纤维的SFAP共同构成了一个运动单位的动作电位（MUAP）。一旦运动中心下达了一条运动命令，一连串的神经元脉冲就会通过运动神经元的轴突传递到神经肌肉结合处，形成一系列MUAP，并由此构成运动单位动作电位序列（MUAPT）。\n\n  <font color=\"red\"><strong>表面 MUAP 是 MUST 通过 STA 方法得到信号</strong></font>，将其进行代数求和就是表面肌电信号。表面 MUAP 是肌纤维产生的 MUAP 经过脂肪、皮肤等容积导体后在皮肤表面测得的运动单元动作电位，所以不同的 MUAP 的幅值会因为收到影响而不同。<font color=\"red\">SFAP 有待进一步弄清</font>，MU 包含了很多肌肉纤维，SF 是单纤维，<font color=\"red\">之间的波形是否存在差异？</font>同一个运动单元中的放电是由一个神经元决定的，也就是说电信号的源是一样的。\n\n  > SFAP的形式已经弄清，参加文献笔记《*基于经验模板的表面肌电运动单元动作电位序列分解方法研究*》。\n  >\n  > MUAP和SFAP之间的波形是存在差异的，MUAP通常呈现双相或三相结构。\n\n- Reconstructed MU不是很懂\n- 如何通过表面MUAP估计原始的MUAP\n\n  > 估计不了，原始的MUAP经过容积导体滤波后才得到了表面MUAP，这两者比较相似。可以使用fastICA方法估计原MUAP\n\n- 如果CKC是在MU募集后，也就是放电后才能识别到，那么放电时间图上，为什么上面的MU（如果代表着后募集的）存在放电时间先于下面的MU（先募集）\n\n  > 这个不影响数据分析，谁上谁下无所谓","tags":["MUAP","MUST"],"categories":["论文","Characteristic"]},{"title":"Decoding the neural drive to muscles from the surface electromyogram","url":"/2022/11/20/论文/Characteristic/Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/","content":"\n这篇文章主要是介绍了为什么通过sEMG来表示神经驱动是不精确的，然后引出了幅值抵消（amplitude cancellation）这个概念，并举例子说明了幅值抵消带来的影响。相比之下，从sEMG中识别单个运动单元释放动作电位的时间允许更直接地访问神经驱动。然后文章介绍了CKC分解算法，能够得到运动单元的放电时间和在各个通道处的信号。接着，文献将iEMG和sEMG分解得到的放电时间做了个对比，灵敏度能达到90%以上。\n\n<!-- more -->\n\n# 1. 为什么看这篇文献\n\n- 作为文献*Estimating motor unit discharge patterns from high-density surface electromyogram*的补充，解决MUAP和MUST的疑惑\n- 神经驱动\n- 运动单元分解\n\n# 2. 笔记\n\n肌肉：拇短展肌\n\n## 2.1 Introduction\n\n- 产生力的大小是由运动单元的募集数量和发放频率控制的。\n- 运动神经元产生的动作电势通常会沿着肌纤维传导。\n- 运动单元动作电位的波形取决于神经元所支配的肌肉纤维的数目和解剖特性，以及电极的参数。\n- 通过识别单位时间内产生的运动单元动作电位的数量，可以从表面肌电图中量化神经对肌肉的驱动程度。\n\n由表面肌电分解识别的单个运动单元动作电位的发生时间（放电时间）来估计脊髓的运动输出。\n\n## 2.2 Amplitude\n\n通过幅值来估计神经的兴奋程度存在几个弊端：\n\n1. 皮肤表面运动单元动作电位的大小仅与运动单元大小部分相关；\n2. 不同运动单元动作电位对肌电信号振幅的相对贡献可能因条件而异；\n3. 传导到皮肤表面上的动作电势会因外界条件的不同而变化；\n4. 表面动作电位之和小于单个动作电位幅值之和，这是因为不同运动单元动作电位之间存在抵消关系，专业术语为”amplitude cancellation“；\n5. 肌肉疲劳等因素对表面肌电有影响，振幅抵消的量也会发生变化。\n\n`是不是说明，直接通过sEMG来估计力是不准确的。是否应该先通过sEMG来估计相关的运动单元，以及运动单元的放电时间，然后再通过这样一个二维图像来估计力。`\n\n运动单元的活动在不同受试者、条件和肌肉之间是不同的，因此实验过程中EMG的幅值不能用绝对幅值，必须归一化为参考收缩中获得的值，如MVC。\n\n表面肌电图的幅值与单位时间内的动作电位之间的关系并不是简单的线性，因为存在幅值抵消amplitude cancellation。因为低阈值运动单元倾向于产生比高阈值单元更小的表面动作电位，所以低阈值运动单元的表面动作电位通过振幅抵消而降低得更多，特别是对于高水平的肌肉活动。由于这种效应，表面肌电振幅可能对低阈值运动单元的活动变化相对不敏感。\n\n- 在30%MVC的实验中，所有运动单元在实验开始时单位时间内发放的动作电位数量为28%，在实验结束时是61%；\n- 在60%MVC的实验中，所有运动单元在实验开始时单位时间内发放的动作电位数量为52%，在实验结束时是62%；\n\n实验开始时两种力水平的动作电位发放不一样，但结束时却非常接近，而幅值（体现为RMS）上两者并不接近，分别为62%和88%。这之间的差异是由幅值抵消造成的。<font color=\"red\">总而言之，就是EMG幅值的改变并不能真实地反应神经活跃程度的改变。</font>\n\n## 2.3 Decomposition\n\n根据运动单元的形状和位置，每个运动单元由它的模板动作电位表示。高密度肌电中不同运动单元间的动作电位的形状通常不同。即使某两个运动单元的动作电位在某些通道中相同，但其他通道中的微小持续的差别能够通过EMG的分解区别出来。\n\n![image-20221207152750399](Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/image-20221207152750399.png)\n\nCKC算法分解结果和植入式电极分解结果对比：\n\n![image-20221129213713087](Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/image-20221129213713087.png)\n\n<mark>在2.5%到20%MVC力水平下，通过sEMG和iEMG两种信号进行分解可以达到90%以上相同。并且有研究表明肌肉的结构对这种分解方式并没有影响。</mark>\n\n通过表面肌电的分解可以识别的运动单元的数量在受试者、肌肉和条件之间有很大的差异。研究还表明，sEMG分解得到的表面肌电的数目通常比真实的活跃的运动单元少。<font color=\"red\">尽管可以通过表面肌电的分解来识别的运动单元相对较少，但识别出的运动单元的电活动解释了大部分肌电信号。Amplitude和EMG decomposition都偏向于具有最大表面动作电位的运动单元，即大型和浅表运动单元。</font>\n\n![image-20221129213953237](Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/image-20221129213953237.png)\n\n表面EMG的分解目前仅限于低收缩力和等距条件。这些限制不适用于可以在任何条件下容易执行的具有表面EMG振幅的神经激活分析。\n\n![image-20221129214033653](Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/image-20221129214033653.png)\n\n❓<font color=\"red\">搞清楚B是怎么的来的</font>\n\n# 3. 文章得到了哪些结论\n\n- 尽管在某些情况下，可以从相对较少的运动单位推断神经激活的变化（主要是低频成分），但运动神经元特性的更细微调整不能从整体信号中推断出来。例如，在间歇性疲劳收缩期间，低阈值运动单位的恢复阈值和放电率的变化有很大差异。这些变化不能仅从有限数量的单位推断出来，需要更大的样本。此外，运动神经元放电低频分量的相关性强度可能会在肌肉间变化。目前，还没有经过验证的方法可以在自愿收缩过程中识别体内大部分活动运动单位。\n- 从运动单元的放电时间，可以提取到运动神经元池的共同突触输入的特征。\n\n# 4. 文章有哪些疑问\n\n- the interference signal表示什么？根据上下文感觉是sEMG的意思，但是翻译应该是干扰信号的意思\n\n  - 解答：interference EMG signal\n\n- Fig. 2. amplitude cancellation的计算方法。参考文献 *Influence of amplitude cancellation on the simulated surface electromyogram*\n\n  ![image-20221129214555084](Decoding-the-neural-drive-to-muscles-from-the-surface-electromyogram/image-20221129214555084.png)\n\n- Fig. 3. 中(c)表示的是什么，文中说的是动作电位的幅值，但是所有的动作电位的幅值不应该一样吗？\n\n  - 解答：所谓的动作电位幅值一样指的是神经元的去极化动作电位一样，通过频率来反映兴奋强弱。而运动单元动作电位的形状是有可能有区别的，MUAP是由SFAP叠加而来的，因此可能出现双相，三相，多相的MUAP。而MUAP经过容积导体的传导，在各个电极处体现的表面MUAP不一样。\n\n- Fig. 4.中的(c)表示什么，说的是5 * 13的电极阵列，但MU只有12行，并且左上角还缺了一个。MU的动作电位是怎么得到的？<font color=\"red\">as averaged over all the discharge times of each unit.</font>\n\n- Fig. 7. (B)的原理\n\n","tags":["Cancellation","MUST"],"categories":["论文","Characteristic"]},{"title":"Personal Blog Build Tutorial","url":"/2022/11/17/计算机/personal-blog-build-tutorial/","content":"\n这篇文章记录如何使用github page + hexo搭建个人博客（[超详细 Hexo + Github Pages 博客搭建教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/370635512)）。\n\n<!-- more -->\n\n![](personal-blog-build-tutorial/image-20221117231436491.png)\n\n# 1. 环境配置\n\n## 1.1 安装git\n\n在官网下载后直接一路默认安装。安装好git后，需要配置git使其与远程仓库相连：\n\n1. 生成密钥，添加到github的setting。在生成密钥前，需要先配置git的全局别名和邮箱。生成密钥后，进入生成密钥的目录，使用记事本打开id_rsa.pub，复制粘贴到github的SSH配置中。\n\n   > Git使用https协议，每次pull, push都要输入密码，相当麻烦。使用ssh密钥，可以省去每次都输密码。\n\n   ```\n   git config --global user.name \"yourname\"\t#需要添加引号\n   git config --global user.email \"youremail\"\n   ssh-keygen -t rsa -C \"youremail\"\n   ```\n\n   ![image-20221118235600050](personal-blog-build-tutorial/image-20221118235600050.png)\n\n2. git添加远程仓库，这里的origin是远程仓库的别名，这一步必须在git 初始化后的文件夹下操作。\n\n   ```\n   git remote add origin your_repository_ssh_address\n   git branch -M main\n   ```\n\n3. git添加文件到本地仓库并传到远程github仓库（在后续文章的远程推送中，需要在hexo g生成的public文件夹下初始化）\n\n   ```\n   git init\n   git add .\n   git commit -m \"first commit\"\n   git push -u origin main\n   ```\n\n## 1.2 安装node.js\n\n一路默认安装，注意安装图中不要勾选automatically install。\n\n参考链接：[windows 下安装nodejs-百度经验 (baidu.com)](https://jingyan.baidu.com/article/b0b63dbfca599a4a483070a5.html)\n\n## 1.3 安装hexo\n\n在安装好node.js后，直接在cmd中使用npm安装hexo：\n\n```\nnpm install -g hexo-cli\n```\n\n---\n\n# 2. 参数配置\n\n一般来说，参数只需要更改_config.yml文件即可。如果添加了主题，比如我使用了icarus主题，那么带主题名字的config文件是主题的配置文件，而原本就有的config文件是站点的配置文件。\n\n![](personal-blog-build-tutorial/image-20221119001218720.png)\n\n主题配置文件只需要把不需要的部分使用#注释掉即可。站点的config.yml配置文件中要注意两点：\n\n- 设置post_asset_folder为true，这样便于后面能够同步上传图片，解决网页上图片不显示的问题\n- 设置部署网站，如果没有设置，那么即使push到github后，主页打开也是404\n\n![image-20221128221446594](personal-blog-build-tutorial/image-20221128221446594.png)\n\n---\n\n# 3. 图片解决方案\n\nmarkdown对图片的支持不友好，需要设置一下才能使得网页上能够显示图片。\n\n1. 安装插件（注意安装时一定要在 hexo 的工作目录下创建，而不是直接通过 cmd 安装）\n\n   ```\n   npm install hexo-asset-img --save\n   ```\n\n2. 配置 typora（[Typora安装资源](https://www.alipan.com/s/D3MHu8nRn7M) 提取码: cj77）（可以使用 obsidian，学习成本稍高）\n\n   ![](personal-blog-build-tutorial/image-20221119002000517.png)\n\n3. 完成参数设置中的第一点\n\n# 4. 公式解决方案\n\n（可以使用默认的渲染器不需要更改）\n\n教程：[公式解决方案教程博客](https://www.jianshu.com/p/7ab21c7f0674)\n\n\n# 5. 好用的插件\n\n- Hexo-auto-category：可以根据文件目录自动生成网页中的 categories\n[【Hexo插件系列】日志的自动分类插件 hexo-auto-category | ESON](https://blog.eson.org/pub/e2f6e239/)\n- Hexo-blog-encrypt： 实现文章的加密\n[hexo-blog-encrypt/ReadMe.zh.md](https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md)\n\n","categories":["计算机"]}]